
<!-- TOC -->

<ul>
  <li><a href="#1-mybatis缓存机制整体设计">1. Mybatis缓存机制整体设计</a></li>
  <li><a href="#2-二级缓存的基本原理">2. 二级缓存的基本原理</a></li>
  <li><a href="#3-二级缓存的划分">3. 二级缓存的划分</a>
    <ul>
      <li><a href="#31-为每一个mapper分配一个cache缓存对象使用cache节点配置">3.1. 为每一个Mapper分配一个Cache缓存对象（使用<code class="highlighter-rouge">&lt;cache&gt;</code>节点配置）</a></li>
      <li><a href="#32-多个mapper共用一个cache缓存对象使用cache-ref节点配置">3.2. 多个Mapper共用一个Cache缓存对象（使用<code class="highlighter-rouge">&lt;cache-ref&gt;</code>节点配置）</a></li>
    </ul>
  </li>
  <li><a href="#4-开启二级缓存的条件">4. 开启二级缓存的条件</a></li>
  <li><a href="#5-缓存使用顺序">5. 缓存使用顺序</a></li>
  <li><a href="#6-二级缓存的实现方式">6. 二级缓存的实现方式</a></li>
  <li><a href="#7-mybatis自身提供的二级缓存实现">7. Mybatis自身提供的二级缓存实现</a></li>
</ul>

<!-- /TOC -->
<h1 id="1-mybatis缓存机制整体设计">1. Mybatis缓存机制整体设计</h1>

<p><img src="/Image/mybatis/27.png" alt="Mybatis" title="Mybatis" /></p>

<p>  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。</p>

<p>如果用户配置了<code class="highlighter-rouge">"cacheEnabled=true"</code>，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：<code class="highlighter-rouge">CachingExecutor</code>，这时SqlSession使用CachingExecutor对象来完成操作请求。</p>

<p>CachingExecutor对于查询请求，会先判断该查询请求在Application级别的<code class="highlighter-rouge">二级缓存中是否有缓存结果</code>，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。</p>

<h1 id="2-二级缓存的基本原理">2. 二级缓存的基本原理</h1>

<p><img src="/Image/mybatis/28.png" alt="Mybatis" title="Mybatis" /></p>

<p>CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，</p>

<p>CachingExecutor和Executor的关系图</p>

<p><img src="/Image/mybatis/29.png" alt="Mybatis" title="Mybatis" /></p>

<h1 id="3-二级缓存的划分">3. 二级缓存的划分</h1>

<p>Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象</p>
<ul>
  <li>使用<code class="highlighter-rouge">&lt;cache&gt;</code>节点配置 为一个Mapper分配一个Cache缓存对象</li>
  <li>使用<code class="highlighter-rouge">&lt;cache-ref&gt;</code>节点配置 为多个Mapper分配相同的Cache对象</li>
</ul>

<h2 id="31-为每一个mapper分配一个cache缓存对象使用cache节点配置">3.1. 为每一个Mapper分配一个Cache缓存对象（使用<code class="highlighter-rouge">&lt;cache&gt;</code>节点配置）</h2>
<p>MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了<code class="highlighter-rouge">&lt;cache&gt;</code> 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象</p>

<p><img src="/Image/mybatis/30.png" alt="Mybatis" title="Mybatis" /></p>

<p>每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID</p>
<h2 id="32-多个mapper共用一个cache缓存对象使用cache-ref节点配置">3.2. 多个Mapper共用一个Cache缓存对象（使用<code class="highlighter-rouge">&lt;cache-ref&gt;</code>节点配置）</h2>
<p>如果你想让多个Mapper公用一个Cache的话，你可以使用<code class="highlighter-rouge">&lt;cache-ref namespace=""&gt;</code>节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。</p>

<p><img src="/Image/mybatis/31.png" alt="Mybatis" title="Mybatis" /></p>

<h1 id="4-开启二级缓存的条件">4. 开启二级缓存的条件</h1>
<p>二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。</p>

<p>虽然在Mapper中配置了<cache>,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`<select> `节点中配置`useCache="true"`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。</select></cache></p>

<p>如下所示，Select语句配置了<code class="highlighter-rouge">useCache="true"</code>，则表明这条Select语句的查询会使用二级缓存。</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectByMinSalary"</span> <span class="na">resultMap=</span><span class="s">"BaseResultMap"</span> <span class="na">parameterType=</span><span class="s">"java.util.Map"</span> <span class="na">useCache=</span><span class="s">"true"</span><span class="nt">&gt;</span>

</code></pre></div></div>

<p><strong>开启二级缓存的条件</strong></p>

<ol>
  <li>MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true</li>
  <li>该select语句所在的Mapper，配置了<code class="highlighter-rouge">&lt;cache&gt;</code> 或<code class="highlighter-rouge">&lt;cached-ref&gt;</code>节点，并且有效</li>
  <li>该select语句的参数 useCache=true</li>
</ol>

<h1 id="5-缓存使用顺序">5. 缓存使用顺序</h1>
<p>二级缓存 ——&gt; 一级缓存 ——&gt; 数据库</p>

<h1 id="6-二级缓存的实现方式">6. 二级缓存的实现方式</h1>
<p><strong>使用MyBatis的二级缓存有三个选择</strong></p>
<ol>
  <li>
    <p>MyBatis自身提供的缓存实现</p>

    <p>MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等</p>
  </li>
  <li>
    <p>用户自定义的Cache接口实现</p>

    <p>MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在<code class="highlighter-rouge">&lt;cache type=""&gt;</code>节点的type属性上即可</p>
  </li>
  <li>
    <p>跟第三方内存缓存库的集成</p>

    <p>MyBatis还支持跟第三方内存缓存库如Memecached的集成</p>
  </li>
</ol>

<h1 id="7-mybatis自身提供的二级缓存实现">7. Mybatis自身提供的二级缓存实现</h1>
<p>MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。</p>

<p><img src="/Image/mybatis/32.png" alt="Mybatis" title="Mybatis" /></p>

<p>对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：</p>

<ul>
  <li>LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；</li>
  <li>FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；</li>
  <li>Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</li>
</ul>
