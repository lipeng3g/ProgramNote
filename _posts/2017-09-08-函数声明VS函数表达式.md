---
layout: post
title:  "函数声明 VS 函数表达式"
date:   2017-09-08 07:51:29 +0800
categories: JavaScript
---
# 函数声明 VS 函数表达式
JavaScript 中需要创建函数的话，有两种方法：**函数声明**、**函数表达式**，各自写法如下：

**// 方法一：函数声明**

`function foo() {}`

**// 方法二：函数表达式**

`var foo = function () {};`

另外还有一种`自执行函数表达式`，主要用于创建一个新的作用域，在此作用域内声明的变量不会和其它作用域内的变量冲突或混淆，大多是以**匿名函数**方式存在，且`立即自动执行`：
```Javascript
(function () {
    // var x = ...
})();
```
此种自执行函数表达式归类于以上两种方法的第二种，也算是函数表达式。

方法一和方法二都创建了一个函数，且命名为 `foo`，但是二者还是有区别的。JavaScript 解释器中存在一种变量声明被提升（`hoisting`）的机制，也就是说`变量（函数）的声明`会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。

例如以下代码段：
```Javascript
alert(foo); // function foo() {}
alert(bar); // undefined
function foo() {}
var bar = function bar_fn() {};
alert(foo); // function foo() {}
alert(bar); // function bar_fn() {}
```
输出结果分别是`function foo() {}`、`undefined`、`function foo() {}`和`function bar_fn() {}`。

可以看到 `foo` 的声明是写在 `alert` 之后，仍然可以被正确调用，因为 ``JavaScript 解释器``会将其提升到 `alert` 前面，而以函数表达式创建的函数 `bar` 则不享受此待遇。

那么`bar` 究竟有没有被提升呢，其实用 `var` 声明的变量都会被提升，只不过是被先赋值为 `undefined` 罢了，所以第二个 `alert` 弹出了 `undefined`。

所以，`JavaScript` 引擎执行以上代码的顺序可能是这样的：

* 创建变量 `foo` 和 `bar`，并将它们都赋值为 `undefined`。
* 创建函数 `foo` 的函数体，并将其赋值给变量 `foo`。
* 执行前面的两个 `alert`。
* 创建函数 `bar_fn`，并将其赋值给 `bar`。
* 执行后面的两个 `alert`。

**注**

严格地说，再 JavaScript 中创建函数的话，还有另外一种方法，称为“函数构造法”：
```Javascript
var foo = Function('alert("hi!");');
var foo = new Function('alert("hi!");'); // 等同于上面一行
```
此方法以一个字符串作为参数形成函数体。但是用这种方法，执行效率方面会打折扣，且似乎无法传递参数，所以少用为妙。

