<!DOCTYPE html><html lang="zh">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>HashMap源码解析(JDK1.7.0_80) - lipeng's blog</title>
<meta name="description" content="写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，这里以JDK1.7.0_80为例，后续会有关于1.8的记录1. 数据存储结构采用双表结构：数组+单向链表    /**     * 一个空的表实例，用于在表未膨胀时共享。     */    static final ...">
<link rel="canonical" href="http://localhost:4000/ProgramNote/java/2018/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.7.0_80).html"><link rel="alternate" type="application/rss+xml" title="lipeng's blog" href="http://localhost:4000/ProgramNote/feed.xml">
<!-- for Safari on iOS https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/app-icon/ --><link rel="apple-touch-icon" sizes="180x180" href="/ProgramNote/assets/images/logo/icon-180x180.png"><link rel="apple-touch-icon" sizes="167x167" href="/ProgramNote/assets/images/logo/icon-167x167.png"><link rel="apple-touch-icon" sizes="152x152" href="/ProgramNote/assets/images/logo/icon-152x152.png"><link rel="apple-touch-icon" sizes="120x120" href="/ProgramNote/assets/images/logo/icon-120x120.png"><link rel="shortcut icon" href="/ProgramNote/assets/images/logo/icon-120x120.png">
<!-- for Chrome on Android https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/ProgramNote/assets/images/logo/icon-192x192.png">
<!-- for Edge on Windows 10 https://msdn.microsoft.com/en-us/library/dn255024(v=vs.85).aspx --><meta name="msapplication-TileImage" content="/ProgramNote/assets/images/logo/icon-144x144.png"><meta name="msapplication-square310x310logo" content="/ProgramNote/assets/images/logo/icon-310x310.png"><meta name="msapplication-wide310x150logo" content="/ProgramNote/assets/images/logo/icon-310x150.png"><meta name="msapplication-square150x150logo" content="/ProgramNote/assets/images/logo/icon-150x150.png"><meta name="msapplication-square70x70logo" content="/ProgramNote/assets/images/logo/icon-70x70.png">
<meta name="msapplication-TileColor" content="#eeeeee"><link rel="stylesheet" href="/ProgramNote/assets/css/blog.css">
    <style></style>
    <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script></head>
  <body>
    <div class="m-page-stage js-page-stage"><div class="m-page-content"><header class="m-page-header main clearfix"><a class="site-title" title="lipeng's Blog
" href="/ProgramNote/">lipeng's blog</a><div class="site-logo"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#666666;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg></div>
  <nav>
    <ul class="inline-list"><li><a href="/ProgramNote/">主页</a></li><li><a href="/ProgramNote/all.html">归档</a></li><li><a href="/ProgramNote/about.html">关于</a></li><li><a type="application/rss+xml" href="/ProgramNote/feed.xml">RSS</a></li>
    </ul>
  </nav>
</header>
<div class="m-page-main"><div class="m-post">
	<div class="main js-main">
		<div class="col-1">
			<article itemscope itemtype="http://schema.org/BlogPosting">
				<meta itemprop="mainEntityOfPage" itemscope itemType="https://schema.org/WebPage"/>
				<header class="article-header"><h1 itemprop="headline" itemprop="name headline">HashMap源码解析(JDK1.7.0_80)</h1><div class="m-article-data clearfix"><meta itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="lipeng"/></meta><ul class="inline-list tag-wrapper"><li>
          <a class="round-rect-button" href="/ProgramNote/all.html?tag=Java">Java</a>
        </li></ul><div class="other-wrapper"><div class="date-wrapper"><time class="article-meta" datetime="2018-01-06T17:13:08+08:00"
          itemprop="datePublished">2018年 01月06日
        </time></div>
  </div>
</div>
</header>
				<div class="m-article-content js-article-content" itemprop="articleBody"><p><strong>写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，这里以JDK1.7.0_80为例，后续会有关于1.8的记录</strong></p>

<h1 id="1-数据存储结构">1. 数据存储结构</h1>
<p>采用双表结构：数组+单向链表<br />
<img src="http://on8ygi8ap.bkt.clouddn.com/image/blog/HashMap.png" alt="hashmap" title="hashMap" /></p>

<pre><code class="language-Java">    /**
     * 一个空的表实例，用于在表未膨胀时共享。
     */
    static final Entry&lt;?,?&gt;[] EMPTY_TABLE = {};
    /**
     * 该表根据需要调整大小。长度必须始终是2的幂。
     * 用户储存元素的数组，最初定义为空，实例化的时候会调用下面的膨胀表的方法，对Table进行赋值操作
     */
    transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
</code></pre>

<pre><code class="language-Java">    /**
    * 获取一个大于输入值得2的幂次值
    */
    private static int roundUpToPowerOf2(int number) {
        // assert number &gt;= 0 : "number must be non-negative";
        return number &gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;
    }
    /**
     * Inflates the table.
     * 上面说的膨胀表，就是赋值，获取一个2的幂值，然后初始化table
     */
    private void inflateTable(int toSize) {
        //注意，这里tosize其实是默认的表的长度值16，如果使用构造函数初始化，比如指定了长度是5，这里就是5
        //但是，在第一次初始化表的时候调用方式是 inflateTable(threshold); 也就是说上面的5或者16其实是阈值
        //下面一句话就是获取了大于5的2的幂值，使用的是 highestOneBit， 取这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果
        //比如这里获取到的是8，然后通过负载因子和容量，重新计算阈值
        // Find a power of 2 &gt;= toSize
        int capacity = roundUpToPowerOf2(toSize);

        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
        table = new Entry[capacity];
        //这里后面讲，与hash冲突有关
        initHashSeedAsNeeded(capacity);
    }
</code></pre>
<p>下面就是hashmap中实际存储的元素了，元素包括了key，value，hash值，还有一个指针，指向了链表的下一个元素。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>

        <span class="cm">/**
         * Creates new entry.
         */</span>
        <span class="n">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="n">K</span> <span class="n">k</span><span class="o">,</span> <span class="n">V</span> <span class="n">v</span><span class="o">,</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
            <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">&lt;</span><span class="n">code</span><span class="o">....&gt;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h1 id="2-初始化">2. 初始化</h1>
<p>HashMap的构造函数一共有四个</p>
<pre><code class="language-Java">
    public HashMap(int initialCapacity, float loadFactor) {
        //初始化容量不能为负数
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        //如果初始化容量超过最大值，以最大值赋值，最大值 1 &lt;&lt; 30
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子不能为负数
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        //负载因子赋值
        this.loadFactor = loadFactor;
        //阈值为初始化大小，请注意，比如，现在初始化大小是5，那么阈值就设置为5了，但是，在inflateTable方法中有进行了重新计算 ******
        threshold = initialCapacity;
        //这里init方法是空实现，没有任何操作
        init();
    }

    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public HashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        //初始化容量是 16 或者是 通过负载因子计算的数量 的最大值
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
        //请注意，只有这里初始化了，前面三个构造函数都没有初始化操作
        inflateTable(threshold);

        putAllForCreate(m);
    }


    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
            //新增table元素，详细过程略
            putForCreate(e.getKey(), e.getValue());
    }
</code></pre>

<h1 id="3-插入数据-put">3. 插入数据 PUT</h1>
<h2 id="31-插入">3.1. 插入</h2>
<p>代码比较简单</p>
<pre><code class="language-Java">    /**
     * 将指定的值与该映射中的指定键关联。如果映射之前包含了键的映射，则旧值将被替换。
     *
     * @param key 与指定值相关联的键
     * @param value 与指定键关联的值
     * @return 之前与键关联的值，如果没有键映射，则返回null。 （空返回也可以指示映射先前与键关联的是null。）
     */
    public V put(K key, V value) {
        //如果为初始化，需要先膨胀表（初始化链表）
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        //如果键为空，调用放空的方法
        if (key == null)
            return putForNullKey(value);//这里有一点需要注意，key为null的时候，会存储在table的开始位置，也就是table[0]的链表中
        //对key进行hash运算
        int hash = hash(key);
        //把key hash运算的值和表长度按位与操作，获取这个hash值应该放在table的哪一个位置（得到索引编号）
        int i = indexFor(hash, table.length);
        //如果将要放入的索引标号位置有数据了，需要遍历链表，如果有相同的key存在，修改旧数据
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        //当table的 i 位置没有数据或者是hash值计算的i位置相同但是key不同的时候，新建链表或者向链表增加数据
        addEntry(hash, key, value, i);
        return null;
    }
</code></pre>
<h2 id="32-链表新增数据">3.2. 链表新增数据</h2>

<pre><code class="language-Java">    /**
     * 向指定的bucket添加一个具有指定键、值和哈希代码的新条目。如果需要的话，该方法还会调整表的大小。
     *
     * 子类重写此操作以改变put方法的行为。
     */
    void addEntry(int hash, K key, V value, int bucketIndex) {
        //判断是否需要重新调整表的大小
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            //如果调整了表以后，需要重新计算应该放入的链表位置
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
        //把元素放入链表
        createEntry(hash, key, value, bucketIndex);
    }

    /**
     * 就像添加条目一样，只是在创建条目作为映射构建或“pseudo - construction”(克隆、反序列化)的一部分时使用这个版本。这个版本不必担心调整表的大小。
     *
     * 子类重写此操作以改变哈希映射(映射)、克隆和读取对象的行为。
     */
    void createEntry(int hash, K key, V value, int bucketIndex) {
        //把key和value放入一个新的Entry，然后指针指向原来的元素，请注意，这里表示新增的数据始终是位于链表的顶部的！！！
        Entry&lt;K,V&gt; e = table[bucketIndex];
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
        size++;
    }
</code></pre>

<h2 id="33-扩容">3.3. 扩容</h2>

<h3 id="331-扩容条件">3.3.1. 扩容条件</h3>
<p>请注意在上面 <code class="highlighter-rouge">addEntry</code>方法中扩容的条件，表的容量大于阈值并且存储的目标位置不为空就会扩容，实际还有一个触发扩容方法的调用，只要满足前一个条件<strong>表的容量大于阈值</strong>就会触发扩容</p>

<ul>
  <li>阈值 = 容量 * 阈值系数</li>
  <li>容量默认值 16  <code class="highlighter-rouge">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></li>
  <li>阈值系数默认值 0.75 <code class="highlighter-rouge">static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>
    <h3 id="332-扩容过程">3.3.2. 扩容过程</h3>
  </li>
</ul>

<pre><code class="language-Java">/**
     * 将该映射的内容重新映射到具有更大容量的新数组中。当该映射中的键数达到阈值时，将自动调用此方法。
     *
     * 如果当前的容量是最大容量，此方法不会调整映射的大小，而是将阈值设置为整数。最大价值。这就产生了防止未来通话的效果。
     *
     * @param newCapacity 新容量的新容量，必须是2的幂值;除非当前容量是最大容量(在这种情况下，值是不相关的)，必须大于当前容量。
     */
    void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        //如果容量达到最大值，threshold会调整为最大值，实际容量不变
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }
        //新建一个表，然后重新计算索引值
        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        //表扩容完成以后计算新的阈值
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }

    /**
     * 将所有条目从当前表传输到新表。（扩容的实际操作方法）
     */
    void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                //根据hash值重新计算在表中的位置
                int i = indexFor(e.hash, newCapacity);
                //链表的元素存储到e
                e.next = newTable[i];
                //元素赋值
                newTable[i] = e;
                //下一个循环
                e = next;
            }
        }
    }
</code></pre>

<p>上面有个方法叫做 <code class="highlighter-rouge">initHashSeedAsNeeded</code> ，用于表示是否重新计算hash值，后面讲。</p>
<h1 id="4-获取数据-get">4. 获取数据 GET</h1>
<p>请注意，这里获取返回值为null的时候，不一定表示不包含key，也可能是键值就是null，如果要知道是否真的包含，需要调用 <code class="highlighter-rouge">containsKey</code> 方法。</p>

<pre><code class="language-Java">    /**
     * 返回指定键映射的值，或者如果此映射不包含键的映射，则返回{@ code null}。
     *
     * &lt;p&gt;更正式地说，如果这个映射包含一个从键{@代码k}到一个值{@ code}的映射，那么{@ code(key == null ?k == null:key。=(k)}，然后该方法返回{@ code v};否则返回{@ code null}。(最多可以有一个这样的映射。)
     *
     * &lt;p&gt;{@ code null}的返回值不一定&lt; i &gt; &lt;/ i &gt;表示映射不包含键的映射;这也可能是map显式地映射了{@ code null}的键。{@link #containsKey containsKey}操作可以用来区分这两种情况
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        //查找 key == null 的值
        if (key == null)
            return getForNullKey();
        Entry&lt;K,V&gt; entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }

    /**
     * 返回与散列映射中指定键关联的条目。如果哈希映射不包含键的映射，则返回null。
     */
    final Entry&lt;K,V&gt; getEntry(Object key) {
        if (size == 0) {
            return null;
        }
        //计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //根据hash值获取table中的index位置
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            //遍历链表 ，hash值相同， key相同，key不为空，这些条件都满足，就会返回正确的值
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }

    /**
     * get()的卸载版本查找空键。空键映射到索引0。这个空例被拆分为单独的方法，以在两个最常用的操作(get和put)中执行，但在其他操作中加入了条件。
     */
    private V getForNullKey() {
        if (size == 0) {
            return null;
        }
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null)
                return e.value;
        }
        return null;
    }
</code></pre>

<h1 id="5-hash计算和冲突">5. Hash计算和冲突</h1>

<ul>
  <li>hash方法为了让每一位都参与位运算，让相近的数最后通过hash能分散开并减少碰撞，采用了多次位移和异或，当然多一次与key的hashCode异或，也是为了尽量减少碰撞；</li>
  <li>hashSeed也是一个非常重要的角色，可以把它看成一个开关，如果开关打开，并且key的类型是String时可以采取sun.misc.Hashing.stringHash32方法获取其hash值。</li>
</ul>

<pre><code class="language-Java">    /**
     * 检索对象哈希代码，并将一个附加的哈希函数应用到结果散列中，以防止糟糕的质量哈希函数。这很重要，因为哈希映射使用的是2的幂值的哈希表，否则就会遇到在较低位上没有差异的哈希码的冲突。
     * 注意:空键总是映射到哈希0，因此索引0。
     */
    final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        // 这个函数可以确保在每个位位置上只有 
        // 常数倍数不同的哈希码有一个有界
        // 数的碰撞(默认负载系数约为8)。
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }
</code></pre>

<p>上面一直没有说的<code class="highlighter-rouge">initHashSeedAsNeeded</code>方法在这里就又用除了，hashSeed的默认值是0，hashSeed会在capacity发生变化的时候调用initHashSeedAsNeeded方法重新计算</p>

<pre><code class="language-Java">
    /**
     * 初始化哈希掩码值。我们推迟初始化，直到我们真正需要它。
     */
    final boolean initHashSeedAsNeeded(int capacity) {
        boolean currentAltHashing = hashSeed != 0;
        boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp;
                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean switching = currentAltHashing ^ useAltHashing;
        if (switching) {
            hashSeed = useAltHashing
                ? sun.misc.Hashing.randomHashSeed(this)
                : 0;
        }
        return switching;
    }
</code></pre>

<p>hashSeed的计算流程涉及到一个设定值<code class="highlighter-rouge">Holder.ALTERNATIVE_HASHING_THRESHOLD</code>，该设定值是通过JVM的参数<code class="highlighter-rouge">jdk.map.althashing.threshold</code>来设置的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>注：
在JDK 8 中，hashSeed已经被移除掉了，移除掉的原因是调用sun.misc.Hashing.randomHashSeed计算hashSeed时会调用方法java.util.Random.nextInt()，该方法使用AtomicLong，在多线程情况下会有性能问题。
</code></pre></div></div>

<p>关于是否会更新hashSeed的问题，自己不太明白，这里有个知乎的解释</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>我们来看switching 的取值方法，是cur和use的异或，cur表示已经有seed，use表示capcity超过了阈值，需要use alternative。那么它们的异或就表示，当没有seed且需要use时；或者当有seed且不需要use时，switch才为true，特别的，switch为true时，如果需要alternative，则seed赋值为一个新的随机值，如果是已有seed则把seed置零。
</code></pre></div></div>

<h1 id="6-其他">6. 其他</h1>

<ol>
  <li>如果可以预估数据量，在创建HashMap实例时，设置合适的初始容量，可以减少扩容操作，提升性能。</li>
  <li>将容量设置为2的n次方性能最好，如：16，32。原因：和HashMap的indexFor方法实现有关。</li>
  <li>用作Key的对象须实现equals和hashCode方法。如果用String对象作Key，就不用自己实现equals和hashCode方法，因为String对象已经实现。</li>
  <li>HashMap是非线程安全的，在多线程并发操作时会出现死循环。原因：执行扩容操作时，将旧表中的数据插入新表时有可能导致单向链表形成闭环。</li>
  <li>HashMap在普通的构造函数，也就是默认不放入任何值的构造函数中，不初始化table，只有在put或者是使用两外一个map初始化的时候才会初始化table</li>
  <li>默认情况下，<strong>初始化的时候阈值就是table的初始化长度</strong>，只有调用resize以后，<strong>阈值 = 长度 * 负载因子</strong></li>
</ol>

<p><strong>参考</strong></p>

<p><a href="http://aofengblog.blog.163.com/blog/static/631702120147148919858/">JDK HashMap源码分析 | HashMap Source Code Analysis</a><br />
<a href="https://www.jianshu.com/p/a11b9c1002f1?from=singlemessage">Java中的HashMap</a><br />
<a href="https://www.zhihu.com/question/58679855">HashMap关于更换hashseed疑问？</a></p>

</div>
				<footer><meta itemprop="dateModified" content="2018-01-06T17:13:08+08:00"><div class="article-license"><div class="m-license"><div class="clearfix"><a class="octocat" href="https://github.com/https://github.com/lipeng3g/ProgramNote/tree/master/_posts/04-Java/2018-01-06-HashMap源码解析(JDK1.7.0_80).md">
        <img alt="View on Github" src="/ProgramNote/assets/images/octocat.jpg" />
      </a><p><a href="https://github.com/https://github.com/lipeng3g/ProgramNote/tree/master/_posts/04-Java/2018-01-06-HashMap源码解析(JDK1.7.0_80).md">在 Github 上查阅此文。</a></p><p>本文遵守 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> 许可协议。</p><a class="license" rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
      <img alt="Creative Commons License" src="/ProgramNote/assets/images/license-cc4.png" />
    </a><p>欢迎转载，转载需注明出处，且禁止用于商业目的。</p>
  </div>
</div></div>
				</footer><section></section></article>
		</div>
		<div class="col-2">
			<aside class="js-article-aside"><div class="m-toc js-toc"></div></aside>
		</div>
	</div>
</div>

<script src="//cdn.bootcss.com/toc/0.3.2/toc.min.js"></script>
<script type="text/javascript">
	window.throttle = function(func, wait) {
	  var args, result, thisArg, timeoutId, lastCalled = 0;

	  function trailingCall() {
	    lastCalled = new Date;
	    timeoutId = null;
	    result = func.apply(thisArg, args);
	  }
	  return function() {
	    var now = new Date,
	      remaining = wait - (now - lastCalled);

	    args = arguments;
	    thisArg = this;

	    if (remaining <= 0) {
	      clearTimeout(timeoutId);
	      timeoutId = null;
	      lastCalled = now;
	      result = func.apply(thisArg, args);
	    } else if (!timeoutId) {
	      timeoutId = setTimeout(trailingCall, remaining);
	    }
	    return result;
	  };
	}
	$(function() {
	  var $window = $(window);
	  var $pageStage = $('.js-page-stage');
	  var $pageMain = $('.js-main');
	  var $pageFooter = $('.js-page-footer');
	  var $articleContent = $('.js-article-content');
	  var $articleAside = $('.js-article-aside');
	  var $toc = $('.js-toc');
	  var hasTitle = $articleContent.find('h1, h2, h3').length > 0;

	  function asideSticky() {
	    return $window.outerWidth() > 1150 && $pageStage.hasClass('has-toc');
	  }

	  function setTocClass() {
	    if (hasTitle) {
	      !$pageStage.hasClass('has-toc') && $pageStage.addClass('has-toc');
	    }
	  }

	  setTocClass();

	  function setAsideTOC() {
	    var asideTop, asideLeft, scrollBottom, asideBottomTop, lastScrollTop;

	    function init() {
	      var asideOffset = $articleAside.offset();
	      var footerOffset = $pageFooter.offset();
	      var mainOffset = $pageMain.offset();
	      asideTop = mainOffset.top;
	      asideHeight = $toc.outerHeight() + parseInt($articleAside.css('padding-top'), 10) + parseInt($articleAside.css('padding-bottom'), 10);
	      asideLeft = mainOffset.left + $pageMain.outerWidth() - $articleAside.outerWidth() - parseInt($pageMain.css('padding-right'), 10);
	      scrollBottom = footerOffset.top - asideHeight;
	      asideBottomTop = scrollBottom - mainOffset.top;
	    }

	    function setAside(force) {
	      force !== true && (force = false);
	      var scrollTop = $window.scrollTop();
	      if (scrollTop >= asideTop && scrollTop <= scrollBottom) {
	        (!force && lastScrollTop >= asideTop && lastScrollTop <= scrollBottom) ||
	        $articleAside.addClass('fixed').css({
	          left: asideLeft + 'px',
	          top: 0
	        });
	      } else if (scrollTop < asideTop) {
	        (!force && lastScrollTop < asideTop) ||
	        $articleAside.removeClass('fixed').css({
	          left: 0,
	          top: 0
	        });
	      } else {
	        (!force && lastScrollTop > scrollBottom) ||
	        $articleAside.removeClass('fixed').css({
	          left: 0,
	          top: asideBottomTop + 'px'
	        });
	      }
	      lastScrollTop = scrollTop;
	    }
	    asideSticky() && (init(), setAside());
	    $window.on('scroll', function() {
	      asideSticky() && setAside();
	    });
	    $window.on('resize', throttle(function() {
	      setTocClass();
	      asideSticky() && (init(), setAside(true));
	    }, 100));
	    setTimeout(init, 4000);
	  }
	  setTimeout(setAsideTOC, 1000);

	  $toc.toc({
	    'selectors': 'h1,h2,h3',
	    'container': '.js-article-content',
	  });
	});
</script></div>
</div>
</div><div class="m-page-footer js-page-footer">
  <div class="main">
    <aside><div class="follow-me"><ul class="inline-list" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lipeng">
    <link itemprop="url" href="http://localhost:4000/"><li title="在 Github 上关注我。">
        <div class="round-button github">
          <a itemprop="sameAs" href="https://github.com/lipeng3g" target="_blank">
            <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
          </a>
        </div>
      </li></ul><p class="email">
      <a title="给我发邮件。" href="mailto:lipeng3g@gmail.com" target="_self">lipeng3g@gmail.com</a>
    </p></div>
</aside>
    <footer class="site-info">
      <p>© lipeng's blog 2015 - 2017</p>
      <p>Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a succinct theme for blogging." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.</p>
    </footer>
  </div>
</div><script>
      $(function() {
        // display coding language
        $(".highlight").each(function() {
          $(this).attr("data-lang", $(this).find("code").attr("data-lang"));
        });
      });
    </script></body>
</html>
