<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ProgramNote/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ProgramNote/" rel="alternate" type="text/html" hreflang="zh" /><updated>2018-01-09T21:50:10+08:00</updated><id>http://localhost:4000/ProgramNote/</id><title type="html">lipeng’s blog</title><subtitle>lipeng's Blog
</subtitle><author><name>lipeng</name><email>lipeng3g@gmail.com</email></author><entry><title type="html">HashTable源码解析(JDK1.8.0_131)</title><link href="http://localhost:4000/ProgramNote/java/2018/01/09/HashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html" rel="alternate" type="text/html" title="HashTable源码解析(JDK1.8.0_131)" /><published>2018-01-09T19:28:41+08:00</published><updated>2018-01-09T19:28:41+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/09/HashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/09/HashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html">&lt;h1 id=&quot;1-数据结构&quot;&gt;1. 数据结构&lt;/h1&gt;
&lt;p&gt;JavaDoc中这样描述 &lt;code class=&quot;highlighter-rouge&quot;&gt;这个类实现了一个哈希表，它将键映射到值。任何非空对象都可以用作键或值。要成功地从哈希表中存储和检索对象，用作键的对象必须实现hashCode方法和equals方法。&lt;/code&gt;&lt;br /&gt;
HashTable依然是一个散列表，和HashMap（JDK1.7，在1.8里面HashMap中包含红黑树）类似，底层实现都是&lt;code class=&quot;highlighter-rouge&quot;&gt;数组 + 链表&lt;/code&gt;，同时都要求 存储对象实现hashCode方法和equals方法。&lt;br /&gt;
注意，和HashMap不同的是，HashTable不允许 key 或者 value 为空，否则会抛出异常。&lt;/p&gt;

&lt;h1 id=&quot;2-构造函数&quot;&gt;2. 构造函数&lt;/h1&gt;
&lt;p&gt;HashTable一共有四个构造函数，先从简单的看起&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 创建一个新的、空的HashTable，初始化的大小是 11， 负载因子是 0.75.
     */
    public Hashtable() {
        this(11, 0.75f);
    }

    /**
     * 创建一个新的、空的HashTable，初始化大小是指定的初始化容量，负载因子是 0.75.
     *
     * @param     initialCapacity   the initial capacity of the hashtable.
     * @exception IllegalArgumentException if the initial capacity is less
     *              than zero.
     */
    public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }

    /**
     * 创建一个新的、空的HashTable，初始化容量和负载因子均有参数指定
     *
     * @param      initialCapacity   the initial capacity of the hashtable.
     * @param      loadFactor        the load factor of the hashtable.
     * @exception  IllegalArgumentException  if the initial capacity is less
     *             than zero, or if the load factor is nonpositive.
     */
    public Hashtable(int initialCapacity, float loadFactor) {
        //初始化容量小于0，抛出异常
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        //负载因子必须为正值，否则抛出异常
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);
        //初始化容量最小为 1
        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        //初始化 Table，指定大小（请注意，这里初始化了，HashMap是在put或者扩容中初始化的，和这里是不同的）
        table = new Entry&amp;lt;?,?&amp;gt;[initialCapacity];
        //根据初始化大小，计算扩容阈值
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于容量的最大值，这里有些不同，请看下面的说明。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 要分配的最大数组大小。 一些虚拟机在数组中保留一些标题字。 尝试分配较大的数组可能会导致OutOfMemoryError：请求的数组大小超过VM限制
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 Table中的元素 Entry，和HashMap中基本完全一致，这里不做详细记录。&lt;/p&gt;

&lt;p&gt;最后一个构造函数是使用集合数据进行初始化操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 使用指定的map来初始化。
     * 初始化容量是通过 Math.max(2*t.size(), 11) 来计算的。
     *
     * @param t the map whose mappings are to be placed in this map.
     * @throws NullPointerException 注意，如果 t 为空，会抛出异常
     * @since   1.2
     */
    public Hashtable(Map&amp;lt;? extends K, ? extends V&amp;gt; t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-新增元素&quot;&gt;3. 新增元素&lt;/h1&gt;

&lt;p&gt;我们接着上面的构造方法继续往下看&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 将指定映射的所有映射复制到这个散列表。这些映射将替换此hashtable对当前指定映射中任何键的任何映射。
     *
     * @param t mappings to be stored in this map
     * @throws NullPointerException 注意，如果 t 为空，会抛出异常
     * @since 1.2
     */
    public synchronized void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; t) {
        for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : t.entrySet())
            put(e.getKey(), e.getValue());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后调用 put 方法，put方法在插入时首先判断value是否为空，不为空的时候执行插入操作，如果以前存在该key，执行更新操作，并且返回旧值&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * 将指定的键映射到此散列表中的指定值。 value和key都不能为空。
     * 
     * 可以通过使用与原始键相等的键调用get方法来检索该值。
     *
     * @param      key     the hashtable key
     * @param      value   the value
     * @return     如果有值，返回旧值，否则返回 null
     * @exception  NullPointerException  如果key或者value为空会抛出异常
     * @see     Object#equals(Object)
     * @see     #get(Object)
     */&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果value为空，抛出异常&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NullPointerException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Makes sure the key is not already in the hashtable.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?,?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//请注意，这里直接调用了 key 的hashCode方法，也就是说，如果你的key == null， 那么这里会抛出空指针异常的。&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//0x7FFFFFFF = 2^31 -1，这里计算table的index的方式和hashmap是有区别的&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7FFFFFFF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@SuppressWarnings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//如果已经存在了，覆盖原来的值，并返回原来的值&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//如果不存在，执行插入操作&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果之前不存在，那么执行新增操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    private void addEntry(int hash, K key, V value, int index) {
        modCount++;
        //如果达到扩容限制，进行扩容操作
        Entry&amp;lt;?,?&amp;gt; tab[] = table;
        if (count &amp;gt;= threshold) {
            //扩容（稍后讲解具体过程）
            rehash();

            tab = table;
            hash = key.hashCode();
            index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        }

        // Creates the new entry.
        @SuppressWarnings(&quot;unchecked&quot;)
        //获取table中的链表存储的entry对象
        Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) tab[index];
        //定义一个新的entry，并且把指针指向旧的entry对象（这里多说一句，很明显hashtable把插入的值放在了链表的头位置，hashmap1.8的版本中，插入位置是链表的结尾，而HashMap1.7版本是插入在头位置的，这里需要注意）
        tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
        count++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在HashTable中还有一个 putIfAbsent 方法，基本和put相同，不同的是，只有key不存在的时候或者是key存在但是value == null 的时候才会添加成功。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    public synchronized V putIfAbsent(K key, V value) {
        Objects.requireNonNull(value);

        // Makes sure the key is not already in the hashtable.
        Entry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings(&quot;unchecked&quot;)
        Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;)tab[index];
        for (; entry != null; entry = entry.next) {
            if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) {
                V old = entry.value;
                if (old == null) {
                    entry.value = value;
                }
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4-扩容&quot;&gt;4. 扩容&lt;/h1&gt;
&lt;p&gt;在put的时候会执行一个 rehash 方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;protected void rehash() {
        int oldCapacity = table.length;
        Entry&amp;lt;?,?&amp;gt;[] oldMap = table;

                // overflow-conscious code
        //这里需要注意，扩容不是 * 2，而是 *2 + 1，比如开始是11，扩容以后是 23！
        int newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1;
        //最大值限制
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        //创建一个新的map
        Entry&amp;lt;?,?&amp;gt;[] newMap = new Entry&amp;lt;?,?&amp;gt;[newCapacity];

        modCount++;
        //计算新的扩容阈值
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap;
        //遍历原来的table，放入新的map中，这里可能会把一个链表拆分到table的多个位置上
        for (int i = oldCapacity ; i-- &amp;gt; 0 ;) {
            for (Entry&amp;lt;K,V&amp;gt; old = (Entry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != null ; ) {
                Entry&amp;lt;K,V&amp;gt; e = old;
                old = old.next;

                int index = (e.hash &amp;amp; 0x7FFFFFFF) % newCapacity;
                e.next = (Entry&amp;lt;K,V&amp;gt;)newMap[index];
                newMap[index] = e;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5-取值-get&quot;&gt;5. 取值 get&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 返回指定键映射到的值;如果此映射不包含键映射，则返回null。
     * 更正式地说，如果这个映射包含从关键字k到值v的映射（key.equals（k）），那么这个方法返回v; 否则返回null。 （最多可以有一个这样的映射。） 
     */
    public synchronized V get(Object key) {
        Entry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        for (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-遍历&quot;&gt;6. 遍历&lt;/h1&gt;

&lt;p&gt;说遍历以前，先看下面两个方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * Returns an enumeration of the keys in this hashtable.
     *
     * @return  an enumeration of the keys in this hashtable.
     * @see     Enumeration
     * @see     #elements()
     * @see     #keySet()
     * @see     Map
     */
    public synchronized Enumeration&amp;lt;K&amp;gt; keys() {
        return this.&amp;lt;K&amp;gt;getEnumeration(KEYS);
    }

    /**
     * Returns an enumeration of the values in this hashtable.
     * Use the Enumeration methods on the returned object to fetch the elements
     * sequentially.
     *
     * @return  an enumeration of the values in this hashtable.
     * @see     java.util.Enumeration
     * @see     #keys()
     * @see     #values()
     * @see     Map
     */
    public synchronized Enumeration&amp;lt;V&amp;gt; elements() {
        return this.&amp;lt;V&amp;gt;getEnumeration(VALUES);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们遍历HashMap的时候至少可以使用下面的三种方法进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;        //1、使用keys()
        Enumeration&amp;lt;String&amp;gt; en1 = table.keys();
            while(en1.hasMoreElements()) {
            en1.nextElement();
        }

        //2、使用elements()
        Enumeration&amp;lt;String&amp;gt; en2 = table.elements();
            while(en2.hasMoreElements()) {
            en2.nextElement();
        }

        //3、使用keySet()
        Iterator&amp;lt;String&amp;gt; it1 = table.keySet().iterator();
            while(it1.hasNext()) {
            it1.next();
        }

        //4、使用entrySet()
        Iterator&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; it2 = table.entrySet().iterator();
            while(it2.hasNext()) {
            it2.next();
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;7-其他&quot;&gt;7. 其他&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;HashTable的很多方法都是用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;，表示它线程安全的，这一点是和HashMap不同的
    &lt;ul&gt;
      &lt;li&gt;从Java 2平台v1.2开始，这个类被改进来实现Map接口，使它成为Java集合框架的成员。 与新的集合实现不同，Hashtable是同步的。 如果不需要线程安全的实现，建议使用HashMap来代替Hashtable。 如果需要线程安全的高度并行实现，则建议使用java.util.concurrent.ConcurrentHashMap来代替Hashtable。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">1. 数据结构 JavaDoc中这样描述 这个类实现了一个哈希表，它将键映射到值。任何非空对象都可以用作键或值。要成功地从哈希表中存储和检索对象，用作键的对象必须实现hashCode方法和equals方法。 HashTable依然是一个散列表，和HashMap（JDK1.7，在1.8里面HashMap中包含红黑树）类似，底层实现都是数组 + 链表，同时都要求 存储对象实现hashCode方法和equals方法。 注意，和HashMap不同的是，HashTable不允许 key 或者 value 为空，否则会抛出异常。 2. 构造函数 HashTable一共有四个构造函数，先从简单的看起 /** * 创建一个新的、空的HashTable，初始化的大小是 11， 负载因子是 0.75. */ public Hashtable() { this(11, 0.75f); } /** * 创建一个新的、空的HashTable，初始化大小是指定的初始化容量，负载因子是 0.75. * * @param initialCapacity the initial capacity of the hashtable. * @exception IllegalArgumentException if the initial capacity is less * than zero. */ public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } /** * 创建一个新的、空的HashTable，初始化容量和负载因子均有参数指定 * * @param initialCapacity the initial capacity of the hashtable. * @param loadFactor the load factor of the hashtable. * @exception IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive. */ public Hashtable(int initialCapacity, float loadFactor) { //初始化容量小于0，抛出异常 if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); //负载因子必须为正值，否则抛出异常 if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); //初始化容量最小为 1 if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; //初始化 Table，指定大小（请注意，这里初始化了，HashMap是在put或者扩容中初始化的，和这里是不同的） table = new Entry&amp;lt;?,?&amp;gt;[initialCapacity]; //根据初始化大小，计算扩容阈值 threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); } 关于容量的最大值，这里有些不同，请看下面的说明。 /** * 要分配的最大数组大小。 一些虚拟机在数组中保留一些标题字。 尝试分配较大的数组可能会导致OutOfMemoryError：请求的数组大小超过VM限制 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 关于 Table中的元素 Entry，和HashMap中基本完全一致，这里不做详细记录。 最后一个构造函数是使用集合数据进行初始化操作 /** * 使用指定的map来初始化。 * 初始化容量是通过 Math.max(2*t.size(), 11) 来计算的。 * * @param t the map whose mappings are to be placed in this map. * @throws NullPointerException 注意，如果 t 为空，会抛出异常 * @since 1.2 */ public Hashtable(Map&amp;lt;? extends K, ? extends V&amp;gt; t) { this(Math.max(2*t.size(), 11), 0.75f); putAll(t); } 3. 新增元素 我们接着上面的构造方法继续往下看 /** * 将指定映射的所有映射复制到这个散列表。这些映射将替换此hashtable对当前指定映射中任何键的任何映射。 * * @param t mappings to be stored in this map * @throws NullPointerException 注意，如果 t 为空，会抛出异常 * @since 1.2 */ public synchronized void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; t) { for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : t.entrySet()) put(e.getKey(), e.getValue()); } 然后调用 put 方法，put方法在插入时首先判断value是否为空，不为空的时候执行插入操作，如果以前存在该key，执行更新操作，并且返回旧值 /** * 将指定的键映射到此散列表中的指定值。 value和key都不能为空。 * * 可以通过使用与原始键相等的键调用get方法来检索该值。 * * @param key the hashtable key * @param value the value * @return 如果有值，返回旧值，否则返回 null * @exception NullPointerException 如果key或者value为空会抛出异常 * @see Object#equals(Object) * @see #get(Object) */ public synchronized V put(K key, V value) { // 如果value为空，抛出异常 if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&amp;lt;?,?&amp;gt; tab[] = table; //请注意，这里直接调用了 key 的hashCode方法，也就是说，如果你的key == null， 那么这里会抛出空指针异常的。 int hash = key.hashCode(); //0x7FFFFFFF = 2^31 -1，这里计算table的index的方式和hashmap是有区别的 int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;)tab[index]; for(; entry != null ; entry = entry.next) { if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) { //如果已经存在了，覆盖原来的值，并返回原来的值 V old = entry.value; entry.value = value; return old; } } //如果不存在，执行插入操作 addEntry(hash, key, value, index); return null; } 如果之前不存在，那么执行新增操作 private void addEntry(int hash, K key, V value, int index) { modCount++; //如果达到扩容限制，进行扩容操作 Entry&amp;lt;?,?&amp;gt; tab[] = table; if (count &amp;gt;= threshold) { //扩容（稍后讲解具体过程） rehash(); tab = table; hash = key.hashCode(); index = (hash &amp;amp; 0x7FFFFFFF) % tab.length; } // Creates the new entry. @SuppressWarnings(&quot;unchecked&quot;) //获取table中的链表存储的entry对象 Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) tab[index]; //定义一个新的entry，并且把指针指向旧的entry对象（这里多说一句，很明显hashtable把插入的值放在了链表的头位置，hashmap1.8的版本中，插入位置是链表的结尾，而HashMap1.7版本是插入在头位置的，这里需要注意） tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e); count++; } 在HashTable中还有一个 putIfAbsent 方法，基本和put相同，不同的是，只有key不存在的时候或者是key存在但是value == null 的时候才会添加成功。 public synchronized V putIfAbsent(K key, V value) { Objects.requireNonNull(value); // Makes sure the key is not already in the hashtable. Entry&amp;lt;?,?&amp;gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;)tab[index]; for (; entry != null; entry = entry.next) { if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) { V old = entry.value; if (old == null) { entry.value = value; } return old; } } addEntry(hash, key, value, index); return null; } 4. 扩容 在put的时候会执行一个 rehash 方法， protected void rehash() { int oldCapacity = table.length; Entry&amp;lt;?,?&amp;gt;[] oldMap = table; // overflow-conscious code //这里需要注意，扩容不是 * 2，而是 *2 + 1，比如开始是11，扩容以后是 23！ int newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1; //最大值限制 if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; } //创建一个新的map Entry&amp;lt;?,?&amp;gt;[] newMap = new Entry&amp;lt;?,?&amp;gt;[newCapacity]; modCount++; //计算新的扩容阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; //遍历原来的table，放入新的map中，这里可能会把一个链表拆分到table的多个位置上 for (int i = oldCapacity ; i-- &amp;gt; 0 ;) { for (Entry&amp;lt;K,V&amp;gt; old = (Entry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != null ; ) { Entry&amp;lt;K,V&amp;gt; e = old; old = old.next; int index = (e.hash &amp;amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&amp;lt;K,V&amp;gt;)newMap[index]; newMap[index] = e; } } } 5. 取值 get /** * 返回指定键映射到的值;如果此映射不包含键映射，则返回null。 * 更正式地说，如果这个映射包含从关键字k到值v的映射（key.equals（k）），那么这个方法返回v; 否则返回null。 （最多可以有一个这样的映射。） */ public synchronized V get(Object key) { Entry&amp;lt;?,?&amp;gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length; for (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) { return (V)e.value; } } return null; } 6. 遍历 说遍历以前，先看下面两个方法 /** * Returns an enumeration of the keys in this hashtable. * * @return an enumeration of the keys in this hashtable. * @see Enumeration * @see #elements() * @see #keySet() * @see Map */ public synchronized Enumeration&amp;lt;K&amp;gt; keys() { return this.&amp;lt;K&amp;gt;getEnumeration(KEYS); } /** * Returns an enumeration of the values in this hashtable. * Use the Enumeration methods on the returned object to fetch the elements * sequentially. * * @return an enumeration of the values in this hashtable. * @see java.util.Enumeration * @see #keys() * @see #values() * @see Map */ public synchronized Enumeration&amp;lt;V&amp;gt; elements() { return this.&amp;lt;V&amp;gt;getEnumeration(VALUES); } 这样我们遍历HashMap的时候至少可以使用下面的三种方法进行遍历 //1、使用keys() Enumeration&amp;lt;String&amp;gt; en1 = table.keys(); while(en1.hasMoreElements()) { en1.nextElement(); } //2、使用elements() Enumeration&amp;lt;String&amp;gt; en2 = table.elements(); while(en2.hasMoreElements()) { en2.nextElement(); } //3、使用keySet() Iterator&amp;lt;String&amp;gt; it1 = table.keySet().iterator(); while(it1.hasNext()) { it1.next(); } //4、使用entrySet() Iterator&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; it2 = table.entrySet().iterator(); while(it2.hasNext()) { it2.next(); } 7. 其他 HashTable的很多方法都是用了 synchronized，表示它线程安全的，这一点是和HashMap不同的 从Java 2平台v1.2开始，这个类被改进来实现Map接口，使它成为Java集合框架的成员。 与新的集合实现不同，Hashtable是同步的。 如果不需要线程安全的实现，建议使用HashMap来代替Hashtable。 如果需要线程安全的高度并行实现，则建议使用java.util.concurrent.ConcurrentHashMap来代替Hashtable。</summary></entry><entry><title type="html">HashSet源码解析(JDK1.8.0_131)</title><link href="http://localhost:4000/ProgramNote/java/2018/01/09/HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html" rel="alternate" type="text/html" title="HashSet源码解析(JDK1.8.0_131)" /><published>2018-01-09T10:21:57+08:00</published><updated>2018-01-09T10:21:57+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/09/HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/09/HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html">&lt;h1 id=&quot;1-数据结构&quot;&gt;1. 数据结构&lt;/h1&gt;
&lt;p&gt;HashSet其实就是一个HashMap，不同的地方在于，HashSet只是用了HashMap的key，value统一设置为相同的值，这样由于HashMap中的key是唯一的，HashSet就实现了不能重复存储的功能。&lt;/p&gt;

&lt;p&gt;集成关系&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/hashset.png&quot; alt=&quot;hashset&quot; title=&quot;HashSet&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-构造函数&quot;&gt;2. 构造函数&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/hashset2.png&quot; alt=&quot;hashset&quot; title=&quot;HashSet&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，HashSet一共有四个构造函数（其实是5个，有一个私有的，仅供LinkedHashSet使用，这里暂时不介绍）&lt;/p&gt;

&lt;p&gt;先看最简单的3个构造方法，都是直接调用HashMap的构造方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 构造一个新的空set,返回一个使用默认的容量16和负载因子0.75的HashMap实例
     */
    public HashSet() {
        map = new HashMap&amp;lt;&amp;gt;();
    }

    /**
     * 构造一个新的空set，返回一个使用指定初始容量和指定负载因子的HashMap实例.
     *
     * @param      initialCapacity   the initial capacity of the hash map
     * @param      loadFactor        the load factor of the hash map
     * @throws     IllegalArgumentException if the initial capacity is less
     *             than zero, or if the load factor is nonpositive
     */
    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
    }

    /**
     * 构造一个新的空set，返回一个使用指定初始容量和默认负载因子0.75的HashMap实例.
     *
     * @param      initialCapacity   the initial capacity of the hash table
     * @throws     IllegalArgumentException if the initial capacity is less
     *             than zero
     */
    public HashSet(int initialCapacity) {
        map = new HashMap&amp;lt;&amp;gt;(initialCapacity);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和HashMap类似，这里也可以使用一个集合来初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 构造一个新的，包含指定集合数据的HashMap实例.  
     * HashMap实例创建的时候使用默认的负载因子0.75，初始化容量是根据集合容量计算而来的
     *
     * @param c the collection whose elements are to be placed into this set
     * @throws NullPointerException if the specified collection is null
     */
    public HashSet(Collection&amp;lt;? extends E&amp;gt; c) {
        map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-新增元素&quot;&gt;3. 新增元素&lt;/h1&gt;
&lt;p&gt;我们从上面的 addAll 开始分析, addAll 是 AbstractCollection 中的方法，知识单纯的循环，调用add方法添加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 这个实现遍历指定的集合，并依次将迭代器返回的每个对象添加到这个集合中。
     *
     * &amp;lt;p&amp;gt;如果没有重写add方法会抛出异常 UnsupportedOperationException
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     * @throws IllegalStateException         {@inheritDoc}
     *
     * @see #add(Object)
     */
    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后看具体的add操作，请注意，这里有一个 PRESENT，这个值是不变的，会存放到map的value中，这也是判断HashMap中是否存在的一部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    // 与map中的对象（key）关联的虚拟值（value）
    private static final Object PRESENT = new Object();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashSet的add方法仍然是调用HashMap的方法，HashSet如何保证插入数据唯一的呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 如果指定的元素不存在，则将其添加到此集合中。 
     * 更正式地说，如果这个集合不包含元素e2（e == null？e2 == null：e.equals（e2）），那么将指定元素e添加到此集合中。 
     * 如果这个集合已经包含这个元素，那么不会新增并且返回false。
     *
     * @param e element to be added to this set
     * @return &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this set did not already contain the specified
     * element
     */
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap的put方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap的putVal方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                //////////////这里，如果存在了，那么返回的是oldValue，对于set来说也就是PRESENT ////////////////
                return oldValue;
            }
        }
        ++modCount;
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
         //////////////这里，如果不存在，返回的是null ////////////////
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HashMap的key值是唯一的，而 HashSet 往HashMap中新增值得时候 value 使用了默认的 PRESENT，那么如果现在插入一个 新的 key和默认的PRESENT,HashMap返回的是null，&lt;code class=&quot;highlighter-rouge&quot;&gt;map.put(e, PRESENT)==null&lt;/code&gt; 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，添加成功，如果插入一个重复的 key 和默认的 PRESENT ，HashMap 会返回旧的值，也就是 PRESENT，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;map.put(e, PRESENT)==null&lt;/code&gt; 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;4-其他&quot;&gt;4. 其他&lt;/h1&gt;
&lt;h2 id=&quot;41-复制&quot;&gt;4.1. 复制&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。
     *
     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。
     *
     * @return a shallow copy of this set
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Object clone() {
        try {
            HashSet&amp;lt;E&amp;gt; newSet = (HashSet&amp;lt;E&amp;gt;) super.clone();
            newSet.map = (HashMap&amp;lt;E, Object&amp;gt;) map.clone();
            return newSet;
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;42-others&quot;&gt;4.2. Others&lt;/h2&gt;

&lt;p&gt;HashSet的 remove 和 contains 方法都是调用 HashMap 的方法来实现的&lt;/p&gt;

&lt;h1 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;HashSet的底层实现是HashMap&lt;/li&gt;
  &lt;li&gt;HashSet的多数方法都是直接调用HashMap&lt;/li&gt;
  &lt;li&gt;HashSet中元素的不重复是依靠 HashMap 的（key值不重复 + value 完全相同）来实现的&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">1. 数据结构 HashSet其实就是一个HashMap，不同的地方在于，HashSet只是用了HashMap的key，value统一设置为相同的值，这样由于HashMap中的key是唯一的，HashSet就实现了不能重复存储的功能。 集成关系 2. 构造函数 可以看到，HashSet一共有四个构造函数（其实是5个，有一个私有的，仅供LinkedHashSet使用，这里暂时不介绍） 先看最简单的3个构造方法，都是直接调用HashMap的构造方法。 /** * 构造一个新的空set,返回一个使用默认的容量16和负载因子0.75的HashMap实例 */ public HashSet() { map = new HashMap&amp;lt;&amp;gt;(); } /** * 构造一个新的空set，返回一个使用指定初始容量和指定负载因子的HashMap实例. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */ public HashSet(int initialCapacity, float loadFactor) { map = new HashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor); } /** * 构造一个新的空set，返回一个使用指定初始容量和默认负载因子0.75的HashMap实例. * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */ public HashSet(int initialCapacity) { map = new HashMap&amp;lt;&amp;gt;(initialCapacity); } 和HashMap类似，这里也可以使用一个集合来初始化 /** * 构造一个新的，包含指定集合数据的HashMap实例. * HashMap实例创建的时候使用默认的负载因子0.75，初始化容量是根据集合容量计算而来的 * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */ public HashSet(Collection&amp;lt;? extends E&amp;gt; c) { map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } 3. 新增元素 我们从上面的 addAll 开始分析, addAll 是 AbstractCollection 中的方法，知识单纯的循环，调用add方法添加 /** * 这个实现遍历指定的集合，并依次将迭代器返回的每个对象添加到这个集合中。 * * &amp;lt;p&amp;gt;如果没有重写add方法会抛出异常 UnsupportedOperationException * * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} * @throws IllegalStateException {@inheritDoc} * * @see #add(Object) */ public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; } 然后看具体的add操作，请注意，这里有一个 PRESENT，这个值是不变的，会存放到map的value中，这也是判断HashMap中是否存在的一部分。 // 与map中的对象（key）关联的虚拟值（value） private static final Object PRESENT = new Object(); HashSet的add方法仍然是调用HashMap的方法，HashSet如何保证插入数据唯一的呢？ /** * 如果指定的元素不存在，则将其添加到此集合中。 * 更正式地说，如果这个集合不包含元素e2（e == null？e2 == null：e.equals（e2）），那么将指定元素e添加到此集合中。 * 如果这个集合已经包含这个元素，那么不会新增并且返回false。 * * @param e element to be added to this set * @return &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this set did not already contain the specified * element */ public boolean add(E e) { return map.put(e, PRESENT)==null; } HashMap的put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } HashMap的putVal方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp;amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&amp;lt;K,V&amp;gt; e; K k; if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); //////////////这里，如果存在了，那么返回的是oldValue，对于set来说也就是PRESENT //////////////// return oldValue; } } ++modCount; if (++size &amp;gt; threshold) resize(); afterNodeInsertion(evict); //////////////这里，如果不存在，返回的是null //////////////// return null; } HashMap的key值是唯一的，而 HashSet 往HashMap中新增值得时候 value 使用了默认的 PRESENT，那么如果现在插入一个 新的 key和默认的PRESENT,HashMap返回的是null，map.put(e, PRESENT)==null 返回 true，添加成功，如果插入一个重复的 key 和默认的 PRESENT ，HashMap 会返回旧的值，也就是 PRESENT，那么map.put(e, PRESENT)==null 返回 false。 4. 其他 4.1. 复制 /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 * * @return a shallow copy of this set */ @SuppressWarnings(&quot;unchecked&quot;) public Object clone() { try { HashSet&amp;lt;E&amp;gt; newSet = (HashSet&amp;lt;E&amp;gt;) super.clone(); newSet.map = (HashMap&amp;lt;E, Object&amp;gt;) map.clone(); return newSet; } catch (CloneNotSupportedException e) { throw new InternalError(e); } } 4.2. Others HashSet的 remove 和 contains 方法都是调用 HashMap 的方法来实现的 5. 总结 HashSet的底层实现是HashMap HashSet的多数方法都是直接调用HashMap HashSet中元素的不重复是依靠 HashMap 的（key值不重复 + value 完全相同）来实现的</summary></entry><entry><title type="html">HashMap源码解析(JDK1.8.0_131)</title><link href="http://localhost:4000/ProgramNote/java/2018/01/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html" rel="alternate" type="text/html" title="HashMap源码解析(JDK1.8.0_131)" /><published>2018-01-07T22:58:21+08:00</published><updated>2018-01-07T22:58:21+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/07/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.8.0_131).html">&lt;p&gt;&lt;strong&gt;写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，前面已经简单分析了1.7的部分代码，这里以1.8.0_131的源码再次进行分析，思路仍然按照之前的思路，看一下1.8中有哪些不同&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-数据存储结构&quot;&gt;1. 数据存储结构&lt;/h1&gt;
&lt;p&gt;才用的结构和1.7类似，但是有些不同的是 数组+单向链表以后，为了提高链表的效率，在链表长度超过一定值（8）以后，链表转换成 红黑树。&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/HashMap8.png&quot; alt=&quot;hashmap&quot; title=&quot;hashmap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于默认值需要注意下面的部分&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 默认初始容量——必须是2的幂。
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16

    /**
     * 最大容量，如果任何一个构造函数都隐式地指定了一个更高的值，则使用参数。必须是 &amp;lt;= (1&amp;lt;&amp;lt; 30) 2的幂。
     */
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;

    /**
     * 在构造函数中没有指定的负载因子。
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * 链表和tree的转换阈值。超过8时转换成tree
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * 链表和tree的转换阈值。小于6的时候转换成链表
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * 容器可能被树化的最小表容量。(否则，如果bin中有太多节点，那么该表就会被调整大小。)应该至少有4 * TREEIFY_THRESHOLD，以避免调整大小和调整阈值之间的冲突。
     */
    static final int MIN_TREEIFY_CAPACITY = 64;
    /**
     * 初始化的表，并根据需要调整大小。当分配时，长度总是2的幂。(在某些操作中，我们还允许长度为零，以允许自启动机制，而这是目前不需要的。)
     */
    transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是map的基础节点，和1.7中基本相同，但是名称换了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
     * Basic hash bin node, used for most entries.  (See below for
     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
     */
    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;2-初始化&quot;&gt;2. 初始化&lt;/h1&gt;
&lt;h2 id=&quot;21-构造方法-hashmap&quot;&gt;2.1. 构造方法 HashMap()&lt;/h2&gt;
&lt;p&gt;依然是有四个构造方法，先看最简单也是最常用的一个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里要说的是，除了一个负载因子进行了默认赋值以外，其他的没有任何操作。&lt;/p&gt;
&lt;h2 id=&quot;22-构造方法-hashmapint-initialcapacity&quot;&gt;2.2. 构造方法 HashMap(int initialCapacity)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param  initialCapacity the initial capacity.
     * @throws IllegalArgumentException if the initial capacity is negative.
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;23-构造方法-hashmapint-initialcapacity-float-loadfactor&quot;&gt;2.3. 构造方法 HashMap(int initialCapacity, float loadFactor)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial
     * capacity and load factor.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public HashMap(int initialCapacity, float loadFactor) {
        //初始化大小不能小于0
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        //如果超过默认的最大值 ，以最大值初始化
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子不能 小于等于 0
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        //负载因子赋值
        this.loadFactor = loadFactor;
        //阈值赋值（请注意，tableSizeFor 返回的是目标容量，也就是说这里把目标容量给了 阈值， 在resize的时候会重新计算 阈值）
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
     * 简单说就是返回一个大于大于当前输入值的最小的 2的幂值，请注意对照 1.7 的代码，1.7中是使用 Integer.highestOneBit 高位补1 的方式实现的
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;24-构造方法-hashmapmap-extends-k--extends-v-m&quot;&gt;2.4. 构造方法 HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/h2&gt;

&lt;p&gt;这里有需要注意的地方，如果使用这个构造方法初始化，会在调用resize或者putVal(依然是调用resize)的时候初始化Table，这是和前面三个的不同，前面三个始终都没有初始化Table，只有在调用put的时候才会真正初始化，这里其实也是，不过因为初始时就放入了数据，所以接着调用了put方法进行初始化了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;

    /**
     * Constructs a new &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the same mappings as the
     * specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.  The &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }


    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&amp;lt;? extends K, ? extends V&amp;gt; m, boolean evict) {
        int s = m.size();
        if (s &amp;gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &amp;lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &amp;gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &amp;gt; threshold)
                resize();
            for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;3-插入数据-put&quot;&gt;3. 插入数据 PUT&lt;/h1&gt;
&lt;h2 id=&quot;31-插入&quot;&gt;3.1. 插入&lt;/h2&gt;
&lt;p&gt;通常情况下调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt; 直接调用了一个内部方法 putVal&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent 如果为true，不改变当前值，通常调用put的时候这里是false，也就是会覆盖原来的值
     * @param evict if false, the table is in creation mode.这个值在LinkHashMap中有用，这里暂时用不到
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        //如果表为空，那么这里进行扩容
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //如果当前位置没有数据，那么直接创建新节点（请注意，计算i位置的方法，在1.7里面是有 indexFor 完成的，这里没有了 indexFor，但是实际处理是一样一样的）
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            //如果有数据，那么进行下面比较复杂的操作
            Node&amp;lt;K,V&amp;gt; e; K k;
            //table 节点存储的值恰好是当前要put的值，覆盖
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            //如果当前位置存放的是 树节点，那么调用树节点的 put 方法（红黑树具体插入查找方法暂时不在本次讨论当中）
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                //否则说明当前依然是链表结构，先插入节点
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        //请注意，这里很重要，在1.7中，插入新节点始终都是在链表的开头，但是这里是next，也就是说，插在了链表的结尾！！！！
                        p.next = newNode(hash, key, value, null);
                        //判断是否需要转成红黑树
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &amp;gt; threshold)
            resize();
        //这里在其他class调用，目前hashmap中没有任何操作
        afterNodeInsertion(evict);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;32-扩容&quot;&gt;3.2. 扩容&lt;/h2&gt;

&lt;h3 id=&quot;321-扩容条件&quot;&gt;3.2.1. 扩容条件&lt;/h3&gt;
&lt;p&gt;通常情况下，扩容前会执行下面的方法，扩容的基本条件就是当前表数量超过阈值！&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;322-扩容过程&quot;&gt;3.2.2. 扩容过程&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 初始化或者是表翻倍。如果为空，使用之前设置的目标容量（这个值存储在阈值中）初始化。
     * 由于我们使用表容量翻倍，元素要么待在原来的位置，要么有一个2的幂值的位移。
     *
     * @return the table
     */
    final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        //翻倍容量，如果是最大值，返回最大值，否则，容量翻倍。
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        //初始化容量，使用之前设置的值
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        //下面是具体的翻倍操作（节点操作）
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                Node&amp;lt;K,V&amp;gt; e;
                //取出一个node
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    //next == null 说明是一个孤立节点，直接重新插入
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    //是一个tree节点，进行红黑树拆分操作（暂时不深入讨论）
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { // 对链表进行高地位重新排序
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一次扩容，newCapacity和newThreshold均是扩容前值的两倍，为什么如此设计呢？还是照样举个例子来说明这样子设计的原因：&lt;br /&gt;
resize后index计算&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/hashmap008.png&quot; alt=&quot;hashmap&quot; title=&quot;hashmap&quot; /&gt;&lt;br /&gt;
resize后，key所在bucket的节点位置保持不变。&lt;br /&gt;
首先，table.length也就是capacity肯定是2的n次方，根据所在bucket节点下标计算公式：index = hash &amp;amp; (table.length - 1)，其实在进行&amp;amp;运算的时候，只是多了一个最高位1，那么新位置要么保持原位置不变，要么在原位置 + oldCapacity，这个设计的巧妙就在于节省了一部分重新计算hash的时间，而且hash值高位出现0和1的概率均等，在resize的过程又将节点平均分配到两个bucket节点。&lt;/p&gt;

&lt;h1 id=&quot;4-获取数据-get&quot;&gt;4. 获取数据 GET&lt;/h1&gt;
&lt;p&gt;获取数据的方式比较清晰，但是这里依然和1.7有很大的不同，请留意&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//先比较第一个节点（hash值存放的第一个节点，不是Table的第一个节点）&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// always check first node&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;5-hash计算和冲突&quot;&gt;5. Hash计算和冲突&lt;/h1&gt;

&lt;h1 id=&quot;6-其他&quot;&gt;6. 其他&lt;/h1&gt;
&lt;p&gt;1.8和1.7相比较，最大的不同在于&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;引入红黑树，在bucket节点下链表长度 &amp;gt; 8时将链表编程rbtree；&lt;/li&gt;
  &lt;li&gt;优化hash和resize，减少resize带来的hash性能消耗。&lt;/li&gt;
  &lt;li&gt;其他不同&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，前面已经简单分析了1.7的部分代码，这里以1.8.0_131的源码再次进行分析，思路仍然按照之前的思路，看一下1.8中有哪些不同 1. 数据存储结构 才用的结构和1.7类似，但是有些不同的是 数组+单向链表以后，为了提高链表的效率，在链表长度超过一定值（8）以后，链表转换成 红黑树。 关于默认值需要注意下面的部分 /** * 默认初始容量——必须是2的幂。 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16 /** * 最大容量，如果任何一个构造函数都隐式地指定了一个更高的值，则使用参数。必须是 &amp;lt;= (1&amp;lt;&amp;lt; 30) 2的幂。 */ static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; /** * 在构造函数中没有指定的负载因子。 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 链表和tree的转换阈值。超过8时转换成tree */ static final int TREEIFY_THRESHOLD = 8; /** * 链表和tree的转换阈值。小于6的时候转换成链表 */ static final int UNTREEIFY_THRESHOLD = 6; /** * 容器可能被树化的最小表容量。(否则，如果bin中有太多节点，那么该表就会被调整大小。)应该至少有4 * TREEIFY_THRESHOLD，以避免调整大小和调整阈值之间的冲突。 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * 初始化的表，并根据需要调整大小。当分配时，长度总是2的幂。(在某些操作中，我们还允许长度为零，以允许自启动机制，而这是目前不需要的。) */ transient Node&amp;lt;K,V&amp;gt;[] table; 下面是map的基础节点，和1.7中基本相同，但是名称换了。 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final int hash; final K key; V value; Node&amp;lt;K,V&amp;gt; next; Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o; if (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp; Objects.equals(value, e.getValue())) return true; } return false; } } 2. 初始化 2.1. 构造方法 HashMap() 依然是有四个构造方法，先看最简单也是最常用的一个 /** * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 这里要说的是，除了一个负载因子进行了默认赋值以外，其他的没有任何操作。 2.2. 构造方法 HashMap(int initialCapacity) /** * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 2.3. 构造方法 HashMap(int initialCapacity, float loadFactor) /** * Constructs an empty &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) { //初始化大小不能小于0 if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //如果超过默认的最大值 ，以最大值初始化 if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载因子不能 小于等于 0 if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); //负载因子赋值 this.loadFactor = loadFactor; //阈值赋值（请注意，tableSizeFor 返回的是目标容量，也就是说这里把目标容量给了 阈值， 在resize的时候会重新计算 阈值） this.threshold = tableSizeFor(initialCapacity); } /** * 简单说就是返回一个大于大于当前输入值的最小的 2的幂值，请注意对照 1.7 的代码，1.7中是使用 Integer.highestOneBit 高位补1 的方式实现的 */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &amp;gt;&amp;gt;&amp;gt; 1; n |= n &amp;gt;&amp;gt;&amp;gt; 2; n |= n &amp;gt;&amp;gt;&amp;gt; 4; n |= n &amp;gt;&amp;gt;&amp;gt; 8; n |= n &amp;gt;&amp;gt;&amp;gt; 16; return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 2.4. 构造方法 HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) 这里有需要注意的地方，如果使用这个构造方法初始化，会在调用resize或者putVal(依然是调用resize)的时候初始化Table，这是和前面三个的不同，前面三个始终都没有初始化Table，只有在调用put的时候才会真正初始化，这里其实也是，不过因为初始时就放入了数据，所以接着调用了put方法进行初始化了。 /** * Constructs a new &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the same mappings as the * specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;. The &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } /** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&amp;lt;? extends K, ? extends V&amp;gt; m, boolean evict) { int s = m.size(); if (s &amp;gt; 0) { if (table == null) { // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &amp;lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &amp;gt; threshold) threshold = tableSizeFor(t); } else if (s &amp;gt; threshold) resize(); for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } 3. 插入数据 PUT 3.1. 插入 通常情况下调用的 put 直接调用了一个内部方法 putVal public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent 如果为true，不改变当前值，通常调用put的时候这里是false，也就是会覆盖原来的值 * @param evict if false, the table is in creation mode.这个值在LinkHashMap中有用，这里暂时用不到 * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i; //如果表为空，那么这里进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果当前位置没有数据，那么直接创建新节点（请注意，计算i位置的方法，在1.7里面是有 indexFor 完成的，这里没有了 indexFor，但是实际处理是一样一样的） if ((p = tab[i = (n - 1) &amp;amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { //如果有数据，那么进行下面比较复杂的操作 Node&amp;lt;K,V&amp;gt; e; K k; //table 节点存储的值恰好是当前要put的值，覆盖 if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) e = p; //如果当前位置存放的是 树节点，那么调用树节点的 put 方法（红黑树具体插入查找方法暂时不在本次讨论当中） else if (p instanceof TreeNode) e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value); else { //否则说明当前依然是链表结构，先插入节点 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { //请注意，这里很重要，在1.7中，插入新节点始终都是在链表的开头，但是这里是next，也就是说，插在了链表的结尾！！！！ p.next = newNode(hash, key, value, null); //判断是否需要转成红黑树 if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &amp;gt; threshold) resize(); //这里在其他class调用，目前hashmap中没有任何操作 afterNodeInsertion(evict); return null; } 3.2. 扩容 3.2.1. 扩容条件 通常情况下，扩容前会执行下面的方法，扩容的基本条件就是当前表数量超过阈值！ if (++size &amp;gt; threshold) resize(); 3.2.2. 扩容过程 /** * 初始化或者是表翻倍。如果为空，使用之前设置的目标容量（这个值存储在阈值中）初始化。 * 由于我们使用表容量翻倍，元素要么待在原来的位置，要么有一个2的幂值的位移。 * * @return the table */ final Node&amp;lt;K,V&amp;gt;[] resize() { Node&amp;lt;K,V&amp;gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //翻倍容量，如果是最大值，返回最大值，否则，容量翻倍。 if (oldCap &amp;gt; 0) { if (oldCap &amp;gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold } //初始化容量，使用之前设置的值 else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; //下面是具体的翻倍操作（节点操作） @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &amp;lt; oldCap; ++j) { Node&amp;lt;K,V&amp;gt; e; //取出一个node if ((e = oldTab[j]) != null) { oldTab[j] = null; //next == null 说明是一个孤立节点，直接重新插入 if (e.next == null) newTab[e.hash &amp;amp; (newCap - 1)] = e; //是一个tree节点，进行红黑树拆分操作（暂时不深入讨论） else if (e instanceof TreeNode) ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap); else { // 对链表进行高地位重新排序 Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null; Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null; Node&amp;lt;K,V&amp;gt; next; do { next = e.next; if ((e.hash &amp;amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 每一次扩容，newCapacity和newThreshold均是扩容前值的两倍，为什么如此设计呢？还是照样举个例子来说明这样子设计的原因： resize后index计算 resize后，key所在bucket的节点位置保持不变。 首先，table.length也就是capacity肯定是2的n次方，根据所在bucket节点下标计算公式：index = hash &amp;amp; (table.length - 1)，其实在进行&amp;amp;运算的时候，只是多了一个最高位1，那么新位置要么保持原位置不变，要么在原位置 + oldCapacity，这个设计的巧妙就在于节省了一部分重新计算hash的时间，而且hash值高位出现0和1的概率均等，在resize的过程又将节点平均分配到两个bucket节点。 4. 获取数据 GET 获取数据的方式比较清晰，但是这里依然和1.7有很大的不同，请留意 public V get(Object key) { Node&amp;lt;K,V&amp;gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) { Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k; if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp; (first = tab[(n - 1) &amp;amp; hash]) != null) { //先比较第一个节点（hash值存放的第一个节点，不是Table的第一个节点） if (first.hash == hash &amp;amp;&amp;amp; // always check first node ((k = first.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 5. Hash计算和冲突 6. 其他 1.8和1.7相比较，最大的不同在于 引入红黑树，在bucket节点下链表长度 &amp;gt; 8时将链表编程rbtree； 优化hash和resize，减少resize带来的hash性能消耗。 其他不同</summary></entry><entry><title type="html">HashMap源码解析(JDK1.7.0_80)</title><link href="http://localhost:4000/ProgramNote/java/2018/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.7.0_80).html" rel="alternate" type="text/html" title="HashMap源码解析(JDK1.7.0_80)" /><published>2018-01-06T17:13:08+08:00</published><updated>2018-01-06T17:13:08+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.7.0_80)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/06/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(JDK1.7.0_80).html">&lt;p&gt;&lt;strong&gt;写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，这里以JDK1.7.0_80为例，后续会有关于1.8的记录&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-数据存储结构&quot;&gt;1. 数据存储结构&lt;/h1&gt;
&lt;p&gt;采用双表结构：数组+单向链表&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/HashMap.png&quot; alt=&quot;hashmap&quot; title=&quot;hashMap&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 一个空的表实例，用于在表未膨胀时共享。
     */
    static final Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE = {};
    /**
     * 该表根据需要调整大小。长度必须始终是2的幂。
     * 用户储存元素的数组，最初定义为空，实例化的时候会调用下面的膨胀表的方法，对Table进行赋值操作
     */
    transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
    * 获取一个大于输入值得2的幂次值
    */
    private static int roundUpToPowerOf2(int number) {
        // assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;;
        return number &amp;gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1;
    }
    /**
     * Inflates the table.
     * 上面说的膨胀表，就是赋值，获取一个2的幂值，然后初始化table
     */
    private void inflateTable(int toSize) {
        //注意，这里tosize其实是默认的表的长度值16，如果使用构造函数初始化，比如指定了长度是5，这里就是5
        //但是，在第一次初始化表的时候调用方式是 inflateTable(threshold); 也就是说上面的5或者16其实是阈值
        //下面一句话就是获取了大于5的2的幂值，使用的是 highestOneBit， 取这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果
        //比如这里获取到的是8，然后通过负载因子和容量，重新计算阈值
        // Find a power of 2 &amp;gt;= toSize
        int capacity = roundUpToPowerOf2(toSize);

        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
        table = new Entry[capacity];
        //这里后面讲，与hash冲突有关
        initHashSeedAsNeeded(capacity);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面就是hashmap中实际存储的元素了，元素包括了key，value，hash值，还有一个指针，指向了链表的下一个元素。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/**
         * Creates new entry.
         */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;....&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-初始化&quot;&gt;2. 初始化&lt;/h1&gt;
&lt;p&gt;HashMap的构造函数一共有四个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public HashMap(int initialCapacity, float loadFactor) {
        //初始化容量不能为负数
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        //如果初始化容量超过最大值，以最大值赋值，最大值 1 &amp;lt;&amp;lt; 30
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子不能为负数
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        //负载因子赋值
        this.loadFactor = loadFactor;
        //阈值为初始化大小，请注意，比如，现在初始化大小是5，那么阈值就设置为5了，但是，在inflateTable方法中有进行了重新计算 ******
        threshold = initialCapacity;
        //这里init方法是空实现，没有任何操作
        init();
    }

    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public HashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Constructs a new &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the same mappings as the
     * specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.  The &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to
     * hold the mappings in the specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;.
     *
     * @param   m the map whose mappings are to be placed in this map
     * @throws  NullPointerException if the specified map is null
     */
    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        //初始化容量是 16 或者是 通过负载因子计算的数量 的最大值
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
        //请注意，只有这里初始化了，前面三个构造函数都没有初始化操作
        inflateTable(threshold);

        putAllForCreate(m);
    }


    private void putAllForCreate(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet())
            //新增table元素，详细过程略
            putForCreate(e.getKey(), e.getValue());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-插入数据-put&quot;&gt;3. 插入数据 PUT&lt;/h1&gt;
&lt;h2 id=&quot;31-插入&quot;&gt;3.1. 插入&lt;/h2&gt;
&lt;p&gt;代码比较简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 将指定的值与该映射中的指定键关联。如果映射之前包含了键的映射，则旧值将被替换。
     *
     * @param key 与指定值相关联的键
     * @param value 与指定键关联的值
     * @return 之前与键关联的值，如果没有键映射，则返回null。 （空返回也可以指示映射先前与键关联的是null。）
     */
    public V put(K key, V value) {
        //如果为初始化，需要先膨胀表（初始化链表）
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        //如果键为空，调用放空的方法
        if (key == null)
            return putForNullKey(value);//这里有一点需要注意，key为null的时候，会存储在table的开始位置，也就是table[0]的链表中
        //对key进行hash运算
        int hash = hash(key);
        //把key hash运算的值和表长度按位与操作，获取这个hash值应该放在table的哪一个位置（得到索引编号）
        int i = indexFor(hash, table.length);
        //如果将要放入的索引标号位置有数据了，需要遍历链表，如果有相同的key存在，修改旧数据
        for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        //当table的 i 位置没有数据或者是hash值计算的i位置相同但是key不同的时候，新建链表或者向链表增加数据
        addEntry(hash, key, value, i);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;32-链表新增数据&quot;&gt;3.2. 链表新增数据&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 向指定的bucket添加一个具有指定键、值和哈希代码的新条目。如果需要的话，该方法还会调整表的大小。
     *
     * 子类重写此操作以改变put方法的行为。
     */
    void addEntry(int hash, K key, V value, int bucketIndex) {
        //判断是否需要重新调整表的大小
        if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
            resize(2 * table.length);
            //如果调整了表以后，需要重新计算应该放入的链表位置
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
        //把元素放入链表
        createEntry(hash, key, value, bucketIndex);
    }

    /**
     * 就像添加条目一样，只是在创建条目作为映射构建或“pseudo - construction”(克隆、反序列化)的一部分时使用这个版本。这个版本不必担心调整表的大小。
     *
     * 子类重写此操作以改变哈希映射(映射)、克隆和读取对象的行为。
     */
    void createEntry(int hash, K key, V value, int bucketIndex) {
        //把key和value放入一个新的Entry，然后指针指向原来的元素，请注意，这里表示新增的数据始终是位于链表的顶部的！！！
        Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];
        table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
        size++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-扩容&quot;&gt;3.3. 扩容&lt;/h2&gt;

&lt;h3 id=&quot;331-扩容条件&quot;&gt;3.3.1. 扩容条件&lt;/h3&gt;
&lt;p&gt;请注意在上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;addEntry&lt;/code&gt;方法中扩容的条件，表的容量大于阈值并且存储的目标位置不为空就会扩容，实际还有一个触发扩容方法的调用，只要满足前一个条件&lt;strong&gt;表的容量大于阈值&lt;/strong&gt;就会触发扩容&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;阈值 = 容量 * 阈值系数&lt;/li&gt;
  &lt;li&gt;容量默认值 16  &lt;code class=&quot;highlighter-rouge&quot;&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;阈值系数默认值 0.75 &lt;code class=&quot;highlighter-rouge&quot;&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f;&lt;/code&gt;
    &lt;h3 id=&quot;332-扩容过程&quot;&gt;3.3.2. 扩容过程&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
     * 将该映射的内容重新映射到具有更大容量的新数组中。当该映射中的键数达到阈值时，将自动调用此方法。
     *
     * 如果当前的容量是最大容量，此方法不会调整映射的大小，而是将阈值设置为整数。最大价值。这就产生了防止未来通话的效果。
     *
     * @param newCapacity 新容量的新容量，必须是2的幂值;除非当前容量是最大容量(在这种情况下，值是不相关的)，必须大于当前容量。
     */
    void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        //如果容量达到最大值，threshold会调整为最大值，实际容量不变
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }
        //新建一个表，然后重新计算索引值
        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        //表扩容完成以后计算新的阈值
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }

    /**
     * 将所有条目从当前表传输到新表。（扩容的实际操作方法）
     */
    void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry&amp;lt;K,V&amp;gt; e : table) {
            while(null != e) {
                Entry&amp;lt;K,V&amp;gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                //根据hash值重新计算在表中的位置
                int i = indexFor(e.hash, newCapacity);
                //链表的元素存储到e
                e.next = newTable[i];
                //元素赋值
                newTable[i] = e;
                //下一个循环
                e = next;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面有个方法叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;initHashSeedAsNeeded&lt;/code&gt; ，用于表示是否重新计算hash值，后面讲。&lt;/p&gt;
&lt;h1 id=&quot;4-获取数据-get&quot;&gt;4. 获取数据 GET&lt;/h1&gt;
&lt;p&gt;请注意，这里获取返回值为null的时候，不一定表示不包含key，也可能是键值就是null，如果要知道是否真的包含，需要调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;containsKey&lt;/code&gt; 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 返回指定键映射的值，或者如果此映射不包含键的映射，则返回{@ code null}。
     *
     * &amp;lt;p&amp;gt;更正式地说，如果这个映射包含一个从键{@代码k}到一个值{@ code}的映射，那么{@ code(key == null ?k == null:key。=(k)}，然后该方法返回{@ code v};否则返回{@ code null}。(最多可以有一个这样的映射。)
     *
     * &amp;lt;p&amp;gt;{@ code null}的返回值不一定&amp;lt; i &amp;gt; &amp;lt;/ i &amp;gt;表示映射不包含键的映射;这也可能是map显式地映射了{@ code null}的键。{@link #containsKey containsKey}操作可以用来区分这两种情况
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
        //查找 key == null 的值
        if (key == null)
            return getForNullKey();
        Entry&amp;lt;K,V&amp;gt; entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }

    /**
     * 返回与散列映射中指定键关联的条目。如果哈希映射不包含键的映射，则返回null。
     */
    final Entry&amp;lt;K,V&amp;gt; getEntry(Object key) {
        if (size == 0) {
            return null;
        }
        //计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //根据hash值获取table中的index位置
        for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            //遍历链表 ，hash值相同， key相同，key不为空，这些条件都满足，就会返回正确的值
            if (e.hash == hash &amp;amp;&amp;amp;
                ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return e;
        }
        return null;
    }

    /**
     * get()的卸载版本查找空键。空键映射到索引0。这个空例被拆分为单独的方法，以在两个最常用的操作(get和put)中执行，但在其他操作中加入了条件。
     */
    private V getForNullKey() {
        if (size == 0) {
            return null;
        }
        for (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != null; e = e.next) {
            if (e.key == null)
                return e.value;
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5-hash计算和冲突&quot;&gt;5. Hash计算和冲突&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;hash方法为了让每一位都参与位运算，让相近的数最后通过hash能分散开并减少碰撞，采用了多次位移和异或，当然多一次与key的hashCode异或，也是为了尽量减少碰撞；&lt;/li&gt;
  &lt;li&gt;hashSeed也是一个非常重要的角色，可以把它看成一个开关，如果开关打开，并且key的类型是String时可以采取sun.misc.Hashing.stringHash32方法获取其hash值。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    /**
     * 检索对象哈希代码，并将一个附加的哈希函数应用到结果散列中，以防止糟糕的质量哈希函数。这很重要，因为哈希映射使用的是2的幂值的哈希表，否则就会遇到在较低位上没有差异的哈希码的冲突。
     * 注意:空键总是映射到哈希0，因此索引0。
     */
    final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;amp;&amp;amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        // 这个函数可以确保在每个位位置上只有 
        // 常数倍数不同的哈希码有一个有界
        // 数的碰撞(默认负载系数约为8)。
        h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
        return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面一直没有说的&lt;code class=&quot;highlighter-rouge&quot;&gt;initHashSeedAsNeeded&lt;/code&gt;方法在这里就又用除了，hashSeed的默认值是0，hashSeed会在capacity发生变化的时候调用initHashSeedAsNeeded方法重新计算&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 初始化哈希掩码值。我们推迟初始化，直到我们真正需要它。
     */
    final boolean initHashSeedAsNeeded(int capacity) {
        boolean currentAltHashing = hashSeed != 0;
        boolean useAltHashing = sun.misc.VM.isBooted() &amp;amp;&amp;amp;
                (capacity &amp;gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean switching = currentAltHashing ^ useAltHashing;
        if (switching) {
            hashSeed = useAltHashing
                ? sun.misc.Hashing.randomHashSeed(this)
                : 0;
        }
        return switching;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hashSeed的计算流程涉及到一个设定值&lt;code class=&quot;highlighter-rouge&quot;&gt;Holder.ALTERNATIVE_HASHING_THRESHOLD&lt;/code&gt;，该设定值是通过JVM的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;jdk.map.althashing.threshold&lt;/code&gt;来设置的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注：
在JDK 8 中，hashSeed已经被移除掉了，移除掉的原因是调用sun.misc.Hashing.randomHashSeed计算hashSeed时会调用方法java.util.Random.nextInt()，该方法使用AtomicLong，在多线程情况下会有性能问题。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于是否会更新hashSeed的问题，自己不太明白，这里有个知乎的解释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们来看switching 的取值方法，是cur和use的异或，cur表示已经有seed，use表示capcity超过了阈值，需要use alternative。那么它们的异或就表示，当没有seed且需要use时；或者当有seed且不需要use时，switch才为true，特别的，switch为true时，如果需要alternative，则seed赋值为一个新的随机值，如果是已有seed则把seed置零。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;6-其他&quot;&gt;6. 其他&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;如果可以预估数据量，在创建HashMap实例时，设置合适的初始容量，可以减少扩容操作，提升性能。&lt;/li&gt;
  &lt;li&gt;将容量设置为2的n次方性能最好，如：16，32。原因：和HashMap的indexFor方法实现有关。&lt;/li&gt;
  &lt;li&gt;用作Key的对象须实现equals和hashCode方法。如果用String对象作Key，就不用自己实现equals和hashCode方法，因为String对象已经实现。&lt;/li&gt;
  &lt;li&gt;HashMap是非线程安全的，在多线程并发操作时会出现死循环。原因：执行扩容操作时，将旧表中的数据插入新表时有可能导致单向链表形成闭环。&lt;/li&gt;
  &lt;li&gt;HashMap在普通的构造函数，也就是默认不放入任何值的构造函数中，不初始化table，只有在put或者是使用两外一个map初始化的时候才会初始化table&lt;/li&gt;
  &lt;li&gt;默认情况下，&lt;strong&gt;初始化的时候阈值就是table的初始化长度&lt;/strong&gt;，只有调用resize以后，&lt;strong&gt;阈值 = 长度 * 负载因子&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://aofengblog.blog.163.com/blog/static/631702120147148919858/&quot;&gt;JDK HashMap源码分析 | HashMap Source Code Analysis&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/a11b9c1002f1?from=singlemessage&quot;&gt;Java中的HashMap&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.zhihu.com/question/58679855&quot;&gt;HashMap关于更换hashseed疑问？&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">写在最前面：HashMap的实现在JDK不同版本中是有差别的，在JDK1.7和1.8中差距挺大，这里以JDK1.7.0_80为例，后续会有关于1.8的记录 1. 数据存储结构 采用双表结构：数组+单向链表 /** * 一个空的表实例，用于在表未膨胀时共享。 */ static final Entry&amp;lt;?,?&amp;gt;[] EMPTY_TABLE = {}; /** * 该表根据需要调整大小。长度必须始终是2的幂。 * 用户储存元素的数组，最初定义为空，实例化的时候会调用下面的膨胀表的方法，对Table进行赋值操作 */ transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE; /** * 获取一个大于输入值得2的幂次值 */ private static int roundUpToPowerOf2(int number) { // assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;; return number &amp;gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1; } /** * Inflates the table. * 上面说的膨胀表，就是赋值，获取一个2的幂值，然后初始化table */ private void inflateTable(int toSize) { //注意，这里tosize其实是默认的表的长度值16，如果使用构造函数初始化，比如指定了长度是5，这里就是5 //但是，在第一次初始化表的时候调用方式是 inflateTable(threshold); 也就是说上面的5或者16其实是阈值 //下面一句话就是获取了大于5的2的幂值，使用的是 highestOneBit， 取这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果 //比如这里获取到的是8，然后通过负载因子和容量，重新计算阈值 // Find a power of 2 &amp;gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; //这里后面讲，与hash冲突有关 initHashSeedAsNeeded(capacity); } 下面就是hashmap中实际存储的元素了，元素包括了key，value，hash值，还有一个指针，指向了链表的下一个元素。 static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final K key; V value; Entry&amp;lt;K,V&amp;gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&amp;lt;K,V&amp;gt; n) { value = v; next = n; key = k; hash = h; } &amp;lt;code....&amp;gt; } 2. 初始化 HashMap的构造函数一共有四个 public HashMap(int initialCapacity, float loadFactor) { //初始化容量不能为负数 if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //如果初始化容量超过最大值，以最大值赋值，最大值 1 &amp;lt;&amp;lt; 30 if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //负载因子不能为负数 if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); //负载因子赋值 this.loadFactor = loadFactor; //阈值为初始化大小，请注意，比如，现在初始化大小是5，那么阈值就设置为5了，但是，在inflateTable方法中有进行了重新计算 ****** threshold = initialCapacity; //这里init方法是空实现，没有任何操作 init(); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap() { this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); } /** * Constructs a new &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; with the same mappings as the * specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;. The &amp;lt;tt&amp;gt;HashMap&amp;lt;/tt&amp;gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &amp;lt;tt&amp;gt;Map&amp;lt;/tt&amp;gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) { //初始化容量是 16 或者是 通过负载因子计算的数量 的最大值 this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); //请注意，只有这里初始化了，前面三个构造函数都没有初始化操作 inflateTable(threshold); putAllForCreate(m); } private void putAllForCreate(Map&amp;lt;? extends K, ? extends V&amp;gt; m) { for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) //新增table元素，详细过程略 putForCreate(e.getKey(), e.getValue()); } 3. 插入数据 PUT 3.1. 插入 代码比较简单 /** * 将指定的值与该映射中的指定键关联。如果映射之前包含了键的映射，则旧值将被替换。 * * @param key 与指定值相关联的键 * @param value 与指定键关联的值 * @return 之前与键关联的值，如果没有键映射，则返回null。 （空返回也可以指示映射先前与键关联的是null。） */ public V put(K key, V value) { //如果为初始化，需要先膨胀表（初始化链表） if (table == EMPTY_TABLE) { inflateTable(threshold); } //如果键为空，调用放空的方法 if (key == null) return putForNullKey(value);//这里有一点需要注意，key为null的时候，会存储在table的开始位置，也就是table[0]的链表中 //对key进行hash运算 int hash = hash(key); //把key hash运算的值和表长度按位与操作，获取这个hash值应该放在table的哪一个位置（得到索引编号） int i = indexFor(hash, table.length); //如果将要放入的索引标号位置有数据了，需要遍历链表，如果有相同的key存在，修改旧数据 for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //当table的 i 位置没有数据或者是hash值计算的i位置相同但是key不同的时候，新建链表或者向链表增加数据 addEntry(hash, key, value, i); return null; } 3.2. 链表新增数据 /** * 向指定的bucket添加一个具有指定键、值和哈希代码的新条目。如果需要的话，该方法还会调整表的大小。 * * 子类重写此操作以改变put方法的行为。 */ void addEntry(int hash, K key, V value, int bucketIndex) { //判断是否需要重新调整表的大小 if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) { resize(2 * table.length); //如果调整了表以后，需要重新计算应该放入的链表位置 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } //把元素放入链表 createEntry(hash, key, value, bucketIndex); } /** * 就像添加条目一样，只是在创建条目作为映射构建或“pseudo - construction”(克隆、反序列化)的一部分时使用这个版本。这个版本不必担心调整表的大小。 * * 子类重写此操作以改变哈希映射(映射)、克隆和读取对象的行为。 */ void createEntry(int hash, K key, V value, int bucketIndex) { //把key和value放入一个新的Entry，然后指针指向原来的元素，请注意，这里表示新增的数据始终是位于链表的顶部的！！！ Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e); size++; } 3.3. 扩容 3.3.1. 扩容条件 请注意在上面 addEntry方法中扩容的条件，表的容量大于阈值并且存储的目标位置不为空就会扩容，实际还有一个触发扩容方法的调用，只要满足前一个条件表的容量大于阈值就会触发扩容 阈值 = 容量 * 阈值系数 容量默认值 16 static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16 阈值系数默认值 0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; 3.3.2. 扩容过程 /** * 将该映射的内容重新映射到具有更大容量的新数组中。当该映射中的键数达到阈值时，将自动调用此方法。 * * 如果当前的容量是最大容量，此方法不会调整映射的大小，而是将阈值设置为整数。最大价值。这就产生了防止未来通话的效果。 * * @param newCapacity 新容量的新容量，必须是2的幂值;除非当前容量是最大容量(在这种情况下，值是不相关的)，必须大于当前容量。 */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果容量达到最大值，threshold会调整为最大值，实际容量不变 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //新建一个表，然后重新计算索引值 Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; //表扩容完成以后计算新的阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } /** * 将所有条目从当前表传输到新表。（扩容的实际操作方法） */ void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry&amp;lt;K,V&amp;gt; e : table) { while(null != e) { Entry&amp;lt;K,V&amp;gt; next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } //根据hash值重新计算在表中的位置 int i = indexFor(e.hash, newCapacity); //链表的元素存储到e e.next = newTable[i]; //元素赋值 newTable[i] = e; //下一个循环 e = next; } } } 上面有个方法叫做 initHashSeedAsNeeded ，用于表示是否重新计算hash值，后面讲。 4. 获取数据 GET 请注意，这里获取返回值为null的时候，不一定表示不包含key，也可能是键值就是null，如果要知道是否真的包含，需要调用 containsKey 方法。 /** * 返回指定键映射的值，或者如果此映射不包含键的映射，则返回{@ code null}。 * * &amp;lt;p&amp;gt;更正式地说，如果这个映射包含一个从键{@代码k}到一个值{@ code}的映射，那么{@ code(key == null ?k == null:key。=(k)}，然后该方法返回{@ code v};否则返回{@ code null}。(最多可以有一个这样的映射。) * * &amp;lt;p&amp;gt;{@ code null}的返回值不一定&amp;lt; i &amp;gt; &amp;lt;/ i &amp;gt;表示映射不包含键的映射;这也可能是map显式地映射了{@ code null}的键。{@link #containsKey containsKey}操作可以用来区分这两种情况 * * @see #put(Object, Object) */ public V get(Object key) { //查找 key == null 的值 if (key == null) return getForNullKey(); Entry&amp;lt;K,V&amp;gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); } /** * 返回与散列映射中指定键关联的条目。如果哈希映射不包含键的映射，则返回null。 */ final Entry&amp;lt;K,V&amp;gt; getEntry(Object key) { if (size == 0) { return null; } //计算hash值 int hash = (key == null) ? 0 : hash(key); //根据hash值获取table中的index位置 for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; //遍历链表 ，hash值相同， key相同，key不为空，这些条件都满足，就会返回正确的值 if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) return e; } return null; } /** * get()的卸载版本查找空键。空键映射到索引0。这个空例被拆分为单独的方法，以在两个最常用的操作(get和put)中执行，但在其他操作中加入了条件。 */ private V getForNullKey() { if (size == 0) { return null; } for (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } 5. Hash计算和冲突 hash方法为了让每一位都参与位运算，让相近的数最后通过hash能分散开并减少碰撞，采用了多次位移和异或，当然多一次与key的hashCode异或，也是为了尽量减少碰撞； hashSeed也是一个非常重要的角色，可以把它看成一个开关，如果开关打开，并且key的类型是String时可以采取sun.misc.Hashing.stringHash32方法获取其hash值。 /** * 检索对象哈希代码，并将一个附加的哈希函数应用到结果散列中，以防止糟糕的质量哈希函数。这很重要，因为哈希映射使用的是2的幂值的哈希表，否则就会遇到在较低位上没有差异的哈希码的冲突。 * 注意:空键总是映射到哈希0，因此索引0。 */ final int hash(Object k) { int h = hashSeed; if (0 != h &amp;amp;&amp;amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // 这个函数可以确保在每个位位置上只有 // 常数倍数不同的哈希码有一个有界 // 数的碰撞(默认负载系数约为8)。 h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12); return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4); } 上面一直没有说的initHashSeedAsNeeded方法在这里就又用除了，hashSeed的默认值是0，hashSeed会在capacity发生变化的时候调用initHashSeedAsNeeded方法重新计算 /** * 初始化哈希掩码值。我们推迟初始化，直到我们真正需要它。 */ final boolean initHashSeedAsNeeded(int capacity) { boolean currentAltHashing = hashSeed != 0; boolean useAltHashing = sun.misc.VM.isBooted() &amp;amp;&amp;amp; (capacity &amp;gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean switching = currentAltHashing ^ useAltHashing; if (switching) { hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(this) : 0; } return switching; } hashSeed的计算流程涉及到一个设定值Holder.ALTERNATIVE_HASHING_THRESHOLD，该设定值是通过JVM的参数jdk.map.althashing.threshold来设置的。 注： 在JDK 8 中，hashSeed已经被移除掉了，移除掉的原因是调用sun.misc.Hashing.randomHashSeed计算hashSeed时会调用方法java.util.Random.nextInt()，该方法使用AtomicLong，在多线程情况下会有性能问题。 关于是否会更新hashSeed的问题，自己不太明白，这里有个知乎的解释 我们来看switching 的取值方法，是cur和use的异或，cur表示已经有seed，use表示capcity超过了阈值，需要use alternative。那么它们的异或就表示，当没有seed且需要use时；或者当有seed且不需要use时，switch才为true，特别的，switch为true时，如果需要alternative，则seed赋值为一个新的随机值，如果是已有seed则把seed置零。 6. 其他 如果可以预估数据量，在创建HashMap实例时，设置合适的初始容量，可以减少扩容操作，提升性能。 将容量设置为2的n次方性能最好，如：16，32。原因：和HashMap的indexFor方法实现有关。 用作Key的对象须实现equals和hashCode方法。如果用String对象作Key，就不用自己实现equals和hashCode方法，因为String对象已经实现。 HashMap是非线程安全的，在多线程并发操作时会出现死循环。原因：执行扩容操作时，将旧表中的数据插入新表时有可能导致单向链表形成闭环。 HashMap在普通的构造函数，也就是默认不放入任何值的构造函数中，不初始化table，只有在put或者是使用两外一个map初始化的时候才会初始化table 默认情况下，初始化的时候阈值就是table的初始化长度，只有调用resize以后，阈值 = 长度 * 负载因子 参考 JDK HashMap源码分析 | HashMap Source Code Analysis Java中的HashMap HashMap关于更换hashseed疑问？</summary></entry><entry><title type="html">Hashcode和equals</title><link href="http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals.html" rel="alternate" type="text/html" title="Hashcode和equals" /><published>2018-01-04T10:46:08+08:00</published><updated>2018-01-04T10:46:08+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals.html">&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;两个对象的Hashcode相同，相象是否相相等？equals呢？ 为了解决这个问题，先要了解一下`java.lang.Object`的`Hashcode`和`equals`方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;equals方法详解&quot;&gt;equals()方法详解&lt;/h1&gt;
&lt;p&gt;先看java.lang.Object的默认实现，部分内容进行了翻译。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   /**
     * 表示某个其他对象是否“等于”这一个。
     * &amp;lt;p&amp;gt;
     * equals方法在非null对象引用上实现等价关系
     * 自反: 对于任何非null的引用值 x，x.equals(x) 应该返回 true。
     * 对称: 对任何非空的引用值 x 和 y, 如果 y.equals(x) 返回true， 那么x.equals(y)必须返回true
     * 传递: 对任何非空的引用值 x, y, z, 如果 x.equals(y)返回 true ，y.equals(z)返回 true, 那么 x.equals(z)也必须返回true
     * 一致: 如果x.equals(y)返回是true，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是true。
     * 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。
     * &amp;lt;p&amp;gt;
     * Object类的equals方法实现了对象上最可能的等价关系;也就是说，对于任何非null的引用值x和y，当且仅当x和y引用同一个对象x == y时返回 true。
     * &amp;lt;p&amp;gt;
     * 请注意，无论何时重写此方法，通常都必须重写hashCode方法，以维护hashCode方法的一般约定，该方法声明相等的对象必须具有相同的哈希码。
     *
     * @param   obj   the reference object with which to compare.
     * @return  true} if this object is the same as the obj
     *          argument; false} otherwise.
     * @see     #hashCode()
     * @see     java.util.HashMap
     */
    public boolean equals(Object obj) {
        return (this == obj);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，非空的对象只有引用地址相同的情况下，equals 才会返回 true，上面说的很清晰 “ == “表示的就是引用地址的比较。&lt;/p&gt;

&lt;p&gt;但是，很多时候，equals方法会被重写，例如 java.lang.String&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String) anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                            return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java.lang.String的equals方法不是进行引用地址比较，而是内容比较。&lt;/p&gt;

&lt;p&gt;下面举个形象的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class User {
    private int id;
    private String name;
    private String password;

    &amp;lt;get and set&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    User user1 = new User();
    User user2 = new User();
    assert user1.equals(user2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果直接运行上面的内容，会显示异常java.lang.AssertionError，表示两个对象不一样，因为这个时候equals方法是最初的java.lang.Object的 “==” 比较。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class User {
    private int id;
    private String name;
    private String password;

    &amp;lt;get and set&amp;gt;

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        User user = (User) o;
        return id == user.id &amp;amp;&amp;amp;
                Objects.equals(name, user.name) &amp;amp;&amp;amp;
                Objects.equals(password, user.password);
    }

    @Override
    public int hashCode() {

        return Objects.hash(id, name, password);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面重写了 equals方法，此时再次进行比较的时候，从引用值比较改成了内容比较，此时返回的就是true了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是，上面同时重写了 equals 和 Hashcode 方法，在这个简单对象中不重写可能不会有太大的问题，但是后面再集合中，如果不重写可能会导致意想不到的问题发生。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;hashcode&quot;&gt;hashCode()&lt;/h1&gt;
&lt;p&gt;先看java.lang.Object的实现，这里native表示是本地方法，有java以外的语言实现，重点看javaDoc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
     * 返回该对象的哈希码值。 这种方法支持哈希表，如由{@link java.util.HashMap}提供的哈希表。
     * &amp;lt;p&amp;gt;
     * hashCode通常情况下遵守的合约是：
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;只要在Java应用程序的执行过程中多次调用同一个对象，{@code hashCode}方法必须始终返回相同的整数，前提是在对象上的比较中没有使用任何信息被修改。 从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。
     * &amp;lt;li&amp;gt;如果两个对象根据equals方法相等，则在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。
     * &amp;lt;li&amp;gt;如果两个对象根据equals（Object）方法不相等，则不要求对两个对象中的每一个调用hashCode方法都必须产生不同的整数结果。 但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。
     * &amp;lt;/ul&amp;gt;
     * &amp;lt;p&amp;gt;
     * 尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。 （这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。）
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
    public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，String等对象类型会重写这些方法，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    public int hashCode() {
        int h = hash;
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单理解就是 String 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&lt;/code&gt;重写了hashcode 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请注意，下面只是简单介绍集合的存储原理，关于地址值的部分不准备，这部分等我看完jdk8的代码以后再修改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要弄明白hashCode的作用，必须要先知道Java中的集合。　　 
总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？&lt;/p&gt;

&lt;p&gt;这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 &lt;br /&gt;
于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，这个地址上的key值就是hashcode值，而value值则记录了这个对象存储的真是地址。&lt;br /&gt;
这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。&lt;/p&gt;

&lt;p&gt;所以，Java对于eqauls方法和hashCode方法是这样规定的：
1.如果两个对象相同，那么它们的hashCode值一定要相同；
2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。  如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。
3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。

在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，Hashcode()方法根据String类的重写代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;hashsethashmaphashtable与hashcode和equals的密切关系&quot;&gt;Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系&lt;/h1&gt;

&lt;p&gt;Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么Hashset、Hashmap、Hashtable中的存储操作是根据什么原理来存取对象的呢？&lt;/p&gt;

&lt;p&gt;以HashSet为例，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是：&lt;br /&gt;
1.判断两个对象的hashCode是否相等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果不相等，认为两个对象也不相等，完毕
如果相等，转入2 (这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.判断两个对象用equals运算是否相等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果不相等，认为两个对象也不相等
如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。&lt;/p&gt;

&lt;h1 id=&quot;答案&quot;&gt;答案&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;两个对象的hashcode相同，对象不一定相等，如果hashcode一致，比较equals，equals返回true，可以判定两者相等&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">问题 两个对象的Hashcode相同，相象是否相相等？equals呢？ 为了解决这个问题，先要了解一下`java.lang.Object`的`Hashcode`和`equals`方法。 equals()方法详解 先看java.lang.Object的默认实现，部分内容进行了翻译。 /** * 表示某个其他对象是否“等于”这一个。 * &amp;lt;p&amp;gt; * equals方法在非null对象引用上实现等价关系 * 自反: 对于任何非null的引用值 x，x.equals(x) 应该返回 true。 * 对称: 对任何非空的引用值 x 和 y, 如果 y.equals(x) 返回true， 那么x.equals(y)必须返回true * 传递: 对任何非空的引用值 x, y, z, 如果 x.equals(y)返回 true ，y.equals(z)返回 true, 那么 x.equals(z)也必须返回true * 一致: 如果x.equals(y)返回是true，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是true。 * 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 * &amp;lt;p&amp;gt; * Object类的equals方法实现了对象上最可能的等价关系;也就是说，对于任何非null的引用值x和y，当且仅当x和y引用同一个对象x == y时返回 true。 * &amp;lt;p&amp;gt; * 请注意，无论何时重写此方法，通常都必须重写hashCode方法，以维护hashCode方法的一般约定，该方法声明相等的对象必须具有相同的哈希码。 * * @param obj the reference object with which to compare. * @return true} if this object is the same as the obj * argument; false} otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) { return (this == obj); } 通常情况下，非空的对象只有引用地址相同的情况下，equals 才会返回 true，上面说的很清晰 “ == “表示的就是引用地址的比较。 但是，很多时候，equals方法会被重写，例如 java.lang.String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } java.lang.String的equals方法不是进行引用地址比较，而是内容比较。 下面举个形象的例子 public class User { private int id; private String name; private String password; &amp;lt;get and set&amp;gt; } 测试方法 User user1 = new User(); User user2 = new User(); assert user1.equals(user2); 如果直接运行上面的内容，会显示异常java.lang.AssertionError，表示两个对象不一样，因为这个时候equals方法是最初的java.lang.Object的 “==” 比较。 public class User { private int id; private String name; private String password; &amp;lt;get and set&amp;gt; @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } User user = (User) o; return id == user.id &amp;amp;&amp;amp; Objects.equals(name, user.name) &amp;amp;&amp;amp; Objects.equals(password, user.password); } @Override public int hashCode() { return Objects.hash(id, name, password); } } 上面重写了 equals方法，此时再次进行比较的时候，从引用值比较改成了内容比较，此时返回的就是true了。 需要注意的是，上面同时重写了 equals 和 Hashcode 方法，在这个简单对象中不重写可能不会有太大的问题，但是后面再集合中，如果不重写可能会导致意想不到的问题发生。 hashCode() 先看java.lang.Object的实现，这里native表示是本地方法，有java以外的语言实现，重点看javaDoc /** * 返回该对象的哈希码值。 这种方法支持哈希表，如由{@link java.util.HashMap}提供的哈希表。 * &amp;lt;p&amp;gt; * hashCode通常情况下遵守的合约是： * &amp;lt;ul&amp;gt; * &amp;lt;li&amp;gt;只要在Java应用程序的执行过程中多次调用同一个对象，{@code hashCode}方法必须始终返回相同的整数，前提是在对象上的比较中没有使用任何信息被修改。 从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。 * &amp;lt;li&amp;gt;如果两个对象根据equals方法相等，则在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。 * &amp;lt;li&amp;gt;如果两个对象根据equals（Object）方法不相等，则不要求对两个对象中的每一个调用hashCode方法都必须产生不同的整数结果。 但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。 * &amp;lt;/ul&amp;gt; * &amp;lt;p&amp;gt; * 尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。 （这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。） * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ public native int hashCode(); 通常情况下，String等对象类型会重写这些方法，例如 public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 简单理解就是 String 使用 s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]重写了hashcode 的值。 请注意，下面只是简单介绍集合的存储原理，关于地址值的部分不准备，这部分等我看完jdk8的代码以后再修改 想要弄明白hashCode的作用，必须要先知道Java中的集合。　　 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，这个地址上的key值就是hashcode值，而value值则记录了这个对象存储的真是地址。 这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 所以，Java对于eqauls方法和hashCode方法是这样规定的： 1.如果两个对象相同，那么它们的hashCode值一定要相同； 2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。 如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。 3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。 换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，Hashcode()方法根据String类的重写代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。 Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系 Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么Hashset、Hashmap、Hashtable中的存储操作是根据什么原理来存取对象的呢？ 以HashSet为例，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是： 1.判断两个对象的hashCode是否相等 如果不相等，认为两个对象也不相等，完毕 如果相等，转入2 (这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。） 2.判断两个对象用equals运算是否相等 如果不相等，认为两个对象也不相等 如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） 为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。 答案 两个对象的hashcode相同，对象不一定相等，如果hashcode一致，比较equals，equals返回true，可以判定两者相等</summary></entry><entry><title type="html">Java中hashcode和一致性哈希算法</title><link href="http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="Java中hashcode和一致性哈希算法" /><published>2018-01-03T17:13:29+08:00</published><updated>2018-01-03T17:13:29+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html">&lt;h1 id=&quot;哈希算法&quot;&gt;哈希算法&lt;/h1&gt;
&lt;h2 id=&quot;什么是哈希算法&quot;&gt;什么是哈希算法&lt;/h2&gt;
&lt;p&gt;哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。&lt;/p&gt;

&lt;h2 id=&quot;哈希算法的特点&quot;&gt;哈希算法的特点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;哈希值是二进制值&lt;/li&gt;
  &lt;li&gt;哈希值具有一定的唯一性&lt;/li&gt;
  &lt;li&gt;哈希值极其紧凑&lt;/li&gt;
  &lt;li&gt;要找到生成同一个哈希值的两个不同输入，在一定时间范围内容是不可能的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正因为哈希值的这些特点，使得哈希算法应用在加密领域成为可能。哈希算法在加密领域的应用，源于哈希算法的不可逆性，对于用户输入的密码，通过哈希算法可以得到一个哈希值。并且，同一个密码，生成的哈希值总是相等的。这样，服务器就可以在不知道用户输入的密码的情况下，判断用户输入的密码是否正确。&lt;/p&gt;

&lt;h2 id=&quot;哈希表&quot;&gt;哈希表&lt;/h2&gt;
&lt;p&gt;哈希表是一种数据机构。&lt;br /&gt;
哈希表根据关键字（key），生成关键字的哈希值，然后通过哈希值映射关键字对应的值。哈希表存储了多余的key（我们本可以只存储值的），是一种用空间换时间的做法。在内存足够的情况下，这种“空间换时间”的做法是值得的。&lt;br /&gt;
哈希表的产生，灵感来源于数组。我们知道，数组号称查询效率最高的数据结构，因为不管数组的容量多大，查询的时间复杂度都是O(1)。如果所有的key都是不重复的整数，那么这就完美了，不需要新增一张哈希表，来做关键字（key）到值（value）的映射。但是，如果key是字符串，情况就不一样了。我们必须要来建一张哈希表，进行映射。数据库索引的原理，其实和哈希表是相同的。&lt;br /&gt;
数据库索引也是用空间换时间的做法。&lt;/p&gt;

&lt;h1 id=&quot;java应用&quot;&gt;Java应用&lt;/h1&gt;
&lt;h2 id=&quot;hashmap应用&quot;&gt;HashMap应用&lt;/h2&gt;

&lt;p&gt;java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道这个元素是否已经存在。&lt;br /&gt;
从实现上来说，java是借助hashcode()方法和equals()方法来实现判断元素是否已经存在的。当我们向HashMap中插入元素A时，&lt;strong&gt;首先&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;调用hashcode()方法，判断元素A在容器中是否已经存在&lt;/code&gt;。如果A元素的hashcode值在HashMap中不存在，则直接插入。&lt;strong&gt;否则&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;接着调用equals()方法，判断A元素在容器中是否已经存在&lt;/code&gt;。&lt;br /&gt;
&lt;strong&gt;hashcode()的时间复杂度为O(1)&lt;/strong&gt;，&lt;strong&gt;equals()方法的时间复杂度为O(m)&lt;/strong&gt;，整体的时间复杂度就是：&lt;strong&gt;O(1) + O(m)&lt;/strong&gt;。  其中，m是桶的深度。&lt;br /&gt;
桶的深度是一个什么概念呢，桶的深度是指具有相同hashcode值得元素的个数，也就是发生哈希碰撞的元素的个数。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;一个好的哈希算法应该尽量减少哈希碰撞的次数。&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关于hashmap中详细的计算方式以后在集合中慢慢学习。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;string应用&quot;&gt;String应用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
     * 返回该字符串的哈希代码。 
     * 哈希值的计算方式 ： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
     * s[i]代表字符串数组中的元素
     * 如果是空字符串，默认hash值是0.
     *
     * @return  a hash code value for this object.
     */
    public int hashCode() {
        int h = hash;
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 将此字符串与指定的对象进行比较。只有参数不是 null，并且和该对象字符序列相同的时候结果是true
     *
     * @param  anObject
     *         The object to compare this {@code String} against
     *
     * @return  {@code true} if the given object represents a {@code String}
     *          equivalent to this string, {@code false} otherwise
     *
     * @see  #compareTo(String)
     * @see  #equalsIgnoreCase(String)
     */
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;一致性哈希算法&quot;&gt;一致性哈希算法&lt;/h1&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;多台机器需要协同作业，保证数据在分布式环境下的一致性，就成为了亟待解决的问题。一致性哈希算法，就是为了解决多台机器，在动态增删的情况下，能够最大限度地保证信息的一致性。&lt;/p&gt;

&lt;p&gt;一致性哈希算法是一种分布式哈希算法，设计目标是为了解决互联网中的热点(Hot spot)问题。&lt;/p&gt;
&lt;h2 id=&quot;参考标准&quot;&gt;参考标准&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;平衡性(Balance)
    &lt;ul&gt;
      &lt;li&gt;平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;单调性(Monotonicity)
    &lt;ul&gt;
      &lt;li&gt;单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分散性(Spread)
    &lt;ul&gt;
      &lt;li&gt;在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;负载(Load)
    &lt;ul&gt;
      &lt;li&gt;负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;

&lt;h3 id=&quot;环形hash空间&quot;&gt;环形Hash空间&lt;/h3&gt;
&lt;p&gt;按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_001.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;把数据通过一定的hash算法处理后映射到环上&quot;&gt;把数据通过一定的hash算法处理后映射到环上&lt;/h3&gt;
&lt;p&gt;现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_002.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hash(object1) = key1；
Hash(object2) = key2；
Hash(object3) = key3；
Hash(object4) = key4；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;将机器通过hash算法映射到环上&quot;&gt;将机器通过hash算法映射到环上&lt;/h3&gt;
&lt;p&gt;在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。
假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：  &lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_003.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hash(NODE1) = KEY1;
Hash(NODE2) = KEY2;
Hash(NODE3) = KEY3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。&lt;/p&gt;

&lt;h3 id=&quot;机器的删除与添加&quot;&gt;机器的删除与添加&lt;/h3&gt;
&lt;p&gt;普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。&lt;/p&gt;
&lt;h4 id=&quot;节点机器的删除&quot;&gt;节点（机器）的删除&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：   ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_004.jpg &quot;title&quot;)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;节点机器的添加&quot;&gt;节点（机器）的添加&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：   ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_005.jpg &quot;title&quot;)  
                                                          
通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;平衡性&quot;&gt;平衡性&lt;/h3&gt;
&lt;p&gt;根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ）,实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_006.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据上图可知对象的映射关系：object1-&amp;gt;NODE1-1，object2-&amp;gt;NODE1-2，object3-&amp;gt;NODE3-2，object4-&amp;gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_007.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：
Hash(“192.168.1.100”);
引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：
Hash(“192.168.1.100#1”); // NODE1-1
Hash(“192.168.1.100#2”); // NODE1-2&lt;/p&gt;

&lt;h2 id=&quot;java实现&quot;&gt;Java实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class ConsistentHash&amp;lt;T&amp;gt; {
    private final HashFunction hashFunction;
    private final int numberOfReplicas;// 节点的复制因子,实际节点个数 *  numberOfReplicas =
                                        // 虚拟节点个数
    private final SortedMap&amp;lt;Long, T&amp;gt; circle = new TreeMap&amp;lt;Long, T&amp;gt;();// 存储虚拟节点的hash值到真实节点的映射

    public ConsistentHash(HashFunction hashFunction, int numberOfReplicas,
            Collection&amp;lt;T&amp;gt; nodes) {
        this.hashFunction = hashFunction;
        this.numberOfReplicas = numberOfReplicas;
        for (T node : nodes)
            add(node);
    }

    public void add(T node) {
        for (int i = 0; i &amp;lt; numberOfReplicas; i++)
            // 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点
            /*
             * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node
             * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上
             */
            circle.put(hashFunction.hash(node.toString() + i), node);
    }

    public void remove(T node) {
        for (int i = 0; i &amp;lt; numberOfReplicas; i++)
            circle.remove(hashFunction.hash(node.toString() + i));
    }

    /*
     * 获得一个最近的顺时针节点,根据给定的key 取Hash
     * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点
     * 再从实际节点中取得 数据
     */
    public T get(Object key) {
        if (circle.isEmpty())
            return null;
        long hash = hashFunction.hash((String) key);// node 用String来表示,获得node在哈希环中的hashCode
        if (!circle.containsKey(hash)) {//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器
            SortedMap&amp;lt;Long, T&amp;gt; tailMap = circle.tailMap(hash);
            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
        }
        return circle.get(hash);
    }

    public long getSize() {
        return circle.size();
    }
    
    /*
     * 查看MD5算法生成的hashCode值---表示整个哈希环中各个虚拟节点位置
     */
    public void testBalance(){
        Set&amp;lt;Long&amp;gt; sets  = circle.keySet();//获得TreeMap中所有的Key
        SortedSet&amp;lt;Long&amp;gt; sortedSets= new TreeSet&amp;lt;Long&amp;gt;(sets);//将获得的Key集合排序
        for(Long hashCode : sortedSets){
            System.out.println(hashCode);
        }
        
        System.out.println(&quot;----each location 's distance are follows: ----&quot;);
        /*
         * 查看用MD5算法生成的long hashCode 相邻两个hashCode的差值
         */
        Iterator&amp;lt;Long&amp;gt; it = sortedSets.iterator();
        Iterator&amp;lt;Long&amp;gt; it2 = sortedSets.iterator();
        if(it2.hasNext())
            it2.next();
        long keyPre, keyAfter;
        while(it.hasNext() &amp;amp;&amp;amp; it2.hasNext()){
            keyPre = it.next();
            keyAfter = it2.next();
            System.out.println(keyAfter - keyPre);
        }
    }
    
    public static void main(String[] args) {
        Set&amp;lt;String&amp;gt; nodes = new HashSet&amp;lt;String&amp;gt;();
        nodes.add(&quot;A&quot;);
        nodes.add(&quot;B&quot;);
        nodes.add(&quot;C&quot;);
        
        ConsistentHash&amp;lt;String&amp;gt; consistentHash = new ConsistentHash&amp;lt;String&amp;gt;(new HashFunction(), 2, nodes);
        consistentHash.add(&quot;D&quot;);
        
        System.out.println(&quot;hash circle size: &quot; + consistentHash.getSize());
        System.out.println(&quot;location of each node are follows: &quot;);
        consistentHash.testBalance();
    }
    
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">哈希算法 什么是哈希算法 哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。 哈希算法的特点 哈希值是二进制值 哈希值具有一定的唯一性 哈希值极其紧凑 要找到生成同一个哈希值的两个不同输入，在一定时间范围内容是不可能的 正因为哈希值的这些特点，使得哈希算法应用在加密领域成为可能。哈希算法在加密领域的应用，源于哈希算法的不可逆性，对于用户输入的密码，通过哈希算法可以得到一个哈希值。并且，同一个密码，生成的哈希值总是相等的。这样，服务器就可以在不知道用户输入的密码的情况下，判断用户输入的密码是否正确。 哈希表 哈希表是一种数据机构。 哈希表根据关键字（key），生成关键字的哈希值，然后通过哈希值映射关键字对应的值。哈希表存储了多余的key（我们本可以只存储值的），是一种用空间换时间的做法。在内存足够的情况下，这种“空间换时间”的做法是值得的。 哈希表的产生，灵感来源于数组。我们知道，数组号称查询效率最高的数据结构，因为不管数组的容量多大，查询的时间复杂度都是O(1)。如果所有的key都是不重复的整数，那么这就完美了，不需要新增一张哈希表，来做关键字（key）到值（value）的映射。但是，如果key是字符串，情况就不一样了。我们必须要来建一张哈希表，进行映射。数据库索引的原理，其实和哈希表是相同的。 数据库索引也是用空间换时间的做法。 Java应用 HashMap应用 java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道这个元素是否已经存在。 从实现上来说，java是借助hashcode()方法和equals()方法来实现判断元素是否已经存在的。当我们向HashMap中插入元素A时，首先，调用hashcode()方法，判断元素A在容器中是否已经存在。如果A元素的hashcode值在HashMap中不存在，则直接插入。否则，接着调用equals()方法，判断A元素在容器中是否已经存在。 hashcode()的时间复杂度为O(1)，equals()方法的时间复杂度为O(m)，整体的时间复杂度就是：O(1) + O(m)。 其中，m是桶的深度。 桶的深度是一个什么概念呢，桶的深度是指具有相同hashcode值得元素的个数，也就是发生哈希碰撞的元素的个数。 一个好的哈希算法应该尽量减少哈希碰撞的次数。 关于hashmap中详细的计算方式以后在集合中慢慢学习。 String应用 /** * 返回该字符串的哈希代码。 * 哈希值的计算方式 ： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * s[i]代表字符串数组中的元素 * 如果是空字符串，默认hash值是0. * * @return a hash code value for this object. */ public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } /** * 将此字符串与指定的对象进行比较。只有参数不是 null，并且和该对象字符序列相同的时候结果是true * * @param anObject * The object to compare this {@code String} against * * @return {@code true} if the given object represents a {@code String} * equivalent to this string, {@code false} otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 一致性哈希算法 基本介绍 多台机器需要协同作业，保证数据在分布式环境下的一致性，就成为了亟待解决的问题。一致性哈希算法，就是为了解决多台机器，在动态增删的情况下，能够最大限度地保证信息的一致性。 一致性哈希算法是一种分布式哈希算法，设计目标是为了解决互联网中的热点(Hot spot)问题。 参考标准 平衡性(Balance) 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。 单调性(Monotonicity) 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 分散性(Spread) 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 负载(Load) 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 实现过程 环形Hash空间 按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图 把数据通过一定的hash算法处理后映射到环上 现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图： Hash(object1) = key1； Hash(object2) = key2； Hash(object3) = key3； Hash(object4) = key4； 将机器通过hash算法映射到环上 在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。 假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下： Hash(NODE1) = KEY1; Hash(NODE2) = KEY2; Hash(NODE3) = KEY3; 通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。 机器的删除与添加 普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。 节点（机器）的删除 以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图： ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_004.jpg &quot;title&quot;) 节点（机器）的添加 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图： ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_005.jpg &quot;title&quot;) 通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。 平衡性 根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。 “虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ）,实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。 以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下： 根据上图可知对象的映射关系：object1-&amp;gt;NODE1-1，object2-&amp;gt;NODE1-2，object3-&amp;gt;NODE3-2，object4-&amp;gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图： “虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值： Hash(“192.168.1.100”); 引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值： Hash(“192.168.1.100#1”); // NODE1-1 Hash(“192.168.1.100#2”); // NODE1-2 Java实现 import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.Set; import java.util.SortedMap; import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; public class ConsistentHash&amp;lt;T&amp;gt; { private final HashFunction hashFunction; private final int numberOfReplicas;// 节点的复制因子,实际节点个数 * numberOfReplicas = // 虚拟节点个数 private final SortedMap&amp;lt;Long, T&amp;gt; circle = new TreeMap&amp;lt;Long, T&amp;gt;();// 存储虚拟节点的hash值到真实节点的映射 public ConsistentHash(HashFunction hashFunction, int numberOfReplicas, Collection&amp;lt;T&amp;gt; nodes) { this.hashFunction = hashFunction; this.numberOfReplicas = numberOfReplicas; for (T node : nodes) add(node); } public void add(T node) { for (int i = 0; i &amp;lt; numberOfReplicas; i++) // 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点 /* * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上 */ circle.put(hashFunction.hash(node.toString() + i), node); } public void remove(T node) { for (int i = 0; i &amp;lt; numberOfReplicas; i++) circle.remove(hashFunction.hash(node.toString() + i)); } /* * 获得一个最近的顺时针节点,根据给定的key 取Hash * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点 * 再从实际节点中取得 数据 */ public T get(Object key) { if (circle.isEmpty()) return null; long hash = hashFunction.hash((String) key);// node 用String来表示,获得node在哈希环中的hashCode if (!circle.containsKey(hash)) {//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器 SortedMap&amp;lt;Long, T&amp;gt; tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); } return circle.get(hash); } public long getSize() { return circle.size(); } /* * 查看MD5算法生成的hashCode值---表示整个哈希环中各个虚拟节点位置 */ public void testBalance(){ Set&amp;lt;Long&amp;gt; sets = circle.keySet();//获得TreeMap中所有的Key SortedSet&amp;lt;Long&amp;gt; sortedSets= new TreeSet&amp;lt;Long&amp;gt;(sets);//将获得的Key集合排序 for(Long hashCode : sortedSets){ System.out.println(hashCode); } System.out.println(&quot;----each location 's distance are follows: ----&quot;); /* * 查看用MD5算法生成的long hashCode 相邻两个hashCode的差值 */ Iterator&amp;lt;Long&amp;gt; it = sortedSets.iterator(); Iterator&amp;lt;Long&amp;gt; it2 = sortedSets.iterator(); if(it2.hasNext()) it2.next(); long keyPre, keyAfter; while(it.hasNext() &amp;amp;&amp;amp; it2.hasNext()){ keyPre = it.next(); keyAfter = it2.next(); System.out.println(keyAfter - keyPre); } } public static void main(String[] args) { Set&amp;lt;String&amp;gt; nodes = new HashSet&amp;lt;String&amp;gt;(); nodes.add(&quot;A&quot;); nodes.add(&quot;B&quot;); nodes.add(&quot;C&quot;); ConsistentHash&amp;lt;String&amp;gt; consistentHash = new ConsistentHash&amp;lt;String&amp;gt;(new HashFunction(), 2, nodes); consistentHash.add(&quot;D&quot;); System.out.println(&quot;hash circle size: &quot; + consistentHash.getSize()); System.out.println(&quot;location of each node are follows: &quot;); consistentHash.testBalance(); } }</summary></entry><entry><title type="html">Java常用关键字总结</title><link href="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html" rel="alternate" type="text/html" title="Java常用关键字总结" /><published>2018-01-02T16:47:46+08:00</published><updated>2018-01-02T16:47:46+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html">&lt;h1 id=&quot;abstrate&quot;&gt;abstrate&lt;/h1&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;abstract 关键字可以&lt;strong&gt;修改类或方法&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 类可以扩展（增加子类），但&lt;strong&gt;不能直接实例化&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。&lt;/p&gt;

&lt;p&gt;如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。&lt;/p&gt;

&lt;p&gt;abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。&lt;/p&gt;

&lt;p&gt;final 类的方法都不能是 abstract，因为 final 类不能有子类。&lt;/p&gt;

&lt;h1 id=&quot;break&quot;&gt;break&lt;/h1&gt;
&lt;h2 id=&quot;说明-1&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;break 总是退出最深层的 while、for、do 或 switch 语句。&lt;/p&gt;

&lt;h1 id=&quot;case&quot;&gt;case&lt;/h1&gt;
&lt;h2 id=&quot;说明-2&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用来标记 switch 语句中的每个分支。&lt;/p&gt;

&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;case 块没有隐式结束点。&lt;/p&gt;

&lt;p&gt;break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。&lt;/p&gt;

&lt;p&gt;如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。&lt;/p&gt;

&lt;h1 id=&quot;catch&quot;&gt;catch&lt;/h1&gt;
&lt;h2 id=&quot;说明-3&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块&lt;/p&gt;

&lt;h2 id=&quot;总结-3&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;br /&gt;
如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。&lt;br /&gt;
如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。&lt;/p&gt;

&lt;h1 id=&quot;continue&quot;&gt;continue&lt;/h1&gt;
&lt;h2 id=&quot;说明-4&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。&lt;/p&gt;

&lt;h2 id=&quot;总结-4&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。&lt;/p&gt;

&lt;h1 id=&quot;extends&quot;&gt;extends&lt;/h1&gt;
&lt;h2 id=&quot;说明-5&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。&lt;/p&gt;

&lt;h2 id=&quot;总结-5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类只能扩展一个其他类。&lt;/p&gt;

&lt;h1 id=&quot;final&quot;&gt;final&lt;/h1&gt;
&lt;h2 id=&quot;说明-6&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。&lt;br /&gt;
final 关键字可以应用于方法，以指示不能重写任何子类中的方法。&lt;/p&gt;

&lt;h2 id=&quot;总结-6&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。&lt;/p&gt;

&lt;p&gt;一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。&lt;/p&gt;

&lt;h1 id=&quot;finally&quot;&gt;finally&lt;/h1&gt;
&lt;h2 id=&quot;说明-7&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。&lt;br /&gt;
finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。&lt;/p&gt;

&lt;h2 id=&quot;总结-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;finally语句在return语句执行之后return返回之前执行的。&lt;/li&gt;
  &lt;li&gt;finally块中的return语句会覆盖try块中的return返回。&lt;/li&gt;
  &lt;li&gt;如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题）&lt;/li&gt;
  &lt;li&gt;try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。&lt;/li&gt;
  &lt;li&gt;当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lanxuezaipiao/p/3440471.html&quot;&gt;阅读更多&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;implements&quot;&gt;implements&lt;/h1&gt;
&lt;h2 id=&quot;说明-8&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。&lt;/p&gt;

&lt;h2 id=&quot;总结-8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;子类必须提供在 接口中所声明的所有方法的实现。&lt;br /&gt;
子类可以声明其他方法和变量，并扩展另一个类。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;instanceof&quot;&gt;instanceof&lt;/h1&gt;
&lt;h2 id=&quot;说明-9&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;instanceof 关键字用来确定对象所属的类。&lt;/p&gt;

&lt;h1 id=&quot;interface&quot;&gt;interface&lt;/h1&gt;
&lt;h2 id=&quot;说明-10&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;interface 关键字用来声明新的 Java 接口，接口是方法的集合。&lt;/p&gt;

&lt;h2 id=&quot;总结-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;实现了接口的任何类都必须提供在该接口中的所有方法的实现。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;native&quot;&gt;native&lt;/h1&gt;
&lt;h2 id=&quot;说明-11&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。&lt;/p&gt;

&lt;h1 id=&quot;private&quot;&gt;private&lt;/h1&gt;
&lt;h2 id=&quot;说明-12&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      private class MyPrivateClass
      {
      }
      private int i;
      private String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-10&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;protected&quot;&gt;protected&lt;/h1&gt;
&lt;h2 id=&quot;说明-13&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      protected class MyPrivateClass
      {
      }
      protected int i;
      protected String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-11&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;public&quot;&gt;public&lt;/h1&gt;
&lt;h2 id=&quot;说明-14&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public class MyPrivateClass
      {
      }
      public int i;
      public String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-12&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在其他任何类或包中引用 public 类、方法或字段。&lt;/p&gt;

&lt;h1 id=&quot;static&quot;&gt;static&lt;/h1&gt;
&lt;h2 id=&quot;说明-15&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public final static int MAX_OBJECTS = 100;
      static int _numObjects = 0;
      static class MyStaticClass
      {
      }
    
      static int getNumObjects()
      {
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-13&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。&lt;br /&gt;
static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。&lt;br /&gt;
static 字段（类的成员变量）在类的所有实例中只存在一次。&lt;br /&gt;
可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。&lt;br /&gt;
模式：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; &lt;/code&gt;&lt;br /&gt;
通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。&lt;/p&gt;

&lt;h1 id=&quot;super&quot;&gt;super&lt;/h1&gt;
&lt;h2 id=&quot;说明-16&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;super 关键字用于引用使用该关键字的类的超类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public MyClass(String arg)
      {
         super(arg);
      }
      public String myStringMethod()
      {
         return super.otherStringMethod();
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-14&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为独立语句出现的 super 表示调用超类的构造方法。&lt;br /&gt;
super.&lt;methodName&gt;() 表示调用超类的方法。&lt;/methodName&gt;&lt;/p&gt;

&lt;h1 id=&quot;synchronized&quot;&gt;synchronized&lt;/h1&gt;
&lt;h2 id=&quot;说明-17&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public synchronized static String mySyncStaticMethod()
      {
      }
      public synchronized String mySyncMethod()
      {
      }
   {
   public class MyOtherClass
   {
      Object someObj;
      public String myMethod()
      {
         &amp;lt;statements&amp;gt;
         synchronized (someObj)
         {
            &amp;lt;statements affecting someObj&amp;gt;
         }
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-15&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可防止代码的关键代码段一次被多个线程执行。&lt;br /&gt;
如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。&lt;br /&gt;
如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。&lt;br /&gt;
如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。  &lt;br /&gt;
每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。   &lt;br /&gt;
实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/p&gt;

&lt;h1 id=&quot;transient&quot;&gt;transient&lt;/h1&gt;
&lt;h2 id=&quot;说明-18&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。&lt;/p&gt;

&lt;h2 id=&quot;总结-16&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。&lt;/li&gt;
  &lt;li&gt;transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。&lt;/li&gt;
  &lt;li&gt;被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特殊说明&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。&lt;br /&gt;
若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。&lt;/p&gt;

&lt;h1 id=&quot;volatile&quot;&gt;volatile&lt;/h1&gt;
&lt;h2 id=&quot;说明-19&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字用于表示可以被多个线程异步修改的成员变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      volatile int sharedValue;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-17&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。&lt;/p&gt;

&lt;p&gt;当一个变量定义为 volatile 之后，将具备两种特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/p&gt;

&lt;p&gt;在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。&lt;/p&gt;

&lt;h2 id=&quot;特殊说明-1&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字在许多 Java 虚拟机中都没有实现。&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">abstrate 说明 abstract 关键字可以修改类或方法。 abstract 类可以扩展（增加子类），但不能直接实例化。 abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。 总结 仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。 如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。 break 说明 用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 总结 break 总是退出最深层的 while、for、do 或 switch 语句。 case 说明 用来标记 switch 语句中的每个分支。 总结 case 块没有隐式结束点。 break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 catch 说明 catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块 总结 开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。 如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 continue 说明 continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 总结 continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。 extends 说明 用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。 总结 一个类只能扩展一个其他类。 final 说明 final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。 final 关键字可以应用于方法，以指示不能重写任何子类中的方法。 总结 一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。 一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。 finally 说明 finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。 finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。 总结 开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 finally语句在return语句执行之后return返回之前执行的。 finally块中的return语句会覆盖try块中的return返回。 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题） try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。 阅读更多 implements 说明 implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。 总结 子类必须提供在 接口中所声明的所有方法的实现。 子类可以声明其他方法和变量，并扩展另一个类。 一个类可以实现多个接口。 instanceof 说明 instanceof 关键字用来确定对象所属的类。 interface 说明 interface 关键字用来声明新的 Java 接口，接口是方法的集合。 总结 实现了接口的任何类都必须提供在该接口中的所有方法的实现。 一个类可以实现多个接口。 native 说明 native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。 private 说明 private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 public class MyPublicClass { private class MyPrivateClass { } private int i; private String myMethod() { &amp;lt;statements&amp;gt; } } 总结 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 protected 说明 protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { protected class MyPrivateClass { } protected int i; protected String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 public 说明 public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { public class MyPrivateClass { } public int i; public String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在其他任何类或包中引用 public 类、方法或字段。 static 说明 static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 public class MyPublicClass { public final static int MAX_OBJECTS = 100; static int _numObjects = 0; static class MyStaticClass { } static int getNumObjects() { } } 总结 通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。 模式： public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; 通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。 super 说明 super 关键字用于引用使用该关键字的类的超类。 public class MyClass { public MyClass(String arg) { super(arg); } public String myStringMethod() { return super.otherStringMethod(); } } 总结 作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法。 synchronized 说明 synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 public class MyClass { public synchronized static String mySyncStaticMethod() { } public synchronized String mySyncMethod() { } { public class MyOtherClass { Object someObj; public String myMethod() { &amp;lt;statements&amp;gt; synchronized (someObj) { &amp;lt;statements affecting someObj&amp;gt; } } } 总结 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 transient 说明 transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 总结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 特殊说明 对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。 若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。 volatile 说明 volatile 关键字用于表示可以被多个线程异步修改的成员变量。 public class MyClass { volatile int sharedValue; } 总结 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 当一个变量定义为 volatile 之后，将具备两种特性： 保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。 volatile 性能： 　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 特殊说明 volatile 关键字在许多 Java 虚拟机中都没有实现。</summary></entry><entry><title type="html">Mybatis初始化(2)</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html" rel="alternate" type="text/html" title="Mybatis初始化(2)" /><published>2017-12-25T20:27:29+08:00</published><updated>2017-12-25T20:27:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html">&lt;h1 id=&quot;mybatis源码解析一mybatis初始化过程解析&quot;&gt;MyBatis源码解析(一)——MyBatis初始化过程解析&lt;/h1&gt;

&lt;h1 id=&quot;1-准备工作&quot;&gt;1. 准备工作&lt;/h1&gt;

&lt;p&gt;为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-94ca3998bee0abb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/294&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-product-产品实体类&quot;&gt;1.1 Product 产品实体类&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;12-productmapper-产品持久化接口&quot;&gt;1.2 ProductMapper 产品持久化接口&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&amp;lt;Product&amp;gt; selectProductList();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-productmapperxml-产品映射文件&quot;&gt;1.3 ProductMapper.xml 产品映射文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectProductList&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.entity.Product&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        select * from product
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;14-dbproperties-数据库配置文件&quot;&gt;1.4 db.properties 数据库配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8
username=root
password=xxxxxx

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-mybatisxml-mybatis的配置文件&quot;&gt;1.5 mybatis.xml MyBatis的配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${driver}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${username}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${password}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team/njupt/mapper/ProductMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;16-main-主函数&quot;&gt;1.6 Main 主函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        String resource = &quot;mybatis.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-mybatis初始化过程&quot;&gt;2. MyBatis初始化过程&lt;/h1&gt;

&lt;h2 id=&quot;21-获取配置文件&quot;&gt;2.1 获取配置文件&lt;/h2&gt;

&lt;p&gt;当系统初始化时，首先会读取配置文件，并将其解析成InputStream&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String resource = &quot;mybatis.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;22-创建sqlsessionfactorybuilder对象&quot;&gt;2.2 创建SqlSessionFactoryBuilder对象&lt;/h2&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;的名字中可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;是用来创建&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;对象的。
来看一下SqlSessionFactoryBuilder源码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-b0f3e995ac56f20a.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;h2 id=&quot;23-sqlsessionfactory创建过程&quot;&gt;2.3 SqlSessionFactory创建过程&lt;/h2&gt;

&lt;p&gt;下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;231-构造xmlconfigbuilder对象&quot;&gt;2.3.1 构造XMLConfigBuilder对象&lt;/h4&gt;

&lt;p&gt;build函数首先会构造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;的体系结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-3998f972a6a4e251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;是用来解析XML配置文件的，不同类型&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;用来解析MyBatis配置文件的不同部位。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;用来解析MyBatis的配置文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;用来解析MyBatis中的映射文件（如上文提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProductMapper.xml&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLStatementBuilder&lt;/code&gt;用来解析映射文件中的SQL语句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这些&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;都有一个共同的父类——&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;。这个父类维护了一个全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，MyBatis的配置文件解析后就以&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的形式存储。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象时，就会初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，并且在初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的时候，一些别名会被注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
super(new Configuration());
ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
this.configuration.setVariables(props);
this.parsed = false;
this.environment = environment;
this.parser = parser;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Configuration() {
typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);

typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);
typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);
typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);
……
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;232-解析配置文件&quot;&gt;2.3.2 解析配置文件&lt;/h3&gt;

&lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象之后，接下来就可以用它来解析配置文件了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void parseConfiguration(XNode root) {
  try {
    // 解析&amp;lt;properties&amp;gt;节点
    propertiesElement(root.evalNode(&quot;properties&quot;));
    // 解析&amp;lt;settings&amp;gt;节点
    Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
    loadCustomVfs(settings);
    // 解析&amp;lt;typeAliases&amp;gt;节点
    typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
    // 解析&amp;lt;plugins&amp;gt;节点
    pluginElement(root.evalNode(&quot;plugins&quot;));
    // 解析&amp;lt;objectFactory&amp;gt;节点
    objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
    objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
    // 解析&amp;lt;reflectorFactory&amp;gt;节点
    reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
    settingsElement(settings);
    // 解析&amp;lt;environments&amp;gt;节点
    environmentsElement(root.evalNode(&quot;environments&quot;));
    databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
    typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
    // 解析&amp;lt;mappers&amp;gt;节点
    mapperElement(root.evalNode(&quot;mappers&quot;));
  } catch (Exception e) {
    throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;会依次解析配置文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; settings &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; environments&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; typeAliases &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; plugins &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; mappers &amp;gt;&lt;/code&gt;等属性。下面介绍下几个重要属性的解析过程。&lt;/p&gt;

&lt;h4 id=&quot;2321-properties节点的解析过程&quot;&gt;2.3.2.1 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;节点的解析过程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的定义如下：

    
&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;
  &amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的解析过程：

&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
      * @Param context &amp;lt;properties&amp;gt;节点
      */
    private void propertiesElement(XNode context) throws Exception {
      if (context != null) {
        // 获取&amp;lt;properties&amp;gt;节点的所有子节点
        Properties defaults = context.getChildrenAsProperties();
        // 获取&amp;lt;properties&amp;gt;节点上的resource属性
        String resource = context.getStringAttribute(&quot;resource&quot;);
        // 获取&amp;lt;properties&amp;gt;节点上的url属性
        String url = context.getStringAttribute(&quot;url&quot;);
        // resource和url不能同时存在
        if (resource != null &amp;amp;&amp;amp; url != null) {
          throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);
        }
        if (resource != null) {
          // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中        
          defaults.putAll(Resources.getResourceAsProperties(resource));
        } else if (url != null) {
          // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中
          defaults.putAll(Resources.getUrlAsProperties(url));
        }
        // 获取configuration中原本的属性，并添加至defaults容器中
        Properties vars = configuration.getVariables();
        if (vars != null) {
          defaults.putAll(vars);
        }
        parser.setVariables(defaults);
        // 将defaults容器添加至configuration中
        configuration.setVariables(defaults);
      }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。
*   然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。）
*   最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2322-节点的解析过程&quot;&gt;2.3.2.2 &lt;settings&gt;节点的解析过程&lt;/settings&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的定义如下：

&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;settings&amp;gt;
      &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的解析过程：
`&lt;settings&gt;`属性的解析过程和 `&lt;properties&gt;`属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。

&lt;/properties&gt;&lt;/settings&gt;&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2323-属性的解析过程&quot;&gt;2.3.2.3 &lt;typeAliases&gt;属性的解析过程&lt;/typeAliases&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;属性的定义方式有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方式1：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt;
  &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方式2：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&amp;lt; typeAlias &amp;gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute(&quot;alias&quot;);
        String type = child.getStringAttribute(&quot;type&quot;);
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAlias&amp;gt;&lt;/code&gt;节点，那么MyBatis就会给指定的类起指定的别名。&lt;/li&gt;
  &lt;li&gt;这些别名都会被存入&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2324-节点的解析过程&quot;&gt;2.3.2.4 &lt;mappers&gt;节点的解析过程&lt;/mappers&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的定义方式有如下四种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方式1：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式2：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式3：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式4：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&amp;lt;mappers&amp;gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&amp;lt;mapper&amp;gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis会遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;下所有的子节点，如果当前遍历到的节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;，则MyBatis会将该包下的所有Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
  &lt;li&gt;如果当前节点为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在解析前，首先需要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;，创建过程如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) {
  // 将configuration赋给BaseBuilder
  super(configuration);
  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）
  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);
  this.parser = parser;
  this.sqlFragments = sqlFragments;
  this.resource = resource;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;首先会初始化父类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
      &lt;li&gt;然后创建&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void parse() {
  // 若当前的Mapper.xml尚未被解析，则开始解析
  // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了
  if (!configuration.isResourceLoaded(resource)) {
    // 解析&amp;lt;mapper&amp;gt;节点
    configurationElement(parser.evalNode(&quot;/mapper&quot;));
    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析
    configuration.addLoadedResource(resource);
    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中
    bindMapperForNamespace();
  }

  parsePendingResultMaps();
  parsePendingCacheRefs();
  parsePendingStatements();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configurationElement&lt;/code&gt;函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void configurationElement(XNode context) {
try {
  // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁
  String namespace = context.getStringAttribute(&quot;namespace&quot;);
  if (namespace == null || namespace.equals(&quot;&quot;)) {
    throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;);
  }
  // 将namespace属性值赋给builderAssistant
  builderAssistant.setCurrentNamespace(namespace);
  // 解析&amp;lt;cache-ref&amp;gt;节点
  cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
  // 解析&amp;lt;cache&amp;gt;节点
  cacheElement(context.evalNode(&quot;cache&quot;));
  // 解析&amp;lt;parameterMap&amp;gt;节点
  parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
  // 解析&amp;lt;resultMap&amp;gt;节点
  resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
  // 解析&amp;lt;sql&amp;gt;节点
  sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
  // 解析sql语句      
  buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
} catch (Exception e) {
  throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMapElements&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点，这些节点会被解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMaps&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt;
  &amp;lt;constructor&amp;gt;
     &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt;
     &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt;
  &amp;lt;/constructor&amp;gt;
  &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt;
  &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception {
  ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的id属性
  String id = resultMapNode.getStringAttribute(&quot;id&quot;,
    resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型）
  String type = resultMapNode.getStringAttribute(&quot;type&quot;,
    resultMapNode.getStringAttribute(&quot;ofType&quot;,
        resultMapNode.getStringAttribute(&quot;resultType&quot;,
            resultMapNode.getStringAttribute(&quot;javaType&quot;))));
  // 获取extends属性
  String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);
  // 获取autoMapping属性
  Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);
  // 将resultMap的返回值类型转换成Class对象
  Class&amp;lt;?&amp;gt; typeClass = resolveClass(type);
  Discriminator discriminator = null;
  // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;();
  resultMappings.addAll(additionalResultMappings);
  // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren();
  for (XNode resultChild : resultChildren) {
    // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去
    if (&quot;constructor&quot;.equals(resultChild.getName())) {
      processConstructorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去
    else if (&quot;discriminator&quot;.equals(resultChild.getName())) {
      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去
    else {
      // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property
      List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;();
      if (&quot;id&quot;.equals(resultChild.getName())) {
        flags.add(ResultFlag.ID);
      }
      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
    }
  }
  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）
  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
  try {
    return resultMapResolver.resolve();
  } catch (IncompleteElementException  e) {
    configuration.addIncompleteResultMap(resultMapResolver);
    throw e;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;，用于构造&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ResultMap resolve() {
  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlElement&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildStatementFromContext&lt;/code&gt;函数
该函数会将映射文件中的sql语句解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;MappedStatement&lt;/code&gt;对象，并存在&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mappedStatements&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;233-创建sqlsessionfactory对象&quot;&gt;2.3.3 创建SqlSessionFactory对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回过头来再看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;函数，刚才说了半天，介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;解析映射文件的过程，解析完成之后&lt;code class=&quot;highlighter-rouge&quot;&gt;parser.parse()&lt;/code&gt;函数会返回一个包含了映射文件解析结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;作为参数，创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;对象。
&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;是接口&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的一个实现类，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的体系结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-da2dbd8f1f2ac844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;创建完毕！&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">MyBatis源码解析(一)——MyBatis初始化过程解析 1. 准备工作 为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示： 1.1 Product 产品实体类 public class Product { private long id; private String productName; private String productContent; private String price; private int sort; private int falseSales; private long category_id; private byte type; private byte state; // PS：省略setter、getter函数 } 1.2 ProductMapper 产品持久化接口 public interface ProductMapper { /** * 查询所有的产品 * @return */ List&amp;lt;Product&amp;gt; selectProductList(); } 1.3 ProductMapper.xml 产品映射文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;team.njupt.mapper.ProductMapper&quot;&amp;gt; &amp;lt;select id=&quot;selectProductList&quot; resultType=&quot;team.njupt.entity.Product&quot;&amp;gt; select * from product &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 1.4 db.properties 数据库配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8 username=root password=xxxxxx 1.5 mybatis.xml MyBatis的配置文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;properties resource=&quot;db.properties&quot;&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;team/njupt/mapper/ProductMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 1.6 Main 主函数 public class Main { public static void main(String[] args) throws IOException { String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); try { ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class); List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList(); for (Product product : productList) { System.out.printf(product.toString()); } } finally { sqlSession.close(); } } } 2. MyBatis初始化过程 2.1 获取配置文件 当系统初始化时，首先会读取配置文件，并将其解析成InputStream String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); 2.2 创建SqlSessionFactoryBuilder对象 从SqlSessionFactoryBuilder的名字中可以看出，SqlSessionFactoryBuilder是用来创建SqlSessionFactory对象的。 来看一下SqlSessionFactoryBuilder源码： SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。 2.3 SqlSessionFactory创建过程 下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 2.3.1 构造XMLConfigBuilder对象 build函数首先会构造一个XMLConfigBuilder对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下XMLConfigBuilder的体系结构。 XMLxxxBuilder是用来解析XML配置文件的，不同类型XMLxxxBuilder用来解析MyBatis配置文件的不同部位。比如：XMLConfigBuilder用来解析MyBatis的配置文件，XMLMapperBuilder用来解析MyBatis中的映射文件（如上文提到的ProductMapper.xml），XMLStatementBuilder用来解析映射文件中的SQL语句。 这些XMLxxxBuilder都有一个共同的父类——BaseBuilder。这个父类维护了一个全局的Configuration对象，MyBatis的配置文件解析后就以Configuration对象的形式存储。 当创建XMLConfigBuilder对象时，就会初始化Configuration对象，并且在初始化Configuration对象的时候，一些别名会被注册到Configuration的typeAliasRegistry容器中。 private XMLConfigBuilder(XPathParser parser, String environment, Properties props) { super(new Configuration()); ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; } public Configuration() { typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); …… } 2.3.2 解析配置文件 当有了XMLConfigBuilder对象之后，接下来就可以用它来解析配置文件了。 private void parseConfiguration(XNode root) { try { // 解析&amp;lt;properties&amp;gt;节点 propertiesElement(root.evalNode(&quot;properties&quot;)); // 解析&amp;lt;settings&amp;gt;节点 Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); // 解析&amp;lt;typeAliases&amp;gt;节点 typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); // 解析&amp;lt;plugins&amp;gt;节点 pluginElement(root.evalNode(&quot;plugins&quot;)); // 解析&amp;lt;objectFactory&amp;gt;节点 objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); // 解析&amp;lt;reflectorFactory&amp;gt;节点 reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // 解析&amp;lt;environments&amp;gt;节点 environmentsElement(root.evalNode(&quot;environments&quot;)); databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); // 解析&amp;lt;mappers&amp;gt;节点 mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } 从上述代码中可以看到，XMLConfigBuilder会依次解析配置文件中的&amp;lt;properties&amp;gt;、&amp;lt; settings &amp;gt;、&amp;lt; environments&amp;gt;、&amp;lt; typeAliases &amp;gt;、&amp;lt; plugins &amp;gt;、&amp;lt; mappers &amp;gt;等属性。下面介绍下几个重要属性的解析过程。 2.3.2.1 &amp;lt;properties&amp;gt;节点的解析过程 节点的定义如下： &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt; &amp;lt;/properties&amp;gt; 节点的解析过程： /** * @Param context &amp;lt;properties&amp;gt;节点 */ private void propertiesElement(XNode context) throws Exception { if (context != null) { // 获取&amp;lt;properties&amp;gt;节点的所有子节点 Properties defaults = context.getChildrenAsProperties(); // 获取&amp;lt;properties&amp;gt;节点上的resource属性 String resource = context.getStringAttribute(&quot;resource&quot;); // 获取&amp;lt;properties&amp;gt;节点上的url属性 String url = context.getStringAttribute(&quot;url&quot;); // resource和url不能同时存在 if (resource != null &amp;amp;&amp;amp; url != null) { throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other.&quot;); } if (resource != null) { // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getResourceAsProperties(resource)); } else if (url != null) { // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getUrlAsProperties(url)); } // 获取configuration中原本的属性，并添加至defaults容器中 Properties vars = configuration.getVariables(); if (vars != null) { defaults.putAll(vars); } parser.setVariables(defaults); // 将defaults容器添加至configuration中 configuration.setVariables(defaults); } } * 首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。 * 然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。） * 最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。 2.3.2.2 节点的解析过程 节点的定义如下： &amp;lt;settings&amp;gt; &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;/settings&amp;gt; 节点的解析过程： ``属性的解析过程和 ``属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。 2.3.2.3 属性的解析过程 &amp;lt;typeAliases&amp;gt;属性的定义方式有如下两种： 方式1： &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt; &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 方式2： &amp;lt;typeAliases&amp;gt; &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。 &amp;lt;typeAliases&amp;gt;节点的解析过程如下： private void typeAliasesElement(XNode parent) { if (parent != null) { // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点 for (XNode child : parent.getChildren()) { // 若当前结点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;上的name属性（包名） String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中 configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } // 如果当前结点为&amp;lt; typeAlias &amp;gt; else { // 获取alias和type属性 String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); // 注册进configuration的typeAliasRegistry中 try { Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e); } } } } } 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;package&amp;gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名） 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;typeAlias&amp;gt;节点，那么MyBatis就会给指定的类起指定的别名。 这些别名都会被存入configuration的typeAliasRegistry容器中。 2.3.2.4 节点的解析过程 &amp;lt;mappers&amp;gt;节点的定义方式有如下四种： 方式1： &amp;lt;mappers&amp;gt; &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式2： &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式3： &amp;lt;mappers&amp;gt; &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式4： &amp;lt;mappers&amp;gt; &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;mappers&amp;gt;节点的解析过程如下： private void mapperElement(XNode parent) throws Exception { if (parent != null) { // 遍历&amp;lt;mappers&amp;gt;下所有子节点 for (XNode child : parent.getChildren()) { // 如果当前节点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名） String mapperPackage = child.getStringAttribute(&quot;name&quot;); // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中 configuration.addMappers(mapperPackage); } // 如果当前节点为&amp;lt;mapper&amp;gt; else { // 依次获取resource、url、class属性 String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); // 解析resource属性（Mapper.xml文件的路径） if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(resource); // 将Mapper.xml文件解析成输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } // 解析url属性（Mapper.xml文件的路径） else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } // 解析class属性（Mapper Class的全限定名） else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) { // 将Mapper Class的权限定名转化成Class对象 Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass); // 注册进configuration对象的mapperRegistry容器中 configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } MyBatis会遍历&amp;lt;mappers&amp;gt;下所有的子节点，如果当前遍历到的节点是&amp;lt;package&amp;gt;，则MyBatis会将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中。 如果当前节点为&amp;lt;mapper&amp;gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到configuration的mapperRegistry容器中。 其中，&amp;lt;mapper&amp;gt;节点的解析过程如下： XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); 在解析前，首先需要创建XMLMapperBuilder，创建过程如下： private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) { // 将configuration赋给BaseBuilder super(configuration); // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者） this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } 首先会初始化父类BaseBuilder，并将configuration赋给BaseBuilder； 然后创建MapperBuilderAssistant对象，该对象为XMLMapperBuilder的协助者，用来协助XMLMapperBuilder完成一些解析映射文件的动作。 当有了XMLMapperBuilder后，便可进入解析&amp;lt;mapper&amp;gt;的过程： public void parse() { // 若当前的Mapper.xml尚未被解析，则开始解析 // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了 if (!configuration.isResourceLoaded(resource)) { // 解析&amp;lt;mapper&amp;gt;节点 configurationElement(parser.evalNode(&quot;/mapper&quot;)); // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析 configuration.addLoadedResource(resource); // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中 bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements(); } configurationElement函数 private void configurationElement(XNode context) { try { // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁 String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;); } // 将namespace属性值赋给builderAssistant builderAssistant.setCurrentNamespace(namespace); // 解析&amp;lt;cache-ref&amp;gt;节点 cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); // 解析&amp;lt;cache&amp;gt;节点 cacheElement(context.evalNode(&quot;cache&quot;)); // 解析&amp;lt;parameterMap&amp;gt;节点 parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // 解析&amp;lt;resultMap&amp;gt;节点 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // 解析&amp;lt;sql&amp;gt;节点 sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 解析sql语句 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e); } } resultMapElements函数 该函数用于解析映射文件中所有的&amp;lt;resultMap&amp;gt;节点，这些节点会被解析成ResultMap对象，存储在Configuration对象的resultMaps容器中。 &amp;lt;resultMap&amp;gt;节点定义如下： &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt; &amp;lt;constructor&amp;gt; &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt; &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt; &amp;lt;/constructor&amp;gt; &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt; &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap&amp;gt;节点的解析过程： private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的id属性 String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型） String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // 获取extends属性 String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // 获取autoMapping属性 Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); // 将resultMap的返回值类型转换成Class对象 Class&amp;lt;?&amp;gt; typeClass = resolveClass(type); Discriminator discriminator = null; // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;(); resultMappings.addAll(additionalResultMappings); // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去 if (&quot;constructor&quot;.equals(resultChild.getName())) { processConstructorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去 else if (&quot;discriminator&quot;.equals(resultChild.getName())) { discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去 else { // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下） ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } ResultMapResolver这个类很纯粹，有且仅有一个函数resolve，用于构造ResultMap对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于MapperBuilderAssistant.addResultMap完成的。 public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } sqlElement函数 该函数用于解析映射文件中所有的&amp;lt;sql&amp;gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。 &amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt; buildStatementFromContext函数 该函数会将映射文件中的sql语句解析成MappedStatement对象，并存在configuration的mappedStatements。 2.3.3 创建SqlSessionFactory对象 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 回过头来再看一下SqlSessionFactory的build函数，刚才说了半天，介绍了XMLConfigBuilder解析映射文件的过程，解析完成之后parser.parse()函数会返回一个包含了映射文件解析结果的configuration对象，紧接着，这个对象将作为参数传递给另一个build函数，如下： public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 这个函数将configuration作为参数，创建了DefaultSqlSessionFactory对象。 DefaultSqlSessionFactory是接口SqlSessionFactory的一个实现类，SqlSessionFactory的体系结构如下图所示： 此时，SqlSessionFactory创建完毕！</summary></entry><entry><title type="html">Spring手动提交事务</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html" rel="alternate" type="text/html" title="Spring手动提交事务" /><published>2017-12-23T10:12:47+08:00</published><updated>2017-12-23T10:12:47+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html">&lt;p&gt;开篇之前先说一下问题来源，我是用了&lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;redisson&lt;/a&gt;作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;);
	if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
		RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;);
		if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
			// 吧啦吧啦
			// 这里是业务逻辑代码
			// 修改对象状态等等
		} else {
			//操作超时，请重新操作
		}
		if (BLock.isLocked()) {
			BLock.unlock();
		}
	} else {
		//操作超时，请重新操作
	}
	if (ALock.isLocked()) {
		ALock.unlock();
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。&lt;/p&gt;

&lt;p&gt;两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。&lt;/p&gt;

&lt;p&gt;结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。&lt;/p&gt;

&lt;p&gt;解决方案1：
	把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题
	这种方法也有缺点，部分业务处理需要在controller中进行&lt;/p&gt;

&lt;p&gt;解决方案2：
	service层手动提交事务，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	@Resource 
    private DataSourceTransactionManager transactionManager; 


	// 下面是手动提交
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();  
	// 事物隔离级别，开启新事务，这样会比较安全些。  
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); 
	// 获得事务状态 
	TransactionStatus status = transactionManager.getTransaction(def);  
	try {  
		transactionManager.commit(status);  
	} catch (Exception e) {  
		transactionManager.rollback(status);  
	}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><summary type="html">开篇之前先说一下问题来源，我是用了redisson作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。 RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;); if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;); if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { // 吧啦吧啦 // 这里是业务逻辑代码 // 修改对象状态等等 } else { //操作超时，请重新操作 } if (BLock.isLocked()) { BLock.unlock(); } } else { //操作超时，请重新操作 } if (ALock.isLocked()) { ALock.unlock(); } 这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。 两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。 结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。 解决方案1： 把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题 这种方法也有缺点，部分业务处理需要在controller中进行 解决方案2： service层手动提交事务，代码如下 @Resource private DataSourceTransactionManager transactionManager; // 下面是手动提交 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // 事物隔离级别，开启新事务，这样会比较安全些。 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); // 获得事务状态 TransactionStatus status = transactionManager.getTransaction(def); try { transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } 以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。 由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。</summary></entry><entry><title type="html">Mybatis二级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis二级缓存" /><published>2017-12-19T19:51:29+08:00</published><updated>2017-12-19T19:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/27.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。&lt;/p&gt;

&lt;p&gt;如果用户配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cacheEnabled=true&quot;&lt;/code&gt;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：&lt;code class=&quot;highlighter-rouge&quot;&gt;CachingExecutor&lt;/code&gt;，这时SqlSession使用CachingExecutor对象来完成操作请求。&lt;/p&gt;

&lt;p&gt;CachingExecutor对于查询请求，会先判断该查询请求在Application级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;二级缓存中是否有缓存结果&lt;/code&gt;，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。&lt;/p&gt;

&lt;h1 id=&quot;2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/28.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，&lt;/p&gt;

&lt;p&gt;CachingExecutor和Executor的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/29.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/h1&gt;

&lt;p&gt;Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置 为一个Mapper分配一个Cache缓存对象&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置 为多个Mapper分配相同的Cache对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/30.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID&lt;/p&gt;
&lt;h2 id=&quot;32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;如果你想让多个Mapper公用一个Cache的话，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;&lt;/code&gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/31.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/h1&gt;
&lt;p&gt;二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。&lt;/p&gt;

&lt;p&gt;虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`&lt;select&gt; `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。&lt;/select&gt;&lt;/cache&gt;&lt;/p&gt;

&lt;p&gt;如下所示，Select语句配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;useCache=&quot;true&quot;&lt;/code&gt;，则表明这条Select语句的查询会使用二级缓存。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;useCache=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开启二级缓存的条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true&lt;/li&gt;
  &lt;li&gt;该select语句所在的Mapper，配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cached-ref&amp;gt;&lt;/code&gt;节点，并且有效&lt;/li&gt;
  &lt;li&gt;该select语句的参数 useCache=true&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/h1&gt;
&lt;p&gt;二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库&lt;/p&gt;

&lt;h1 id=&quot;6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;使用MyBatis的二级缓存有三个选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis自身提供的缓存实现&lt;/p&gt;

    &lt;p&gt;MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义的Cache接口实现&lt;/p&gt;

    &lt;p&gt;MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache type=&quot;&quot;&amp;gt;&lt;/code&gt;节点的type属性上即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟第三方内存缓存库的集成&lt;/p&gt;

    &lt;p&gt;MyBatis还支持跟第三方内存缓存库如Memecached的集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/h1&gt;
&lt;p&gt;MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/32.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；&lt;/li&gt;
  &lt;li&gt;FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；&lt;/li&gt;
  &lt;li&gt;Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">1. Mybatis缓存机制整体设计 2. 二级缓存的基本原理 3. 二级缓存的划分 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 4. 开启二级缓存的条件 5. 缓存使用顺序 6. 二级缓存的实现方式 7. Mybatis自身提供的二级缓存实现 1. Mybatis缓存机制整体设计   当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。 如果用户配置了&quot;cacheEnabled=true&quot;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。 CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。 2. 二级缓存的基本原理 CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式， CachingExecutor和Executor的关系图 3. 二级缓存的划分 Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象 使用&amp;lt;cache&amp;gt;节点配置 为一个Mapper分配一个Cache缓存对象 使用&amp;lt;cache-ref&amp;gt;节点配置 为多个Mapper分配相同的Cache对象 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&amp;lt;cache&amp;gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象 每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 如果你想让多个Mapper公用一个Cache的话，你可以使用&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。 4. 开启二级缓存的条件 二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。 虽然在Mapper中配置了,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在` `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。 如下所示，Select语句配置了useCache=&quot;true&quot;，则表明这条Select语句的查询会使用二级缓存。 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&amp;gt; 开启二级缓存的条件 MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了&amp;lt;cache&amp;gt; 或&amp;lt;cached-ref&amp;gt;节点，并且有效 该select语句的参数 useCache=true 5. 缓存使用顺序 二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库 6. 二级缓存的实现方式 使用MyBatis的二级缓存有三个选择 MyBatis自身提供的缓存实现 MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等 用户自定义的Cache接口实现 MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&amp;lt;cache type=&quot;&quot;&amp;gt;节点的type属性上即可 跟第三方内存缓存库的集成 MyBatis还支持跟第三方内存缓存库如Memecached的集成 7. Mybatis自身提供的二级缓存实现 MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略： LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录； FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉； Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</summary></entry></feed>