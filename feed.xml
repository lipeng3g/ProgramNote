<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ProgramNote/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ProgramNote/" rel="alternate" type="text/html" hreflang="en" /><updated>2017-12-20T20:23:48+08:00</updated><id>http://localhost:4000/ProgramNote/</id><title type="html">lipeng’s blog</title><subtitle>lipeng's Blog
</subtitle><author><name>lipeng</name></author><entry><title type="html">Javascript过滤前后空格</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html" rel="alternate" type="text/html" title="Javascript过滤前后空格" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html">&lt;h1 id=&quot;javascript过滤前后空格&quot;&gt;Javascript过滤前后空格&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript%E8%BF%87%E6%BB%A4%E5%89%8D%E5%90%8E%E7%A9%BA%E6%A0%BC&quot;&gt;Javascript过滤前后空格&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%9F%A5&quot;&gt;循环检查&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2&quot;&gt;正则表达式替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;JQuery&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;循环检查&quot;&gt;循环检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;//供使用者调用 
function trim(s){ 
  return trimRight(trimLeft(s)); 
} 
//去掉左边的空白 
function trimLeft(s){ 
  if(s == null) { 
    return &quot;&quot;; 
  } 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(0)) != -1) { 
    var j=0, i = str.length; 
    while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ 
      j++; 
    } 
    str = str.substring(j, i); 
  } 
  return str; 
} 

//去掉右边的空白
function trimRight(s){ 
  if(s == null) return &quot;&quot;; 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ 
    var i = str.length - 1; 
    while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ 
      i--; 
    } 
    str = str.substring(0, i+1); 
  } 
  return str; 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式替换&quot;&gt;正则表达式替换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;
String.prototype.Trim = function() //去左右空格;
{ 
    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
} 
String.prototype.LTrim = function() //去左空格;
{ 
    return this.replace(/(^\s*)/g, &quot;&quot;); 
} 
String.prototype.RTrim = function() //去右空格;
{ 
    return this.replace(/(\s*$)/g, &quot;&quot;); 
} 

//去左空格;
function ltrim(s){
    return s.replace(/(^\s*)/g, &quot;&quot;);
}
//去右空格;
function rtrim(s){
    return s.replace(/(\s*$)/g, &quot;&quot;);
}
//去左右空格;
function trim(s){
    return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;JQuery&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;// 使用方法
$.trim(str) 
// Jquery实现方法
function trim(str){  
    return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');  
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><summary type="html">Javascript过滤前后空格 Javascript过滤前后空格 循环检查 正则表达式替换 JQuery 循环检查 推荐 ☆☆☆ //供使用者调用 function trim(s){ return trimRight(trimLeft(s)); } //去掉左边的空白 function trimLeft(s){ if(s == null) { return &quot;&quot;; } var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(0)) != -1) { var j=0, i = str.length; while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ j++; } str = str.substring(j, i); } return str; } //去掉右边的空白 function trimRight(s){ if(s == null) return &quot;&quot;; var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ var i = str.length - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ i--; } str = str.substring(0, i+1); } return str; } 正则表达式替换 推荐 ☆☆☆☆ String.prototype.Trim = function() //去左右空格; { return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } String.prototype.LTrim = function() //去左空格; { return this.replace(/(^\s*)/g, &quot;&quot;); } String.prototype.RTrim = function() //去右空格; { return this.replace(/(\s*$)/g, &quot;&quot;); } //去左空格; function ltrim(s){ return s.replace(/(^\s*)/g, &quot;&quot;); } //去右空格; function rtrim(s){ return s.replace(/(\s*$)/g, &quot;&quot;); } //去左右空格; function trim(s){ return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } JQuery 推荐 ☆☆☆☆☆ // 使用方法 $.trim(str) // Jquery实现方法 function trim(str){ return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,''); }</summary></entry><entry><title type="html">Function.apply and Function.call in JavaScript</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&Function.call.html" rel="alternate" type="text/html" title="Function.apply and Function.call in JavaScript" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call.html">&lt;h1 id=&quot;functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%87%BD%E6%95%B0%E6%98%AF%E5%AF%B9%E8%B1%A1&quot;&gt;函数是对象&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#call&quot;&gt;Call()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apply&quot;&gt;Apply()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E6%95%B0&quot;&gt;参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;函数是对象&quot;&gt;函数是对象&lt;/h2&gt;
&lt;p&gt;JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。&lt;/p&gt;

&lt;p&gt;您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。&lt;/p&gt;

&lt;p&gt;函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。&lt;/p&gt;

&lt;p&gt;例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;function foo()
{
    alert('x');
}
 
alert(foo.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的执行结果是(请注意，这是一个字符串)
&lt;code class=&quot;highlighter-rouge&quot;&gt;function foo()
{
    alert('x');
}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;Call()&lt;/h2&gt;
&lt;p&gt;因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。
“函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。&lt;/p&gt;

&lt;p&gt;让我们从下面的代码开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
 
function f()
{
    alert(this.x);
}
 
f();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们有一个名为f()的全局函数。f()使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;这个关键字来引用x，但是注意我们不通过对象的实例调用函数。
那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。&lt;/p&gt;

&lt;p&gt;call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。
例如，下面是我们如何使用call()方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
 
function f()
{
    alert(this.x);
}
 
f();
f.call(o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f()的第一个调用将显示10的值，因为这引用了全局对象。
但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。&lt;/p&gt;

&lt;p&gt;摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。&lt;/p&gt;

&lt;p&gt;我们还可以通过call()将参数传递给目标函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.call(o, &quot;invoking f via call&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;apply&quot;&gt;Apply()&lt;/h2&gt;
&lt;p&gt;apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.apply(o, [&quot;invoking f through apply&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f1(message1)
{
    alert(message1 + this.x);
}
 
function f2(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func, args)
{
    func.apply(object, args);
}
 
g(o, f1, [&quot;the value of x = &quot;]);
g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。&lt;/p&gt;

&lt;p&gt;在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    alert(message);
}
 
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    // message param is the same as arguments[0]    
    // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的
    for(var i = 1; i &amp;lt; arguments.length; i++)
    {
        message += arguments[i];
    }
     
    alert(message); 
}
 
// this will say &quot;Hello&quot;
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。
在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func)
{           
    // arguments[0] == object
    // arguments[1] == func
    
    var args = []; // empty array
    // copy all other arguments we want to &quot;pass through&quot; 
    for(var i = 2; i &amp;lt; arguments.length; i++)
    {
        args.push(arguments[i]);
    }
 
    func.apply(object, args);
}
 
g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><summary type="html">Function.apply and Function.call in JavaScript Function.apply and Function.call in JavaScript 函数是对象 Call() Apply() 参数 函数是对象 JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。 您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。 函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。 例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码： function foo() { alert('x'); } alert(foo.toString()); 上面的执行结果是(请注意，这是一个字符串) function foo() { alert('x'); } Call() 因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。 “函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。 让我们从下面的代码开始： var x = 10; function f() { alert(this.x); } f(); 在这里，我们有一个名为f()的全局函数。f()使用this这个关键字来引用x，但是注意我们不通过对象的实例调用函数。 那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。 call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。 例如，下面是我们如何使用call()方法: var x = 10; var o = { x: 15 }; function f() { alert(this.x); } f(); f.call(o); f()的第一个调用将显示10的值，因为这引用了全局对象。 但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。 摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。 我们还可以通过call()将参数传递给目标函数: var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.call(o, &quot;invoking f via call&quot;); Apply() apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。 var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.apply(o, [&quot;invoking f through apply&quot;]); apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。 var o = { x: 15 }; function f1(message1) { alert(message1 + this.x); } function f2(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func, args) { func.apply(object, args); } g(o, f1, [&quot;the value of x = &quot;]); g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]); 参数 上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。 在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”: function f(message) { alert(message); } f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。 function f(message) { // message param is the same as arguments[0] // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的 for(var i = 1; i &amp;lt; arguments.length; i++) { message += arguments[i]; } alert(message); } // this will say &quot;Hello&quot; f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。 在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。 var o = { x: 15 }; function f(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func) { // arguments[0] == object // arguments[1] == func var args = []; // empty array // copy all other arguments we want to &quot;pass through&quot; for(var i = 2; i &amp;lt; arguments.length; i++) { args.push(arguments[i]); } func.apply(object, args); } g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;); 当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。 原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx</summary></entry><entry><title type="html">Mybatis二级缓存</title><link href="http://localhost:4000/ProgramNote/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis二级缓存" /><published>2017-12-19T00:00:00+08:00</published><updated>2017-12-19T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/27.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。&lt;/p&gt;

&lt;p&gt;如果用户配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cacheEnabled=true&quot;&lt;/code&gt;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：&lt;code class=&quot;highlighter-rouge&quot;&gt;CachingExecutor&lt;/code&gt;，这时SqlSession使用CachingExecutor对象来完成操作请求。&lt;/p&gt;

&lt;p&gt;CachingExecutor对于查询请求，会先判断该查询请求在Application级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;二级缓存中是否有缓存结果&lt;/code&gt;，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。&lt;/p&gt;

&lt;h1 id=&quot;2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/28.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，&lt;/p&gt;

&lt;p&gt;CachingExecutor和Executor的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/29.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/h1&gt;

&lt;p&gt;Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置 为一个Mapper分配一个Cache缓存对象&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置 为多个Mapper分配相同的Cache对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/30.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID&lt;/p&gt;
&lt;h2 id=&quot;32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;如果你想让多个Mapper公用一个Cache的话，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;&lt;/code&gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/31.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/h1&gt;
&lt;p&gt;二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。&lt;/p&gt;

&lt;p&gt;虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`&lt;select&gt; `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。&lt;/select&gt;&lt;/cache&gt;&lt;/p&gt;

&lt;p&gt;如下所示，Select语句配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;useCache=&quot;true&quot;&lt;/code&gt;，则表明这条Select语句的查询会使用二级缓存。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;useCache=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开启二级缓存的条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true&lt;/li&gt;
  &lt;li&gt;该select语句所在的Mapper，配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cached-ref&amp;gt;&lt;/code&gt;节点，并且有效&lt;/li&gt;
  &lt;li&gt;该select语句的参数 useCache=true&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/h1&gt;
&lt;p&gt;二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库&lt;/p&gt;

&lt;h1 id=&quot;6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;使用MyBatis的二级缓存有三个选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis自身提供的缓存实现&lt;/p&gt;

    &lt;p&gt;MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义的Cache接口实现&lt;/p&gt;

    &lt;p&gt;MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache type=&quot;&quot;&amp;gt;&lt;/code&gt;节点的type属性上即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟第三方内存缓存库的集成&lt;/p&gt;

    &lt;p&gt;MyBatis还支持跟第三方内存缓存库如Memecached的集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/h1&gt;
&lt;p&gt;MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/32.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；&lt;/li&gt;
  &lt;li&gt;FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；&lt;/li&gt;
  &lt;li&gt;Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><summary type="html">1. Mybatis缓存机制整体设计 2. 二级缓存的基本原理 3. 二级缓存的划分 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 4. 开启二级缓存的条件 5. 缓存使用顺序 6. 二级缓存的实现方式 7. Mybatis自身提供的二级缓存实现 1. Mybatis缓存机制整体设计   当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。 如果用户配置了&quot;cacheEnabled=true&quot;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。 CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。 2. 二级缓存的基本原理 CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式， CachingExecutor和Executor的关系图 3. 二级缓存的划分 Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象 使用&amp;lt;cache&amp;gt;节点配置 为一个Mapper分配一个Cache缓存对象 使用&amp;lt;cache-ref&amp;gt;节点配置 为多个Mapper分配相同的Cache对象 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&amp;lt;cache&amp;gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象 每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 如果你想让多个Mapper公用一个Cache的话，你可以使用&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。 4. 开启二级缓存的条件 二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。 虽然在Mapper中配置了,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在` `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。 如下所示，Select语句配置了useCache=&quot;true&quot;，则表明这条Select语句的查询会使用二级缓存。 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&amp;gt; 开启二级缓存的条件 MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了&amp;lt;cache&amp;gt; 或&amp;lt;cached-ref&amp;gt;节点，并且有效 该select语句的参数 useCache=true 5. 缓存使用顺序 二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库 6. 二级缓存的实现方式 使用MyBatis的二级缓存有三个选择 MyBatis自身提供的缓存实现 MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等 用户自定义的Cache接口实现 MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&amp;lt;cache type=&quot;&quot;&amp;gt;节点的type属性上即可 跟第三方内存缓存库的集成 MyBatis还支持跟第三方内存缓存库如Memecached的集成 7. Mybatis自身提供的二级缓存实现 MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略： LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录； FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉； Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</summary></entry><entry><title type="html">装饰者模式简单理解</title><link href="http://localhost:4000/ProgramNote/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="装饰者模式简单理解" /><published>2017-12-19T00:00:00+08:00</published><updated>2017-12-19T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html">&lt;h1 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;装饰者模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%9F%BA%E6%9C%AC%E6%8F%8F%E8%BF%B0&quot;&gt;基本描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B&quot;&gt;代码实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;基本描述&quot;&gt;基本描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给对象动态地添加附加功能。&lt;/li&gt;
  &lt;li&gt;装饰者提供了一个灵活的拓展子类功能的备选方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个程序猿
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员
 */
public class Coder {

 public void coding() {
     System.out.println(&quot;我在写程序。。。&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个程序猿的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员装饰器
 */
public class CoderDecorator extends Coder {

 private Coder coder;

 public CoderDecorator(Coder coder) {
     this.coder = coder;
 }

 @Override
 public void coding() {
     coder.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个专门更换键盘的装饰器
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;写代码以前换键盘
 */
public class CoderDecoratorA extends CoderDecorator {&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;public CoderDecoratorA(Coder coder) {
     super(coder);
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public void coding() {
     this.addNewKeyBoard();
     super.coding();
 }&lt;/p&gt;

    &lt;p&gt;private void addNewKeyBoard() {
     System.out.println(“更换了新的机械键盘，噼里啪啦”);
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
4. 定义一个专门更换鼠标的装饰器
```Java

/**
 * 写代码以前换鼠标
 */
public class CoderDecoratorB extends CoderDecorator {

    public CoderDecoratorB(Coder coder) {
        super(coder);
    }

    @Override
    public void coding() {
        this.addNewMouse();
        super.coding();
    }

    private void addNewMouse() {
        System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个更换电脑的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 写代码以前换电脑
 */
public class CoderDecoratorC extends CoderDecorator {

 public CoderDecoratorC(Coder coder) {
     super(coder);
 }

 @Override
 public void coding() {
     this.changeToMacbookPro();
     super.coding();
 }

 private void changeToMacbookPro() {
     System.out.println(&quot;电脑不好使，换了，美滋滋&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;好了，现在老板可以根据不同程序猿的要求一一满足了
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序猿写代码
 */
public class Client {

 public static void main(String[] args) {
     //创造一个程序猿A，并且开始写代码
     Coder coderA = new Coder();
     //换个键盘在写
     CoderDecorator decoratorA = new CoderDecoratorA(coderA);
     //换个鼠标在写
     decoratorA = new CoderDecoratorB(decoratorA);
     //把电脑也换了
     decoratorA = new CoderDecoratorC(decoratorA);
     decoratorA.coding();

     //创造一个程序猿B，并且开始写代码
     Coder coderB = new Coder();
     //换个键盘在写
     CoderDecorator decoratorB = new CoderDecoratorA(coderB);
     //把电脑也换了
     decoratorB = new CoderDecoratorC(decoratorB);
     decoratorB.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这里满足程序猿A的要求
电脑不好使，换了，美滋滋
换了新的鼠标，哒哒哒，哒哒哒
更换了新的机械键盘，噼里啪啦
我在写程序。。。
//这里满足程序猿B的要求
电脑不好使，换了，美滋滋
更换了新的机械键盘，噼里啪啦
我在写程序。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>lipeng</name></author><summary type="html">装饰者模式 装饰者模式 基本描述 代码实例 基本描述 目的 给对象动态地添加附加功能。 装饰者提供了一个灵活的拓展子类功能的备选方案。 代码实例 公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。） 定义一个程序猿 /** * 程序员 */ public class Coder { public void coding() { System.out.println(&quot;我在写程序。。。&quot;); } } 定义一个程序猿的装饰器 /** * 程序员装饰器 */ public class CoderDecorator extends Coder { private Coder coder; public CoderDecorator(Coder coder) { this.coder = coder; } @Override public void coding() { coder.coding(); } } 定义一个专门更换键盘的装饰器 ```Java /** 写代码以前换键盘 */ public class CoderDecoratorA extends CoderDecorator { public CoderDecoratorA(Coder coder) { super(coder); } @Override public void coding() { this.addNewKeyBoard(); super.coding(); } private void addNewKeyBoard() { System.out.println(“更换了新的机械键盘，噼里啪啦”); } } 4. 定义一个专门更换鼠标的装饰器 ```Java /** * 写代码以前换鼠标 */ public class CoderDecoratorB extends CoderDecorator { public CoderDecoratorB(Coder coder) { super(coder); } @Override public void coding() { this.addNewMouse(); super.coding(); } private void addNewMouse() { System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;); } } 定义一个更换电脑的装饰器 /** * 写代码以前换电脑 */ public class CoderDecoratorC extends CoderDecorator { public CoderDecoratorC(Coder coder) { super(coder); } @Override public void coding() { this.changeToMacbookPro(); super.coding(); } private void changeToMacbookPro() { System.out.println(&quot;电脑不好使，换了，美滋滋&quot;); } } 好了，现在老板可以根据不同程序猿的要求一一满足了 /** * 程序猿写代码 */ public class Client { public static void main(String[] args) { //创造一个程序猿A，并且开始写代码 Coder coderA = new Coder(); //换个键盘在写 CoderDecorator decoratorA = new CoderDecoratorA(coderA); //换个鼠标在写 decoratorA = new CoderDecoratorB(decoratorA); //把电脑也换了 decoratorA = new CoderDecoratorC(decoratorA); decoratorA.coding(); //创造一个程序猿B，并且开始写代码 Coder coderB = new Coder(); //换个键盘在写 CoderDecorator decoratorB = new CoderDecoratorA(coderB); //把电脑也换了 decoratorB = new CoderDecoratorC(decoratorB); decoratorB.coding(); } } 执行结果 //这里满足程序猿A的要求 电脑不好使，换了，美滋滋 换了新的鼠标，哒哒哒，哒哒哒 更换了新的机械键盘，噼里啪啦 我在写程序。。。 //这里满足程序猿B的要求 电脑不好使，换了，美滋滋 更换了新的机械键盘，噼里啪啦 我在写程序。。。</summary></entry><entry><title type="html">Mybatis一级缓存</title><link href="http://localhost:4000/ProgramNote/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis一级缓存" /><published>2017-12-15T00:00:00+08:00</published><updated>2017-12-15T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8&quot;&gt;1. 一级缓存的作用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&quot;&gt;2. 一级缓存的依赖关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&quot;&gt;3. 一级缓存的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0&quot;&gt;4. 一级缓存的实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-cache%E6%8E%A5%E5%8F%A3&quot;&gt;5. Cache接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98&quot;&gt;6. 性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/h1&gt;

&lt;p&gt;每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。&lt;/p&gt;

&lt;p&gt;肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/21.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SqlSession级别的数据缓存，称为一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/h1&gt;

&lt;p&gt;一级缓存由SqlSession控制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/22.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSession&lt;/code&gt;将它的工作交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;中拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;，则对于&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;对象而言，它将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;对象维护缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/23.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PerpetualCache的实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * @author Clinton Begin
 */
public class PerpetualCache implements Cache {

  private final String id;

  private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;();

  public PerpetualCache(String id) {
    this.id = id;
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public int getSize() {
    return cache.size();
  }

  @Override
  public void putObject(Object key, Object value) {
    cache.put(key, value);
  }

  @Override
  public Object getObject(Object key) {
    return cache.get(key);
  }

  @Override
  public Object removeObject(Object key) {
    return cache.remove(key);
  }

  @Override
  public void clear() {
    cache.clear();
  }

  @Override
  public ReadWriteLock getReadWriteLock() {
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    if (this == o) {
      return true;
    }
    if (!(o instanceof Cache)) {
      return false;
    }

    Cache otherCache = (Cache) o;
    return getId().equals(otherCache.getId());
  }

  @Override
  public int hashCode() {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    return getId().hashCode();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/24.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果命中，则直接将缓存结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没命中：&lt;/p&gt;

    &lt;p&gt;4.1  去数据库中查询数据，得到查询结果；&lt;/p&gt;

    &lt;p&gt;4.2  将key和查询到的结果分别作为key,value对存储到Cache中；&lt;/p&gt;

    &lt;p&gt;4.3. 将查询结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/25.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-cache接口&quot;&gt;5. Cache接口&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/Image/mybatis/26.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。&lt;/p&gt;

&lt;p&gt;MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。&lt;/p&gt;

&lt;p&gt;Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。&lt;/p&gt;

&lt;p&gt;现在最核心的问题出现了：怎样来确定一次查询的特征值？&lt;/p&gt;

&lt;p&gt;换句话说就是：怎样判断某两次查询是完全相同的查询？&lt;/p&gt;

&lt;p&gt;也可以这样说：如何确定Cache中的key值？&lt;/p&gt;

&lt;p&gt;MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;传入的 statementId&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传递给java.sql.Statement要设置的参数值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CacheKey由以下条件决定：
&lt;strong&gt;statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CacheKey的创建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    CacheKey cacheKey = new CacheKey();
    cacheKey.update(ms.getId());//StatementId
    cacheKey.update(rowBounds.getOffset());//rowBounds.offset
    cacheKey.update(rowBounds.getLimit());//rowBounds.limit
    cacheKey.update(boundSql.getSql());//Sql
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    // mimic DefaultParameterHandler logic
    for (ParameterMapping parameterMapping : parameterMappings) {
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        String propertyName = parameterMapping.getProperty();
        if (boundSql.hasAdditionalParameter(propertyName)) {
          value = boundSql.getAdditionalParameter(propertyName);
        } else if (parameterObject == null) {
          value = null;
        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        cacheKey.update(value);
      }
    }
    if (configuration.getEnvironment() != null) {
      // issue #176
      cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-性能问题&quot;&gt;6. 性能问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;一级缓存没有维护容量和大小限制&lt;/li&gt;
  &lt;li&gt;一级缓存没有更新缓存和缓存过期的概念&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><summary type="html">1. 一级缓存的作用 2. 一级缓存的依赖关系 3. 一级缓存的生命周期 4. 一级缓存的实现 5. Cache接口 6. 性能问题 1. 一级缓存的作用 每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。 肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。 SqlSession级别的数据缓存，称为一级缓存 2. 一级缓存的依赖关系 一级缓存由SqlSession控制。 SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。 Executor接口的实现类BaseExecutor中拥有一个Cache接口的实现类PerpetualCache，则对于BaseExecutor对象而言，它将使用PerpetualCache对象维护缓存。 PerpetualCache的实现代码 /** * @author Clinton Begin */ public class PerpetualCache implements Cache { private final String id; private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;(); public PerpetualCache(String id) { this.id = id; } @Override public String getId() { return id; } @Override public int getSize() { return cache.size(); } @Override public void putObject(Object key, Object value) { cache.put(key, value); } @Override public Object getObject(Object key) { return cache.get(key); } @Override public Object removeObject(Object key) { return cache.remove(key); } @Override public void clear() { cache.clear(); } @Override public ReadWriteLock getReadWriteLock() { return null; } @Override public boolean equals(Object o) { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } if (this == o) { return true; } if (!(o instanceof Cache)) { return false; } Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); } @Override public int hashCode() { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } return getId().hashCode(); } } 3. 一级缓存的生命周期 MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 4. 一级缓存的实现 对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 4.1 去数据库中查询数据，得到查询结果； 4.2 将key和查询到的结果分别作为key,value对存储到Cache中； 4.3. 将查询结果返回； 结束。 5. Cache接口 MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。 MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ 换句话说就是：怎样判断某两次查询是完全相同的查询？ 也可以这样说：如何确定Cache中的key值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 传入的 statementId 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）； 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 传递给java.sql.Statement要设置的参数值 CacheKey由以下条件决定： statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值 CacheKey的创建 @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { if (closed) { throw new ExecutorException(&quot;Executor was closed.&quot;); } CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId());//StatementId cacheKey.update(rowBounds.getOffset());//rowBounds.offset cacheKey.update(rowBounds.getLimit());//rowBounds.limit cacheKey.update(boundSql.getSql());//Sql List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数 TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic for (ParameterMapping parameterMapping : parameterMappings) { if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } cacheKey.update(value); } } if (configuration.getEnvironment() != null) { // issue #176 cacheKey.update(configuration.getEnvironment().getId()); } return cacheKey; } 构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法. public void update(Object object) { int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); } 6. 性能问题 一级缓存没有维护容量和大小限制 一级缓存没有更新缓存和缓存过期的概念</summary></entry><entry><title type="html">DispatcherServlet探究</title><link href="http://localhost:4000/ProgramNote/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html" rel="alternate" type="text/html" title="DispatcherServlet探究" /><published>2017-12-14T00:00:00+08:00</published><updated>2017-12-14T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/spring/01.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中&lt;/p&gt;

&lt;p&gt;配置如下&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring-mvc.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 启动优先级 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;async-supported&amp;gt;&lt;/span&gt;true&lt;span class=&quot;nt&quot;&gt;&amp;lt;/async-supported&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意，DispatcherServlet可以配置多个，有自己的上下文容器。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PropertyValues初始化 ServletConfigPropertyValues是一个内部类&lt;/li&gt;
  &lt;li&gt;封装了bean的行为，提供了设置和获取属性值&lt;/li&gt;
  &lt;li&gt;加载资源文件&lt;/li&gt;
  &lt;li&gt;注册属性编辑&lt;/li&gt;
  &lt;li&gt;初始化beanWrapper&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;项目启动&lt;/p&gt;

&lt;p&gt;DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public final void init() throws ServletException {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;);
        }

        try {
            // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类
            PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);
            // 2、封装了bean的行为，提供了设置和获取属性值
            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
            // 3、加载资源文件
            ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());
            // 4、注册属性编辑
            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));
            // 5、初始化beanWrapper
            this.initBeanWrapper(bw);
            bw.setPropertyValues(pvs, true);
        } catch (BeansException var4) {
            if (this.logger.isErrorEnabled()) {
                this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4);
            }

            throw var4;
        }
        //让子类做任何他们想要的初始化。
        this.initServletBean();
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;);
        }

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PropertyValues初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    private static class ServletConfigPropertyValues extends MutablePropertyValues {
        public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException {
            Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null;
            //获取init-param中的数值对
            Enumeration paramNames = config.getInitParameterNames();

            while(paramNames.hasMoreElements()) {
                String property = (String)paramNames.nextElement();
                Object value = config.getInitParameter(property);
                this.addPropertyValue(new PropertyValue(property, value));
                if (missingProps != null) {
                    missingProps.remove(property);
                }
            }

            if (!CollectionUtils.isEmpty(missingProps)) {
                throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下图所示，获取init-param中的配置参数，写入PropertyValues
&lt;img src=&quot;/ProgramNote/assets/Image/spring/02.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BeanWrapper实现对bean行为的封装&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhiweianran/article/details/7919129&quot;&gt;待学习&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ResourceLoader加载资源文件比较简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ServletContextResourceLoader extends DefaultResourceLoader {

	private final ServletContext servletContext;


	/**
	 * Create a new ServletContextResourceLoader.
	 * @param servletContext the ServletContext to load resources with
	 */
	public ServletContextResourceLoader(ServletContext servletContext) {
		this.servletContext = servletContext;
	}

	/**
	 * This implementation supports file paths beneath the root of the web application.
	 * @see ServletContextResource
	 */
	@Override
	protected Resource getResourceByPath(String path) {
		return new ServletContextResource(this.servletContext, path);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;initServletBean的介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	/**
	 * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。
	 * &amp;lt;p&amp;gt;这个方法的默认实现是空的
	 * @throws ServletException if subclass initialization fails
	 */
	protected void initServletBean() throws ServletException {
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在&lt;strong&gt;FrameworkServlet&lt;/strong&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
	/**
	 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
	 * have been set. Creates this servlet's WebApplicationContext.
	 */
	@Override
	protected final void initServletBean() throws ServletException {
		getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;);
		if (this.logger.isInfoEnabled()) {
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
            //这里是主要的动作，创建应用程序上下文
			this.webApplicationContext = initWebApplicationContext();
			initFrameworkServlet();
		}
		catch (ServletException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}
		catch (RuntimeException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}

		if (this.logger.isInfoEnabled()) {
			long elapsedTime = System.currentTimeMillis() - startTime;
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; +
					elapsedTime + &quot; ms&quot;);
		}
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;

	/**
	 * 初始化并发布此servlet的Web应用程序上下文。
	 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation
	 * of the context. Can be overridden in subclasses.
	 * @return the WebApplicationContext instance
	 * @see #FrameworkServlet(WebApplicationContext)
	 * @see #setContextClass
	 * @see #setContextConfigLocation
	 */
	protected WebApplicationContext initWebApplicationContext() {
		WebApplicationContext rootContext =
				WebApplicationContextUtils.getWebApplicationContext(getServletContext());
		WebApplicationContext wac = null;

		if (this.webApplicationContext != null) {
            //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的  
			wac = this.webApplicationContext;
			if (wac instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
				if (!cwac.isActive()) {
					//上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务
					if (cwac.getParent() == null) {
						//在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素
						cwac.setParent(rootContext);
					}
					configureAndRefreshWebApplicationContext(cwac);
				}
			}
		}
		if (wac == null) {
			//在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了
			wac = findWebApplicationContext();
		}
		if (wac == null) {
			//没有的话就定义一个
			wac = createWebApplicationContext(rootContext);
		}

		if (!this.refreshEventReceived) {
			// 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息  
			onRefresh(wac);
		}

		if (this.publishContext) {
			// 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中  
			String attrName = getServletContextAttributeName();
			getServletContext().setAttribute(attrName, wac);
			if (this.logger.isDebugEnabled()) {
				this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() +
						&quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
			}
		}

		return wac;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文地址：
http://blog.csdn.net/congcong68/article/details/40451233&lt;/p&gt;

&lt;p&gt;需要学的
http://blog.csdn.net/congcong68/article/details/40650143&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><category term="SpringMVC" /><summary type="html">DispatcherServlet是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。 当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中 配置如下 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 启动优先级 --&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;async-supported&amp;gt;true&amp;lt;/async-supported&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 请注意，DispatcherServlet可以配置多个，有自己的上下文容器。 PropertyValues初始化 ServletConfigPropertyValues是一个内部类 封装了bean的行为，提供了设置和获取属性值 加载资源文件 注册属性编辑 初始化beanWrapper 项目启动 DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法 public final void init() throws ServletException { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;); } try { // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类 PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties); // 2、封装了bean的行为，提供了设置和获取属性值 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); // 3、加载资源文件 ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext()); // 4、注册属性编辑 bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment())); // 5、初始化beanWrapper this.initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException var4) { if (this.logger.isErrorEnabled()) { this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4); } throw var4; } //让子类做任何他们想要的初始化。 this.initServletBean(); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;); } } PropertyValues初始化 private static class ServletConfigPropertyValues extends MutablePropertyValues { public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException { Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null; //获取init-param中的数值对 Enumeration paramNames = config.getInitParameterNames(); while(paramNames.hasMoreElements()) { String property = (String)paramNames.nextElement(); Object value = config.getInitParameter(property); this.addPropertyValue(new PropertyValue(property, value)); if (missingProps != null) { missingProps.remove(property); } } if (!CollectionUtils.isEmpty(missingProps)) { throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;)); } } } 如下图所示，获取init-param中的配置参数，写入PropertyValues BeanWrapper实现对bean行为的封装 待学习 ResourceLoader加载资源文件比较简单 public class ServletContextResourceLoader extends DefaultResourceLoader { private final ServletContext servletContext; /** * Create a new ServletContextResourceLoader. * @param servletContext the ServletContext to load resources with */ public ServletContextResourceLoader(ServletContext servletContext) { this.servletContext = servletContext; } /** * This implementation supports file paths beneath the root of the web application. * @see ServletContextResource */ @Override protected Resource getResourceByPath(String path) { return new ServletContextResource(this.servletContext, path); } } initServletBean的介绍 /** * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。 * &amp;lt;p&amp;gt;这个方法的默认实现是空的 * @throws ServletException if subclass initialization fails */ protected void initServletBean() throws ServletException { } 上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在FrameworkServlet中 /** * Overridden method of {@link HttpServletBean}, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */ @Override protected final void initServletBean() throws ServletException { getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;); if (this.logger.isInfoEnabled()) { this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;); } long startTime = System.currentTimeMillis(); try { //这里是主要的动作，创建应用程序上下文 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } catch (RuntimeException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; + elapsedTime + &quot; ms&quot;); } } /** * 初始化并发布此servlet的Web应用程序上下文。 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation * of the context. Can be overridden in subclasses. * @return the WebApplicationContext instance * @see #FrameworkServlet(WebApplicationContext) * @see #setContextClass * @see #setContextConfigLocation */ protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的 wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { //上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务 if (cwac.getParent() == null) { //在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素 cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { //在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了 wac = findWebApplicationContext(); } if (wac == null) { //没有的话就定义一个 wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息 onRefresh(wac); } if (this.publishContext) { // 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() + &quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;); } } return wac; } 本文地址： http://blog.csdn.net/congcong68/article/details/40451233 需要学的 http://blog.csdn.net/congcong68/article/details/40650143</summary></entry><entry><title type="html">component-scan总结</title><link href="http://localhost:4000/ProgramNote/2017/12/13/component-scan%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="component-scan总结" /><published>2017-12-13T00:00:00+08:00</published><updated>2017-12-13T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/13/component-scan%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/13/component-scan%E6%80%BB%E7%BB%93.html">&lt;p&gt;今天偶然看到了原有的一个项目中有这样的配置信息&lt;/p&gt;

&lt;p&gt;配置文件&lt;strong&gt;spring-config.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 扫描注解Bean --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:exclude-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置文件&lt;strong&gt;spring-mvc.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 开启controller注解支持 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb.platform.controller&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;use-default-filters=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在&lt;strong&gt;spring-config.xml&lt;/strong&gt;中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。&lt;/p&gt;

&lt;p&gt;第二个问题是&lt;code class=&quot;highlighter-rouge&quot;&gt;use-default-filters=&quot;false&quot;&lt;/code&gt;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。&lt;/p&gt;

&lt;h1 id=&quot;component-scan的分析&quot;&gt;component-scan的分析&lt;/h1&gt;

&lt;h2 id=&quot;注册解析器&quot;&gt;注册解析器&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;component-scan&lt;/code&gt;交由&lt;code class=&quot;highlighter-rouge&quot;&gt;org.springframework.context.config.ContextNamespaceHandler&lt;/code&gt;处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ContextNamespaceHandler extends NamespaceHandlerSupport {
    public ContextNamespaceHandler() {
    }

    public void init() {
        this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());
        //这里注册处理的解析器
        this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;componentscanbeandefinitionparser组装classpathbeandefinitionscanner&quot;&gt;ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        //获取basePackage
        String basePackage = element.getAttribute(&quot;base-package&quot;);
        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
        //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式
        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;);
        //组装ClassPathBeanDefinitionScanner
        ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element);
        //扫描===========
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages);
        //注册bean
        this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //组装ClassPathBeanDefinitionScanner
    protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {
        //默认情况下  use-default-filters属性为true
        boolean useDefaultFilters = true;
        if (element.hasAttribute(&quot;use-default-filters&quot;)) {
            useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;));
        }
        //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner
        ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters);
        scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());
        scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());
        if (element.hasAttribute(&quot;resource-pattern&quot;)) {
            scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;));
        }

        try {
            this.parseBeanNameGenerator(element, scanner);
        } catch (Exception var7) {
            parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause());
        }

        try {
            this.parseScope(element, scanner);
        } catch (Exception var6) {
            parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause());
        }

        this.parseTypeFilters(element, scanner, parserContext);
        return scanner;
    }

    protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {
        return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //ClassPathBeanDefinitionScanner构造器
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) {
        this.beanDefinitionDefaults = new BeanDefinitionDefaults();
        this.beanNameGenerator = new AnnotationBeanNameGenerator();
        this.scopeMetadataResolver = new AnnotationScopeMetadataResolver();
        this.includeAnnotationConfig = true;
        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
        this.registry = registry;
        if (useDefaultFilters) {
            //这里注册过滤器，就是那些bean被扫描注册
            this.registerDefaultFilters();
        }

        this.setEnvironment(environment);
        this.setResourceLoader(resourceLoader);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //注册过滤器
    // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。
    protected void registerDefaultFilters() {
        this.includeFilters.add(new AnnotationTypeFilter(Component.class));
        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false));
            this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var4) {
            ;
        }

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false));
            this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var3) {
            ;
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次回到&lt;code class=&quot;highlighter-rouge&quot;&gt;//扫描===========&lt;/code&gt;这个地方，继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet();
        String[] var3 = basePackages;
        int var4 = basePackages.length;

        for(int var5 = 0; var5 &amp;lt; var4; ++var5) {
            String basePackage = var3[var5];
            //这里判定是否符合条件
            Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage);
            Iterator var8 = candidates.iterator();

            while(var8.hasNext()) {
                BeanDefinition candidate = (BeanDefinition)var8.next();
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                if (candidate instanceof AbstractBeanDefinition) {
                    this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
                }

                if (candidate instanceof AnnotatedBeanDefinition) {
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
                }

                if (this.checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    this.registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }

        return beanDefinitions;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定符合条件的地方继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
        LinkedHashSet candidates = new LinkedHashSet();

        try {
            String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
            boolean traceEnabled = this.logger.isTraceEnabled();
            boolean debugEnabled = this.logger.isDebugEnabled();
            Resource[] var7 = resources;
            int var8 = resources.length;

            for(int var9 = 0; var9 &amp;lt; var8; ++var9) {
                Resource resource = var7[var9];
                if (traceEnabled) {
                    this.logger.trace(&quot;Scanning &quot; + resource);
                }

                if (resource.isReadable()) {
                    try {
                        MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                        //这里判定是否符合排除或者包含的component条件
                        if (this.isCandidateComponent(metadataReader)) {
                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                            sbd.setResource(resource);
                            sbd.setSource(resource);
                            if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) {
                                if (debugEnabled) {
                                    this.logger.debug(&quot;Identified candidate component class: &quot; + resource);
                                }

                                candidates.add(sbd);
                            } else if (debugEnabled) {
                                this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                            }
                        } else if (traceEnabled) {
                            this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                        }
                    } catch (Throwable var13) {
                        throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13);
                    }
                } else if (traceEnabled) {
                    this.logger.trace(&quot;Ignored because not readable: &quot; + resource);
                }
            }

            return candidates;
        } catch (IOException var14) {
            throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定是否符合component的地方继续&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
        Iterator var2 = this.excludeFilters.iterator();

        TypeFilter tf;
        do {
            //先判断 exclude-filter,黑名单过滤
            if (!var2.hasNext()) {
                var2 = this.includeFilters.iterator();

                do {
                    //然后判断 include-filter,白名单过滤
                    // 其他情况排除
                    if (!var2.hasNext()) {
                        return false;
                    }

                    tf = (TypeFilter)var2.next();
                } while(!tf.match(metadataReader, this.metadataReaderFactory));

                return this.isConditionMatch(metadataReader);
            }

            tf = (TypeFilter)var2.next();
        } while(!tf.match(metadataReader, this.metadataReaderFactory));

        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter&lt;/li&gt;
  &lt;li&gt;use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描&lt;/li&gt;
  &lt;li&gt;controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Spring" /><category term="SpringMVC" /><summary type="html">今天偶然看到了原有的一个项目中有这样的配置信息 配置文件spring-config.xml &amp;lt;!-- 扫描注解Bean --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&amp;gt; &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 配置文件spring-mvc.xml &amp;lt;!-- 开启controller注解支持 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb.platform.controller&quot; use-default-filters=&quot;false&quot;&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在spring-config.xml中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。 第二个问题是use-default-filters=&quot;false&quot;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。 component-scan的分析 注册解析器 component-scan交由org.springframework.context.config.ContextNamespaceHandler处理 public class ContextNamespaceHandler extends NamespaceHandlerSupport { public ContextNamespaceHandler() { } public void init() { this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); //这里注册处理的解析器 this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } } ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner public BeanDefinition parse(Element element, ParserContext parserContext) { //获取basePackage String basePackage = element.getAttribute(&quot;base-package&quot;); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;); //组装ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element); //扫描=========== Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages); //注册bean this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } //组装ClassPathBeanDefinitionScanner protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { //默认情况下 use-default-filters属性为true boolean useDefaultFilters = true; if (element.hasAttribute(&quot;use-default-filters&quot;)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;)); } //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(&quot;resource-pattern&quot;)) { scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;)); } try { this.parseBeanNameGenerator(element, scanner); } catch (Exception var7) { parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause()); } try { this.parseScope(element, scanner); } catch (Exception var6) { parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause()); } this.parseTypeFilters(element, scanner, parserContext); return scanner; } protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) { return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader()); } //ClassPathBeanDefinitionScanner构造器 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) { this.beanDefinitionDefaults = new BeanDefinitionDefaults(); this.beanNameGenerator = new AnnotationBeanNameGenerator(); this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); this.includeAnnotationConfig = true; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) { //这里注册过滤器，就是那些bean被扫描注册 this.registerDefaultFilters(); } this.setEnvironment(environment); this.setResourceLoader(resourceLoader); } //注册过滤器 // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。 protected void registerDefaultFilters() { this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false)); this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;); } catch (ClassNotFoundException var4) { ; } try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false)); this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;); } catch (ClassNotFoundException var3) { ; } } 我们再次回到//扫描===========这个地方，继续往下走 protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &amp;lt; var4; ++var5) { String basePackage = var3[var5]; //这里判定是否符合条件 Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if (this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 从判定符合条件的地方继续往下走 public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) { LinkedHashSet candidates = new LinkedHashSet(); try { String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = this.logger.isTraceEnabled(); boolean debugEnabled = this.logger.isDebugEnabled(); Resource[] var7 = resources; int var8 = resources.length; for(int var9 = 0; var9 &amp;lt; var8; ++var9) { Resource resource = var7[var9]; if (traceEnabled) { this.logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //这里判定是否符合排除或者包含的component条件 if (this.isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if (debugEnabled) { this.logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else if (debugEnabled) { this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not readable: &quot; + resource); } } return candidates; } catch (IOException var14) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14); } } 从判定是否符合component的地方继续 protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { Iterator var2 = this.excludeFilters.iterator(); TypeFilter tf; do { //先判断 exclude-filter,黑名单过滤 if (!var2.hasNext()) { var2 = this.includeFilters.iterator(); do { //然后判断 include-filter,白名单过滤 // 其他情况排除 if (!var2.hasNext()) { return false; } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return this.isConditionMatch(metadataReader); } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return false; } 结论 include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描 controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）</summary></entry><entry><title type="html">Mybatis构架设计</title><link href="http://localhost:4000/ProgramNote/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1.html" rel="alternate" type="text/html" title="Mybatis构架设计" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1&quot;&gt;1. Mybatis框架设计&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-%E6%8E%A5%E5%8F%A3%E5%B1%82--%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F&quot;&gt;1.1. 接口层–和数据库交互的方式&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#111-%E4%BD%BF%E7%94%A8mybatis%E6%8F%90%E4%BE%9B%E7%9A%84api&quot;&gt;1.1.1. 使用Mybatis提供的API&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#112-%E4%BD%BF%E7%94%A8mapper%E6%8E%A5%E5%8F%A3&quot;&gt;1.1.2. 使用Mapper接口&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#12-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B1%82&quot;&gt;1.2. 数据处理层&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#121-%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81sql%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90&quot;&gt;1.2.1. 参数映射和动态SQL语句生成&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;[1.2.2. SQL语句的执行以及封装查询结果集成List&lt;E&gt;](#122-sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E6%88%90liste)&lt;/E&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#13-%E6%A1%86%E6%9E%B6%E6%94%AF%E6%92%91%E5%B1%82&quot;&gt;1.3. 框架支撑层&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#131-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6&quot;&gt;1.3.1. 事务管理机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#132-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6&quot;&gt;1.3.2. 连接池管理机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#133-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6&quot;&gt;1.3.3. 缓存机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#134-sql%E8%AF%AD%E5%8F%A5%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F&quot;&gt;1.3.4. SQL语句配置方式&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#135-%E5%BC%95%E5%AF%BC%E5%B1%82&quot;&gt;1.3.5. 引导层&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-mybatis%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6%E4%B8%80%E8%B5%B7%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB&quot;&gt;2. Mybatis主要构件一起相互关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90&quot;&gt;3. 实例分析&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87&quot;&gt;3.1. 数据准备&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#311-%E6%95%B0%E6%8D%AE%E5%BA%93&quot;&gt;3.1.1. 数据库&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#312-mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-mybatisconfigxml&quot;&gt;3.1.2. Mybatis配置文件 mybatisConfig.xml&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#313-%E5%88%9B%E5%BB%BAemployee%E5%AE%9E%E4%BD%93bean-%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AEmapper%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#314-%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81&quot;&gt;3.1.4. 演示代码&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-sqlsession%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B%E5%88%86%E6%9E%90&quot;&gt;3.2. SqlSession工作工程分析&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#321-%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E4%BC%9A%E8%AF%9D--%E5%88%9B%E5%BB%BAsqlsession%E5%AF%B9%E8%B1%A1&quot;&gt;3.2.1. 开启一个数据库访问会话–创建SqlSession对象&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#322-%E4%B8%BAsqlsession%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%9A%84sql%E8%AF%AD%E5%8F%A5statementid%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C&quot;&gt;3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#323-mybatis%E6%89%A7%E8%A1%8C%E5%99%A8executor%E6%A0%B9%E6%8D%AEsqlsession%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E6%89%A7%E8%A1%8Cquery%E6%96%B9%E6%B3%95&quot;&gt;3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#324-statementhandler%E5%AF%B9%E8%B1%A1%E8%B4%9F%E8%B4%A3%E8%AE%BE%E7%BD%AEstatement%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E3%80%81%E5%A4%84%E7%90%86jdbc%E8%BF%94%E5%9B%9E%E7%9A%84resultset%EF%BC%8C%E5%B0%86resultset%E5%8A%A0%E5%B7%A5%E4%B8%BAlist-%E9%9B%86%E5%90%88%E8%BF%94%E5%9B%9E&quot;&gt;3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#325-statementhandler-%E7%9A%84parameterizestatement-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0&quot;&gt;3.2.5. StatementHandler 的parameterize(statement) 方法的实现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;[3.2.6. StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现](#326-statementhandler-%E7%9A%84liste-querystatement-statement-resulthandler-resulthandler%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0)&lt;/E&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis框架设计&quot;&gt;1. Mybatis框架设计&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/Image/mybatis/16.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-接口层和数据库交互的方式&quot;&gt;1.1. 接口层–和数据库交互的方式&lt;/h2&gt;
&lt;p&gt;Mybatis和数据库交互有两种方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用Mybatis提供的API&lt;/li&gt;
  &lt;li&gt;使用Mapper接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;111-使用mybatis提供的api&quot;&gt;1.1.1. 使用Mybatis提供的API&lt;/h3&gt;

&lt;p&gt;这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；&lt;/p&gt;

&lt;p&gt;MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/17.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。&lt;/p&gt;

&lt;h3 id=&quot;112-使用mapper接口&quot;&gt;1.1.2. 使用Mapper接口&lt;/h3&gt;

&lt;p&gt;MyBatis 将配置文件中的每一个&lt;mapper&gt; 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟&lt;mapper&gt; 节点中的&amp;lt;select|update|delete|insert&amp;gt; 节点项对应，即&amp;lt;select|update|delete|insert&amp;gt; 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。&lt;/mapper&gt;&lt;/mapper&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/18.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作.&lt;/p&gt;

&lt;p&gt;MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。&lt;/p&gt;

&lt;h2 id=&quot;12-数据处理层&quot;&gt;1.2. 数据处理层&lt;/h2&gt;
&lt;p&gt;数据处理层是Mybatis的核心，主要完成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过传入参数构建动态SQL语句&lt;/li&gt;
  &lt;li&gt;SQL语句的执行&lt;/li&gt;
  &lt;li&gt;封装查询结果集成List&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;121-参数映射和动态sql语句生成&quot;&gt;1.2.1. 参数映射和动态SQL语句生成&lt;/h3&gt;
&lt;p&gt;Mybatis通过传入参数值使用OGNL动态构造SQL语句。&lt;/p&gt;

&lt;p&gt;参数映射是指java数据类型和jdbc数据类型之间的转换，这里包含两个过程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查询阶段，要将java类型的数据转换成jdbc类型的数据，通过preparedStatement.setXXX() 来设值；&lt;/li&gt;
  &lt;li&gt;另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;122-sql语句的执行以及封装查询结果集成list&quot;&gt;1.2.2. SQL语句的执行以及封装查询结果集成List&lt;E&gt;&lt;/E&gt;&lt;/h3&gt;
&lt;p&gt;动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List&lt;E&gt; 列表。&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。&lt;/p&gt;

&lt;h2 id=&quot;13-框架支撑层&quot;&gt;1.3. 框架支撑层&lt;/h2&gt;
&lt;h3 id=&quot;131-事务管理机制&quot;&gt;1.3.1. 事务管理机制&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/05-Mybatis/04-Mybatis事务管理.md&quot;&gt;Mybatis事务&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;132-连接池管理机制&quot;&gt;1.3.2. 连接池管理机制&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/05-Mybatis/03-Mybatis数据源和连接池&quot;&gt;Mybatis数据源和连接池&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;133-缓存机制&quot;&gt;1.3.3. 缓存机制&lt;/h3&gt;
&lt;p&gt;为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。&lt;/p&gt;

&lt;h3 id=&quot;134-sql语句配置方式&quot;&gt;1.3.4. SQL语句配置方式&lt;/h3&gt;

&lt;p&gt;传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。&lt;/p&gt;

&lt;h3 id=&quot;135-引导层&quot;&gt;1.3.5. 引导层&lt;/h3&gt;
&lt;p&gt;引导层是配置和启动MyBatis 配置信息的方式。&lt;/p&gt;

&lt;p&gt;MyBatis 提供两种方式来引导MyBatis&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于XML配置文件的方式&lt;/li&gt;
  &lt;li&gt;基于Java API 的方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luanlouis/article/details/35570809&quot;&gt;Java Persistence with MyBatis 3(中文版) 第二章 引导MyBatis&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-mybatis主要构件一起相互关系&quot;&gt;2. Mybatis主要构件一起相互关系&lt;/h1&gt;

&lt;p&gt;Mybatis主要的核心部件（非全部）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SqlSession
    &lt;ul&gt;
      &lt;li&gt;作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Executor
    &lt;ul&gt;
      &lt;li&gt;MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StatementHandler
    &lt;ul&gt;
      &lt;li&gt;封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ParameterHandler
    &lt;ul&gt;
      &lt;li&gt;负责对用户传递的参数转换成JDBC Statement 所需要的参数，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ResultSetHandler
    &lt;ul&gt;
      &lt;li&gt;负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TypeHandler
    &lt;ul&gt;
      &lt;li&gt;负责java数据类型和jdbc数据类型之间的映射和转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MappedStatement
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;MappedStatement维护了一条&amp;lt;select&lt;/td&gt;
              &lt;td&gt;update&lt;/td&gt;
              &lt;td&gt;delete&lt;/td&gt;
              &lt;td&gt;insert&amp;gt;节点的封装，&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SqlSource
    &lt;ul&gt;
      &lt;li&gt;负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BoundSql
    &lt;ul&gt;
      &lt;li&gt;表示动态生成的SQL语句以及相应的参数信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Configuration
    &lt;ul&gt;
      &lt;li&gt;MyBatis所有的配置信息都维持在Configuration对象之中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/19.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-实例分析&quot;&gt;3. 实例分析&lt;/h1&gt;
&lt;h2 id=&quot;31-数据准备&quot;&gt;3.1. 数据准备&lt;/h2&gt;

&lt;h3 id=&quot;311-数据库&quot;&gt;3.1.1. 数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;   
   --创建一个员工基本信息表
    create  table &quot;EMPLOYEES&quot;(
        &quot;EMPLOYEE_ID&quot; NUMBER(6) not null,
       &quot;FIRST_NAME&quot; VARCHAR2(20),
       &quot;LAST_NAME&quot; VARCHAR2(25) not null,
       &quot;EMAIL&quot; VARCHAR2(25) not null unique,
       &quot;SALARY&quot; NUMBER(8,2),
        constraint &quot;EMP_EMP_ID_PK&quot; primary key (&quot;EMPLOYEE_ID&quot;)
    );
    comment on table EMPLOYEES is '员工信息表';
    comment on column EMPLOYEES.EMPLOYEE_ID is '员工id';
    comment on column EMPLOYEES.FIRST_NAME is 'first name';
    comment on column EMPLOYEES.LAST_NAME is 'last name';
    comment on column EMPLOYEES.EMAIL is 'email address';
    comment on column EMPLOYEES.SALARY is 'salary';
    
    --添加数据
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (100, 'Steven', 'King', 'SKING', 24000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (101, 'Neena', 'Kochhar', 'NKOCHHAR', 17000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (102, 'Lex', 'De Haan', 'LDEHAAN', 17000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (103, 'Alexander', 'Hunold', 'AHUNOLD', 9000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (104, 'Bruce', 'Ernst', 'BERNST', 6000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (105, 'David', 'Austin', 'DAUSTIN', 4800.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (106, 'Valli', 'Pataballa', 'VPATABAL', 4800.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (107, 'Diana', 'Lorentz', 'DLORENTZ', 4200.00);    

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;312-mybatis配置文件-mybatisconfigxml&quot;&gt;3.1.2. Mybatis配置文件 mybatisConfig.xml&lt;/h3&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	 &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;oracle.jdbc.driver.OracleDriver&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;louis&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123456&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com/louis/mybatis/domain/EmployeesMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;313-创建employee实体bean-以及配置mapper配置文件&quot;&gt;3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.louis.mybatis.model;

import java.math.BigDecimal;

public class Employee {
    private Integer employeeId;

    private String firstName;

    private String lastName;

    private String email;

    private BigDecimal salary;

    public Integer getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(Integer employeeId) {
        this.employeeId = employeeId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;com.louis.mybatis.dao.EmployeesMapper&quot; &amp;gt;

  &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.louis.mybatis.model.Employee&quot; &amp;gt;
    &amp;lt;id column=&quot;EMPLOYEE_ID&quot; property=&quot;employeeId&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt;
    &amp;lt;result column=&quot;FIRST_NAME&quot; property=&quot;firstName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;LAST_NAME&quot; property=&quot;lastName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;EMAIL&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;SALARY&quot; property=&quot;salary&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  
  &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &amp;gt;
    select 
    	EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY
    	from LOUIS.EMPLOYEES
    	where EMPLOYEE_ID = #{employeeId,jdbcType=DECIMAL}
  &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MAVEN依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;  
    &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;3.2.7&amp;lt;/version&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
      
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt;  
        &amp;lt;version&amp;gt;10.2.0.4.0&amp;lt;/version&amp;gt;  
    &amp;lt;/dependency&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;314-演示代码&quot;&gt;3.1.4. 演示代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.louis.mybatis.test;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.louis.mybatis.model.Employee;

/**
 * SqlSession 简单查询演示类
 * @author louluan
 */
public class SelectDemo {

	public static void main(String[] args) throws Exception {
		/*
		 * 1.加载mybatis的配置文件，初始化mybatis，创建出SqlSessionFactory，是创建SqlSession的工厂
		 * 这里只是为了演示的需要，SqlSessionFactory临时创建出来，在实际的使用中，SqlSessionFactory只需要创建一次，当作单例来使用
		 */
		InputStream inputStream = Resources.getResourceAsStream(&quot;mybatisConfig.xml&quot;);
		SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
		SqlSessionFactory factory = builder.build(inputStream);
		
		//2. 从SqlSession工厂 SqlSessionFactory中创建一个SqlSession，进行数据库操作
		SqlSession sqlSession = factory.openSession();
	
		//3.使用SqlSession查询
		Map&amp;lt;String,Object&amp;gt; params = new HashMap&amp;lt;String,Object&amp;gt;();
		
		params.put(&quot;min_salary&quot;,10000);
		//a.查询工资低于10000的员工
		List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);
		//b.未传最低工资，查所有员工
		List&amp;lt;Employee&amp;gt; result1 = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;);
		System.out.println(&quot;薪资低于10000的员工数：&quot;+result.size());
		//~output :   查询到的数据总数：5  
		System.out.println(&quot;所有员工数: &quot;+result1.size());
		//~output :  所有员工数: 8
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;32-sqlsession工作工程分析&quot;&gt;3.2. SqlSession工作工程分析&lt;/h2&gt;
&lt;h3 id=&quot;321-开启一个数据库访问会话创建sqlsession对象&quot;&gt;3.2.1. 开启一个数据库访问会话–创建SqlSession对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;SqlSession sqlSession = factory.openSession();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mybatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/20.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;322-为sqlsession传递一个配置的sql语句statementid和参数然后返回结果&quot;&gt;3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&lt;/strong&gt;是配置在xml中的statementId， params是传递的查询参数。&lt;/p&gt;

&lt;p&gt;selectList的默认实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //1、根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement   
      MappedStatement ms = configuration.getMappedStatement(statement);
      //2、将查询任务委托给Mybatis的执行器Execute
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，使用org.apache.ibatis.session.Configuration实例来维护。使用者可以使用sqlSession.getConfiguration()方法来获取。MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的。上述例子中的&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    select 
    	EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY
    	from LOUIS.EMPLOYEES
    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;if&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;test=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;min_salary != null&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    		where SALARY &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt; #{min_salary,jdbcType=DECIMAL}
    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/if&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;会加载到内存中生成一个对应的MappedStatement对象，然后以 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; = MappedStatement对象的形式维护到Configuration的一个Map中。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作。&lt;/p&gt;

&lt;h3 id=&quot;323-mybatis执行器executor根据sqlsession传递的参数执行query方法&quot;&gt;3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
* BaseExecutor 类部分代码
*
*/
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
	// 1.根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示  
    BoundSql boundSql = ms.getBoundSql(parameter);
    // 2.为当前的查询创建一个缓存Key
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }

  @SuppressWarnings(&quot;unchecked&quot;)
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
    	// 3.缓存中没有值，直接从数据库中读取数据  
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      deferredLoads.clear(); // issue #601
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache(); // issue #482
      }
    }
    return list;
  }
 private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
    	
      //4. 执行查询，返回List 结果，然后	将查询的结果放入缓存之中
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*
*SimpleExecutor类的doQuery()方法实现
*
*/
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      //5. 根据既有的参数，创建StatementHandler对象来执行查询操作
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //6. 创建java.Sql.Statement对象，传递给StatementHandler对象
      stmt = prepareStatement(handler, ms.getStatementLog());
      //7. 调用StatementHandler.query()方法，返回List结果集
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor.query()&lt;/code&gt;方法几经转折，最后会创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;对象，然后将必要的参数传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;来完成对数据库的查询，最终返回List结果集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用；&lt;/li&gt;
  &lt;li&gt;为查询创建缓存，以提高性能&lt;/li&gt;
  &lt;li&gt;创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;324-statementhandler对象负责设置statement对象中的查询参数处理jdbc返回的resultset将resultset加工为list-集合返回&quot;&gt;3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回&lt;/h3&gt;
&lt;p&gt;看一下：prepareStatement() 方法的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*
*SimpleExecutor类的doQuery()方法实现
*
*/
    public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { 
        Statement stmt = null; 
        try { 
            Configuration configuration = ms.getConfiguration(); 
            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); 
            // 1.准备Statement对象，并设置Statement对象的参数 
            stmt = prepareStatement(handler, ms.getStatementLog()); 
            // 2. StatementHandler执行query()方法，返回List结果 
            return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); 
        } 
        finally 
        { 
            closeStatement(stmt); 
        } 
    }

  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    Connection connection = getConnection(statementLog);
    stmt = handler.prepare(connection);
    //对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数
    handler.parameterize(stmt);
    return stmt;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。
StatementHandler通过parameterize(statement)方法对Statement进行设值；&lt;/li&gt;
  &lt;li&gt;StatementHandler通过List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List；&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;325-statementhandler-的parameterizestatement-方法的实现&quot;&gt;3.2.5. StatementHandler 的parameterize(statement) 方法的实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*   StatementHandler 类的parameterize(statement) 方法实现 
*/
public void parameterize(Statement statement) throws SQLException {
	//使用ParameterHandler对象来完成对Statement的设值  
    parameterHandler.setParameters((PreparedStatement) statement);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
   * 
   *ParameterHandler类的setParameters(PreparedStatement ps) 实现
   * 对某一个Statement进行设置参数
   */
  public void setParameters(PreparedStatement ps) throws SQLException {
    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();
    if (parameterMappings != null) {
      for (int i = 0; i &amp;lt; parameterMappings.size(); i++) {
        ParameterMapping parameterMapping = parameterMappings.get(i);
        if (parameterMapping.getMode() != ParameterMode.OUT) {
          Object value;
          String propertyName = parameterMapping.getProperty();
          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params
            value = boundSql.getAdditionalParameter(propertyName);
          } else if (parameterObject == null) {
            value = null;
          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
            value = parameterObject;
          } else {
            MetaObject metaObject = configuration.newMetaObject(parameterObject);
            value = metaObject.getValue(propertyName);
          }
          
          // 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数
          TypeHandler typeHandler = parameterMapping.getTypeHandler();
          JdbcType jdbcType = parameterMapping.getJdbcType();
          if (value == null &amp;amp;&amp;amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();
          // 设置参数
          typeHandler.setParameter(ps, i + 1, value, jdbcType);
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;StatementHandler 的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法&lt;/li&gt;
  &lt;li&gt;ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;326-statementhandler-的list-querystatement-statement-resulthandler-resulthandler方法的实现&quot;&gt;3.2.6. StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现&lt;/E&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
   * PreParedStatement类的query方法实现
   */
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
	// 1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理  
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    //2. 使用ResultHandler来处理ResultSet
    return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**  
*ResultSetHandler类的handleResultSets()方法实现
*
*/
public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
    final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;();

    int resultSetCount = 0;
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    
    while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      
      //将resultSet
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResulSets();
    if (resultSets != null) {
      while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List&lt;E&gt; 结果集&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  //
  // DefaultResultSetHandler 类的handleResultSets(Statement stmt)实现 
  //HANDLE RESULT SETS
  //

  public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
    final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;();

    int resultSetCount = 0;
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    
    while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      
      //将resultSet
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResulSets();
    if (resultSets != null) {
      while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><summary type="html">1. Mybatis框架设计 1.1. 接口层–和数据库交互的方式 1.1.1. 使用Mybatis提供的API 1.1.2. 使用Mapper接口 1.2. 数据处理层 1.2.1. 参数映射和动态SQL语句生成 [1.2.2. SQL语句的执行以及封装查询结果集成List](#122-sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E6%88%90liste) 1.3. 框架支撑层 1.3.1. 事务管理机制 1.3.2. 连接池管理机制 1.3.3. 缓存机制 1.3.4. SQL语句配置方式 1.3.5. 引导层 2. Mybatis主要构件一起相互关系 3. 实例分析 3.1. 数据准备 3.1.1. 数据库 3.1.2. Mybatis配置文件 mybatisConfig.xml 3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件 3.1.4. 演示代码 3.2. SqlSession工作工程分析 3.2.1. 开启一个数据库访问会话–创建SqlSession对象 3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果 3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法 3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回 3.2.5. StatementHandler 的parameterize(statement) 方法的实现 [3.2.6. StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现](#326-statementhandler-%E7%9A%84liste-querystatement-statement-resulthandler-resulthandler%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0) 1. Mybatis框架设计 1.1. 接口层–和数据库交互的方式 Mybatis和数据库交互有两种方式 使用Mybatis提供的API 使用Mapper接口 1.1.1. 使用Mybatis提供的API 这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互； MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。 创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。 1.1.2. 使用Mapper接口 MyBatis 将配置文件中的每一个 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟 节点中的&amp;lt;select|update|delete|insert&amp;gt; 节点项对应，即&amp;lt;select|update|delete|insert&amp;gt; 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。 根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作. MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。 1.2. 数据处理层 数据处理层是Mybatis的核心，主要完成 通过传入参数构建动态SQL语句 SQL语句的执行 封装查询结果集成List 1.2.1. 参数映射和动态SQL语句生成 Mybatis通过传入参数值使用OGNL动态构造SQL语句。 参数映射是指java数据类型和jdbc数据类型之间的转换，这里包含两个过程 查询阶段，要将java类型的数据转换成jdbc类型的数据，通过preparedStatement.setXXX() 来设值； 另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。 1.2.2. SQL语句的执行以及封装查询结果集成List 动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List 列表。 MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。 1.3. 框架支撑层 1.3.1. 事务管理机制 Mybatis事务 1.3.2. 连接池管理机制 Mybatis数据源和连接池 1.3.3. 缓存机制 为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。 1.3.4. SQL语句配置方式 传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。 1.3.5. 引导层 引导层是配置和启动MyBatis 配置信息的方式。 MyBatis 提供两种方式来引导MyBatis 基于XML配置文件的方式 基于Java API 的方式 Java Persistence with MyBatis 3(中文版) 第二章 引导MyBatis 2. Mybatis主要构件一起相互关系 Mybatis主要的核心部件（非全部） SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能 Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所需要的参数， ResultSetHandler 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合； TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换 MappedStatement MappedStatement维护了一条&amp;lt;select update delete insert&amp;gt;节点的封装， SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回 BoundSql 表示动态生成的SQL语句以及相应的参数信息 Configuration MyBatis所有的配置信息都维持在Configuration对象之中。 3. 实例分析 3.1. 数据准备 3.1.1. 数据库 --创建一个员工基本信息表 create table &quot;EMPLOYEES&quot;( &quot;EMPLOYEE_ID&quot; NUMBER(6) not null, &quot;FIRST_NAME&quot; VARCHAR2(20), &quot;LAST_NAME&quot; VARCHAR2(25) not null, &quot;EMAIL&quot; VARCHAR2(25) not null unique, &quot;SALARY&quot; NUMBER(8,2), constraint &quot;EMP_EMP_ID_PK&quot; primary key (&quot;EMPLOYEE_ID&quot;) ); comment on table EMPLOYEES is '员工信息表'; comment on column EMPLOYEES.EMPLOYEE_ID is '员工id'; comment on column EMPLOYEES.FIRST_NAME is 'first name'; comment on column EMPLOYEES.LAST_NAME is 'last name'; comment on column EMPLOYEES.EMAIL is 'email address'; comment on column EMPLOYEES.SALARY is 'salary'; --添加数据 insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (100, 'Steven', 'King', 'SKING', 24000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (101, 'Neena', 'Kochhar', 'NKOCHHAR', 17000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (102, 'Lex', 'De Haan', 'LDEHAAN', 17000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (103, 'Alexander', 'Hunold', 'AHUNOLD', 9000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (104, 'Bruce', 'Ernst', 'BERNST', 6000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (105, 'David', 'Austin', 'DAUSTIN', 4800.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (106, 'Valli', 'Pataballa', 'VPATABAL', 4800.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (107, 'Diana', 'Lorentz', 'DLORENTZ', 4200.00); 3.1.2. Mybatis配置文件 mybatisConfig.xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot; /&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:xe&quot; /&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;louis&quot; /&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot; /&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;com/louis/mybatis/domain/EmployeesMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件 package com.louis.mybatis.model; import java.math.BigDecimal; public class Employee { private Integer employeeId; private String firstName; private String lastName; private String email; private BigDecimal salary; public Integer getEmployeeId() { return employeeId; } public void setEmployeeId(Integer employeeId) { this.employeeId = employeeId; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public BigDecimal getSalary() { return salary; } public void setSalary(BigDecimal salary) { this.salary = salary; } } &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;com.louis.mybatis.dao.EmployeesMapper&quot; &amp;gt; &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.louis.mybatis.model.Employee&quot; &amp;gt; &amp;lt;id column=&quot;EMPLOYEE_ID&quot; property=&quot;employeeId&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt; &amp;lt;result column=&quot;FIRST_NAME&quot; property=&quot;firstName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;LAST_NAME&quot; property=&quot;lastName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;EMAIL&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;SALARY&quot; property=&quot;salary&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &amp;gt; select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY from LOUIS.EMPLOYEES where EMPLOYEE_ID = #{employeeId,jdbcType=DECIMAL} &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; MAVEN依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;10.2.0.4.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3.1.4. 演示代码 package com.louis.mybatis.test; import java.io.InputStream; import java.util.HashMap; import java.util.List; import java.util.Map; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.louis.mybatis.model.Employee; /** * SqlSession 简单查询演示类 * @author louluan */ public class SelectDemo { public static void main(String[] args) throws Exception { /* * 1.加载mybatis的配置文件，初始化mybatis，创建出SqlSessionFactory，是创建SqlSession的工厂 * 这里只是为了演示的需要，SqlSessionFactory临时创建出来，在实际的使用中，SqlSessionFactory只需要创建一次，当作单例来使用 */ InputStream inputStream = Resources.getResourceAsStream(&quot;mybatisConfig.xml&quot;); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); //2. 从SqlSession工厂 SqlSessionFactory中创建一个SqlSession，进行数据库操作 SqlSession sqlSession = factory.openSession(); //3.使用SqlSession查询 Map&amp;lt;String,Object&amp;gt; params = new HashMap&amp;lt;String,Object&amp;gt;(); params.put(&quot;min_salary&quot;,10000); //a.查询工资低于10000的员工 List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params); //b.未传最低工资，查所有员工 List&amp;lt;Employee&amp;gt; result1 = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;); System.out.println(&quot;薪资低于10000的员工数：&quot;+result.size()); //~output : 查询到的数据总数：5 System.out.println(&quot;所有员工数: &quot;+result1.size()); //~output : 所有员工数: 8 } } 3.2. SqlSession工作工程分析 3.2.1. 开启一个数据库访问会话–创建SqlSession对象 SqlSession sqlSession = factory.openSession(); Mybatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中。 3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果 List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params); com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary是配置在xml中的statementId， params是传递的查询参数。 selectList的默认实现 @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) { return this.selectList(statement, parameter, RowBounds.DEFAULT); } @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) { try { //1、根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); //2、将查询任务委托给Mybatis的执行器Execute return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error querying database. Cause: &quot; + e, e); } finally { ErrorContext.instance().reset(); } } MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，使用org.apache.ibatis.session.Configuration实例来维护。使用者可以使用sqlSession.getConfiguration()方法来获取。MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的。上述例子中的 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; &amp;gt; select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY from LOUIS.EMPLOYEES &amp;lt;if test=&quot;min_salary != null&quot;&amp;gt; where SALARY &amp;lt; #{min_salary,jdbcType=DECIMAL} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt; 会加载到内存中生成一个对应的MappedStatement对象，然后以 key = com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary, value = MappedStatement对象的形式维护到Configuration的一个Map中。 总结： SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作。 3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法 /** * BaseExecutor 类部分代码 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { // 1.根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示 BoundSql boundSql = ms.getBoundSql(parameter); // 2.为当前的查询创建一个缓存Key CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } @SuppressWarnings(&quot;unchecked&quot;) public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId()); if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;); if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) { clearLocalCache(); } List&amp;lt;E&amp;gt; list; try { queryStack++; list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null; if (list != null) { handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); } else { // 3.缓存中没有值，直接从数据库中读取数据 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); } } finally { queryStack--; } if (queryStack == 0) { for (DeferredLoad deferredLoad : deferredLoads) { deferredLoad.load(); } deferredLoads.clear(); // issue #601 if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) { clearLocalCache(); // issue #482 } } return list; }  private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { List&amp;lt;E&amp;gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try { //4. 执行查询，返回List 结果，然后 将查询的结果放入缓存之中 list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); } finally { localCache.removeObject(key); } localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) { localOutputParameterCache.putObject(key, parameter); } return list; } /** * *SimpleExecutor类的doQuery()方法实现 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { Statement stmt = null; try { Configuration configuration = ms.getConfiguration(); //5. 根据既有的参数，创建StatementHandler对象来执行查询操作 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); //6. 创建java.Sql.Statement对象，传递给StatementHandler对象 stmt = prepareStatement(handler, ms.getStatementLog()); //7. 调用StatementHandler.query()方法，返回List结果集  return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); } finally { closeStatement(stmt); } } 上述的Executor.query()方法几经转折，最后会创建一个StatementHandler对象，然后将必要的参数传递给StatementHandler，使用StatementHandler来完成对数据库的查询，最终返回List结果集。 总结 根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用； 为查询创建缓存，以提高性能 创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果 3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回 看一下：prepareStatement() 方法的实现 /** * *SimpleExecutor类的doQuery()方法实现 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { Statement stmt = null; try { Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 1.准备Statement对象，并设置Statement对象的参数 stmt = prepareStatement(handler, ms.getStatementLog()); // 2. StatementHandler执行query()方法，返回List结果 return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); } finally { closeStatement(stmt); } } private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException { Statement stmt; Connection connection = getConnection(statementLog); stmt = handler.prepare(connection); //对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数 handler.parameterize(stmt); return stmt; } 总结 对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。 StatementHandler通过parameterize(statement)方法对Statement进行设值； StatementHandler通过List query(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List； 3.2.5. StatementHandler 的parameterize(statement) 方法的实现 /** * StatementHandler 类的parameterize(statement) 方法实现 */ public void parameterize(Statement statement) throws SQLException { //使用ParameterHandler对象来完成对Statement的设值 parameterHandler.setParameters((PreparedStatement) statement); } /** * *ParameterHandler类的setParameters(PreparedStatement ps) 实现 * 对某一个Statement进行设置参数 */ public void setParameters(PreparedStatement ps) throws SQLException { ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId()); List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) { for (int i = 0; i &amp;lt; parameterMappings.size(); i++) { ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } // 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数 TypeHandler typeHandler = parameterMapping.getTypeHandler(); JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;amp;&amp;amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull(); // 设置参数 typeHandler.setParameter(ps, i + 1, value, jdbcType); } } } } 总结 StatementHandler 的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法 ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。 3.2.6. StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现 /** * PreParedStatement类的query方法实现 */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException { // 1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理 PreparedStatement ps = (PreparedStatement) statement; ps.execute(); //2. 使用ResultHandler来处理ResultSet return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps); } /** *ResultSetHandler类的handleResultSets()方法实现 * */ public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException { final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps(); int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) { ResultMap resultMap = resultMaps.get(resultSetCount); //将resultSet handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) { while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) { ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) { String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); } rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } } return collapseSingleResultList(multipleResults); } StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List 结果集 // // DefaultResultSetHandler 类的handleResultSets(Statement stmt)实现 //HANDLE RESULT SETS // public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException { final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps(); int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) { ResultMap resultMap = resultMaps.get(resultSetCount); //将resultSet handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) { while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) { ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) { String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); } rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } } return collapseSingleResultList(multipleResults); }</summary></entry><entry><title type="html">Mybatis事务管理</title><link href="http://localhost:4000/ProgramNote/2017/12/08/Mybatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html" rel="alternate" type="text/html" title="Mybatis事务管理" /><published>2017-12-08T00:00:00+08:00</published><updated>2017-12-08T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/08/Mybatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/08/Mybatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis%E4%BA%8B%E5%8A%A1&quot;&gt;1. Mybatis事务&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%81%E5%88%9B%E5%BB%BA%E3%80%81%E4%BD%BF%E7%94%A8&quot;&gt;2. 事务的配置、创建、使用&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE&quot;&gt;2.1. 事务的配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA&quot;&gt;2.2. 事务的创建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#23-transactionfactory&quot;&gt;2.3. TransactionFactory&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#24-transaction%E7%9A%84%E5%88%9B%E5%BB%BA&quot;&gt;2.4. Transaction的创建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#25-jdbctransaction&quot;&gt;2.5. JdbcTransaction&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#26-managedtransaction&quot;&gt;2.6. ManagedTransaction&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis事务&quot;&gt;1. Mybatis事务&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据库的事务具有 创建、提交、回滚、关闭功能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Mybatis事务管理分为&lt;code class=&quot;highlighter-rouge&quot;&gt;JdbcTransaction&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ManagedTransaction&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;JdbcTransaction : 使用java.sql.Connection对象完成对事务的&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;rollback&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;close&lt;/code&gt;操作&lt;/li&gt;
  &lt;li&gt;ManagedTransaction ： 使用容器例如JBOSS来实现对事务的管理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/13.png&quot; alt=&quot;类图&quot; title=&quot;类图&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-事务的配置创建使用&quot;&gt;2. 事务的配置、创建、使用&lt;/h1&gt;
&lt;h2 id=&quot;21-事务的配置&quot;&gt;2.1. 事务的配置&lt;/h2&gt;
&lt;p&gt;通常Mybatis的配置如下
&lt;img src=&quot;/Image/mybatis/14.png&quot; alt=&quot;配置&quot; title=&quot;配置&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;environment&lt;/code&gt;节点定义了连接数据库的信息，&lt;code class=&quot;highlighter-rouge&quot;&gt;transactionManager&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;属性决定了使用哪种类型的事务管理机制。&lt;/p&gt;

&lt;h2 id=&quot;22-事务的创建&quot;&gt;2.2. 事务的创建&lt;/h2&gt;
&lt;p&gt;MyBatis事务的创建是交给TransactionFactory 事务工厂来创建的，如果我们将&lt;transactionManager&gt;的type 配置为&quot;JDBC&quot;,那么，在MyBatis初始化解析&lt;environment&gt;节点时，会根据type=&quot;JDBC&quot;创建一个JdbcTransactionFactory工厂&lt;/environment&gt;&lt;/transactionManager&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  public Configuration() {
    typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
    typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

    typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
    typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
    typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  //XMLConfigBuilder 
  private void environmentsElement(XNode context) throws Exception {
    if (context != null) {
      if (environment == null) {
        environment = context.getStringAttribute(&quot;default&quot;);//获取environments的default属性值
      }
      for (XNode child : context.getChildren()) {
        String id = child.getStringAttribute(&quot;id&quot;);//获取environment的id值
        if (isSpecifiedEnvironment(id)) {//判断上面获取的这两个值是否一致
          TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));//根据transactionManager决定创建什么类型的TransactionFactory
          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));//创建DataSource
          DataSource dataSource = dsFactory.getDataSource();
          Environment.Builder environmentBuilder = new Environment.Builder(id)
              .transactionFactory(txFactory)
              .dataSource(dataSource);//使用了Environment内置的构造器Builder，传递id 事务工厂TransactionFactory和数据源DataSource  
          configuration.setEnvironment(environmentBuilder.build());
        }
      }
    }
  }

    private boolean isSpecifiedEnvironment(String id) {
    if (environment == null) {
      throw new BuilderException(&quot;No environment specified.&quot;);
    } else if (id == null) {
      throw new BuilderException(&quot;Environment requires an id attribute.&quot;);
    } else if (environment.equals(id)) {
      return true;
    }
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  //解析&amp;lt;transactionManager&amp;gt;节点，创建对应的TransactionFactory
  private TransactionFactory transactionManagerElement(XNode context) throws Exception {
    if (context != null) {
      String type = context.getStringAttribute(&quot;type&quot;);
      Properties props = context.getChildrenAsProperties();
      TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance();//上面Configuration中设置了typeAliasRegistry.registerAlias
      factory.setProperties(props);
      return factory;
    }
    throw new BuilderException(&quot;Environment declaration requires a TransactionFactory.&quot;);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;23-transactionfactory&quot;&gt;2.3. TransactionFactory&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/15.png&quot; alt=&quot;类图&quot; title=&quot;类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;事务工厂Transaction定义了创建Transaction的两个方法：一个是通过指定的Connection对象创建 Transaction，另外是通过数据源DataSource来创建Transaction。与JDBC 和MANAGED两种Transaction相对应，TransactionFactory有两个对应的实现的子类&lt;/p&gt;

&lt;h2 id=&quot;24-transaction的创建&quot;&gt;2.4. Transaction的创建&lt;/h2&gt;
&lt;p&gt;通过事务工厂TransactionFactory很容易获取到Transaction对象实例。我们以JdbcTransaction为例，看一下JdbcTransactionFactory是怎样生成JdbcTransaction的，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * Creates {@link JdbcTransaction} instances.
 *
 * @author Clinton Begin
 *
 * @see JdbcTransaction
 */
public class JdbcTransactionFactory implements TransactionFactory {

  @Override
  public void setProperties(Properties props) {
  }
    /** 
    * 根据给定的数据库连接Connection创建Transaction 
    * @param conn Existing database connection 
    * @return 
    */
  @Override
  public Transaction newTransaction(Connection conn) {
    return new JdbcTransaction(conn);
  }

    /** 
     * 根据DataSource、隔离级别和是否自动提交创建Transacion 
     * 
     * @param ds 
     * @param level Desired isolation level 
     * @param autoCommit Desired autocommit 
     * @return 
     */
  @Override
  public Transaction newTransaction(DataSource ds, TransactionIsolationLevel level, boolean autoCommit) {
    return new JdbcTransaction(ds, level, autoCommit);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上说是，JdbcTransactionFactory会创建JDBC类型的Transaction，即JdbcTransaction。类似地，ManagedTransactionFactory也会创建ManagedTransaction。&lt;/p&gt;

&lt;h2 id=&quot;25-jdbctransaction&quot;&gt;2.5. JdbcTransaction&lt;/h2&gt;
&lt;p&gt;JdbcTransaction直接使用JDBC提交和回滚事务。它依赖于从DataSource中取得的Connection来管理transaction的作用域，Connection对象的获取被延迟到调用getConnection()方法。&lt;/p&gt;

&lt;p&gt;如果aotocommit设置为on，自动忽略commit和rollback。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * {@link Transaction} 它直接使用JDBC提交和回滚工具。
 * 它依赖从数据源检索到的连接来管理事务的范围。
 * 延迟连接检索到get connection()被调用。
 * 在自动提交时忽略提交或回滚请求。
 *
 * @author Clinton Begin
 *
 * @see JdbcTransactionFactory
 */
public class JdbcTransaction implements Transaction {

  private static final Log log = LogFactory.getLog(JdbcTransaction.class);

  protected Connection connection;
  protected DataSource dataSource;
  protected TransactionIsolationLevel level;
  // MEMO: We are aware of the typo. See #941
  protected boolean autoCommmit;

  public JdbcTransaction(DataSource ds, TransactionIsolationLevel desiredLevel, boolean desiredAutoCommit) {
    dataSource = ds;
    level = desiredLevel;
    autoCommmit = desiredAutoCommit;
  }

  public JdbcTransaction(Connection connection) {
    this.connection = connection;
  }

  @Override
  public Connection getConnection() throws SQLException {
    if (connection == null) {
      openConnection();
    }
    return connection;
  }

  @Override
  public void commit() throws SQLException {
    if (connection != null &amp;amp;&amp;amp; !connection.getAutoCommit()) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;Committing JDBC Connection [&quot; + connection + &quot;]&quot;);
      }
      connection.commit();
    }
  }

  @Override
  public void rollback() throws SQLException {
    if (connection != null &amp;amp;&amp;amp; !connection.getAutoCommit()) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;Rolling back JDBC Connection [&quot; + connection + &quot;]&quot;);
      }
      connection.rollback();
    }
  }

  @Override
  public void close() throws SQLException {
    if (connection != null) {
      resetAutoCommit();
      if (log.isDebugEnabled()) {
        log.debug(&quot;Closing JDBC Connection [&quot; + connection + &quot;]&quot;);
      }
      connection.close();
    }
  }

  protected void setDesiredAutoCommit(boolean desiredAutoCommit) {
    try {
      if (connection.getAutoCommit() != desiredAutoCommit) {
        if (log.isDebugEnabled()) {
          log.debug(&quot;Setting autocommit to &quot; + desiredAutoCommit + &quot; on JDBC Connection [&quot; + connection + &quot;]&quot;);
        }
        connection.setAutoCommit(desiredAutoCommit);
      }
    } catch (SQLException e) {
      // Only a very poorly implemented driver would fail here,
      // and there's not much we can do about that.
      throw new TransactionException(&quot;Error configuring AutoCommit.  &quot;
          + &quot;Your driver may not support getAutoCommit() or setAutoCommit(). &quot;
          + &quot;Requested setting: &quot; + desiredAutoCommit + &quot;.  Cause: &quot; + e, e);
    }
  }

  protected void resetAutoCommit() {
    try {
      if (!connection.getAutoCommit()) {
        // MyBatis does not call commit/rollback on a connection if just selects were performed.
        // Some databases start transactions with select statements
        // and they mandate a commit/rollback before closing the connection.
        // A workaround is setting the autocommit to true before closing the connection.
        // Sybase throws an exception here.
        if (log.isDebugEnabled()) {
          log.debug(&quot;Resetting autocommit to true on JDBC Connection [&quot; + connection + &quot;]&quot;);
        }
        connection.setAutoCommit(true);
      }
    } catch (SQLException e) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;Error resetting autocommit to true &quot;
          + &quot;before closing the connection.  Cause: &quot; + e);
      }
    }
  }

  protected void openConnection() throws SQLException {
    if (log.isDebugEnabled()) {
      log.debug(&quot;Opening JDBC Connection&quot;);
    }
    connection = dataSource.getConnection();
    if (level != null) {
      connection.setTransactionIsolation(level.getLevel());
    }
    setDesiredAutoCommit(autoCommmit);
  }

  @Override
  public Integer getTimeout() throws SQLException {
    return null;
  }
  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;26-managedtransaction&quot;&gt;2.6. ManagedTransaction&lt;/h2&gt;

&lt;p&gt;ManagedTransaction让容器来管理事务Transaction的整个生命周期，意思就是说，使用ManagedTransaction的commit和rollback功能不会对事务有任何的影响，它什么都不会做，它将事务管理的权利移交给了容器来实现。看如下Managed的实现代码大家就会一目了然：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * {@link Transaction} 让容器管理事务transaction的整个生命周期 
 * connection的获取延迟到getConnection()方法的调用 
 * 忽略所有的commit和rollback操作 
 * 默认情况下，可以关闭一个连接connection，也可以配置它不可以关闭一个连接 
 * 让容器来管理transaction的整个生命周期 
 *
 * @author Clinton Begin
 *
 * @see ManagedTransactionFactory
 */
public class ManagedTransaction implements Transaction {

  private static final Log log = LogFactory.getLog(ManagedTransaction.class);

  private DataSource dataSource;
  private TransactionIsolationLevel level;
  private Connection connection;
  private final boolean closeConnection;

  public ManagedTransaction(Connection connection, boolean closeConnection) {
    this.connection = connection;
    this.closeConnection = closeConnection;
  }

  public ManagedTransaction(DataSource ds, TransactionIsolationLevel level, boolean closeConnection) {
    this.dataSource = ds;
    this.level = level;
    this.closeConnection = closeConnection;
  }

  @Override
  public Connection getConnection() throws SQLException {
    if (this.connection == null) {
      openConnection();
    }
    return this.connection;
  }

  @Override
  public void commit() throws SQLException {
    // Does nothing
  }

  @Override
  public void rollback() throws SQLException {
    // Does nothing
  }

  @Override
  public void close() throws SQLException {
    if (this.closeConnection &amp;amp;&amp;amp; this.connection != null) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;Closing JDBC Connection [&quot; + this.connection + &quot;]&quot;);
      }
      this.connection.close();
    }
  }

  protected void openConnection() throws SQLException {
    if (log.isDebugEnabled()) {
      log.debug(&quot;Opening JDBC Connection&quot;);
    }
    this.connection = this.dataSource.getConnection();
    if (this.level != null) {
      this.connection.setTransactionIsolation(this.level.getLevel());
    }
  }

  @Override
  public Integer getTimeout() throws SQLException {
    return null;
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;如果我们使用MyBatis构建本地程序，即不是WEB程序，若将type设置成”MANAGED”，那么，我们执行的任何update操作，即使我们最后执行了commit操作，数据也不会保留，不会对数据库造成任何影响。因为我们将MyBatis配置成了“MANAGED”，即MyBatis自己不管理事务，而我们又是运行的本地程序，没有事务管理功能，所以对数据库的update操作都是无效的。&lt;/p&gt;

&lt;p&gt;TODO:Spring+Mybatis事务是如何运转的？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luanlouis/article/details/37992171&quot;&gt;原文地址http://blog.csdn.net/luanlouis/article/details/37992171&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><summary type="html">1. Mybatis事务 2. 事务的配置、创建、使用 2.1. 事务的配置 2.2. 事务的创建 2.3. TransactionFactory 2.4. Transaction的创建 2.5. JdbcTransaction 2.6. ManagedTransaction 1. Mybatis事务 数据库的事务具有 创建、提交、回滚、关闭功能。 Mybatis事务管理分为JdbcTransaction和ManagedTransaction： JdbcTransaction : 使用java.sql.Connection对象完成对事务的commit、rollback、close操作 ManagedTransaction ： 使用容器例如JBOSS来实现对事务的管理 2. 事务的配置、创建、使用 2.1. 事务的配置 通常Mybatis的配置如下 environment节点定义了连接数据库的信息，transactionManager的type属性决定了使用哪种类型的事务管理机制。 2.2. 事务的创建 MyBatis事务的创建是交给TransactionFactory 事务工厂来创建的，如果我们将的type 配置为&quot;JDBC&quot;,那么，在MyBatis初始化解析节点时，会根据type=&quot;JDBC&quot;创建一个JdbcTransactionFactory工厂 public Configuration() { typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); ... } //XMLConfigBuilder private void environmentsElement(XNode context) throws Exception { if (context != null) { if (environment == null) { environment = context.getStringAttribute(&quot;default&quot;);//获取environments的default属性值 } for (XNode child : context.getChildren()) { String id = child.getStringAttribute(&quot;id&quot;);//获取environment的id值 if (isSpecifiedEnvironment(id)) {//判断上面获取的这两个值是否一致 TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));//根据transactionManager决定创建什么类型的TransactionFactory DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));//创建DataSource DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource);//使用了Environment内置的构造器Builder，传递id 事务工厂TransactionFactory和数据源DataSource configuration.setEnvironment(environmentBuilder.build()); } } } } private boolean isSpecifiedEnvironment(String id) { if (environment == null) { throw new BuilderException(&quot;No environment specified.&quot;); } else if (id == null) { throw new BuilderException(&quot;Environment requires an id attribute.&quot;); } else if (environment.equals(id)) { return true; } return false; } //解析&amp;lt;transactionManager&amp;gt;节点，创建对应的TransactionFactory private TransactionFactory transactionManagerElement(XNode context) throws Exception { if (context != null) { String type = context.getStringAttribute(&quot;type&quot;); Properties props = context.getChildrenAsProperties(); TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance();//上面Configuration中设置了typeAliasRegistry.registerAlias factory.setProperties(props); return factory; } throw new BuilderException(&quot;Environment declaration requires a TransactionFactory.&quot;); } 2.3. TransactionFactory 事务工厂Transaction定义了创建Transaction的两个方法：一个是通过指定的Connection对象创建 Transaction，另外是通过数据源DataSource来创建Transaction。与JDBC 和MANAGED两种Transaction相对应，TransactionFactory有两个对应的实现的子类 2.4. Transaction的创建 通过事务工厂TransactionFactory很容易获取到Transaction对象实例。我们以JdbcTransaction为例，看一下JdbcTransactionFactory是怎样生成JdbcTransaction的，代码如下： /** * Creates {@link JdbcTransaction} instances. * * @author Clinton Begin * * @see JdbcTransaction */ public class JdbcTransactionFactory implements TransactionFactory { @Override public void setProperties(Properties props) { } /** * 根据给定的数据库连接Connection创建Transaction * @param conn Existing database connection * @return */ @Override public Transaction newTransaction(Connection conn) { return new JdbcTransaction(conn); } /** * 根据DataSource、隔离级别和是否自动提交创建Transacion * * @param ds * @param level Desired isolation level * @param autoCommit Desired autocommit * @return */ @Override public Transaction newTransaction(DataSource ds, TransactionIsolationLevel level, boolean autoCommit) { return new JdbcTransaction(ds, level, autoCommit); } } 如上说是，JdbcTransactionFactory会创建JDBC类型的Transaction，即JdbcTransaction。类似地，ManagedTransactionFactory也会创建ManagedTransaction。 2.5. JdbcTransaction JdbcTransaction直接使用JDBC提交和回滚事务。它依赖于从DataSource中取得的Connection来管理transaction的作用域，Connection对象的获取被延迟到调用getConnection()方法。 如果aotocommit设置为on，自动忽略commit和rollback。 /** * {@link Transaction} 它直接使用JDBC提交和回滚工具。 * 它依赖从数据源检索到的连接来管理事务的范围。 * 延迟连接检索到get connection()被调用。 * 在自动提交时忽略提交或回滚请求。 * * @author Clinton Begin * * @see JdbcTransactionFactory */ public class JdbcTransaction implements Transaction { private static final Log log = LogFactory.getLog(JdbcTransaction.class); protected Connection connection; protected DataSource dataSource; protected TransactionIsolationLevel level; // MEMO: We are aware of the typo. See #941 protected boolean autoCommmit; public JdbcTransaction(DataSource ds, TransactionIsolationLevel desiredLevel, boolean desiredAutoCommit) { dataSource = ds; level = desiredLevel; autoCommmit = desiredAutoCommit; } public JdbcTransaction(Connection connection) { this.connection = connection; } @Override public Connection getConnection() throws SQLException { if (connection == null) { openConnection(); } return connection; } @Override public void commit() throws SQLException { if (connection != null &amp;amp;&amp;amp; !connection.getAutoCommit()) { if (log.isDebugEnabled()) { log.debug(&quot;Committing JDBC Connection [&quot; + connection + &quot;]&quot;); } connection.commit(); } } @Override public void rollback() throws SQLException { if (connection != null &amp;amp;&amp;amp; !connection.getAutoCommit()) { if (log.isDebugEnabled()) { log.debug(&quot;Rolling back JDBC Connection [&quot; + connection + &quot;]&quot;); } connection.rollback(); } } @Override public void close() throws SQLException { if (connection != null) { resetAutoCommit(); if (log.isDebugEnabled()) { log.debug(&quot;Closing JDBC Connection [&quot; + connection + &quot;]&quot;); } connection.close(); } } protected void setDesiredAutoCommit(boolean desiredAutoCommit) { try { if (connection.getAutoCommit() != desiredAutoCommit) { if (log.isDebugEnabled()) { log.debug(&quot;Setting autocommit to &quot; + desiredAutoCommit + &quot; on JDBC Connection [&quot; + connection + &quot;]&quot;); } connection.setAutoCommit(desiredAutoCommit); } } catch (SQLException e) { // Only a very poorly implemented driver would fail here, // and there's not much we can do about that. throw new TransactionException(&quot;Error configuring AutoCommit. &quot; + &quot;Your driver may not support getAutoCommit() or setAutoCommit(). &quot; + &quot;Requested setting: &quot; + desiredAutoCommit + &quot;. Cause: &quot; + e, e); } } protected void resetAutoCommit() { try { if (!connection.getAutoCommit()) { // MyBatis does not call commit/rollback on a connection if just selects were performed. // Some databases start transactions with select statements // and they mandate a commit/rollback before closing the connection. // A workaround is setting the autocommit to true before closing the connection. // Sybase throws an exception here. if (log.isDebugEnabled()) { log.debug(&quot;Resetting autocommit to true on JDBC Connection [&quot; + connection + &quot;]&quot;); } connection.setAutoCommit(true); } } catch (SQLException e) { if (log.isDebugEnabled()) { log.debug(&quot;Error resetting autocommit to true &quot; + &quot;before closing the connection. Cause: &quot; + e); } } } protected void openConnection() throws SQLException { if (log.isDebugEnabled()) { log.debug(&quot;Opening JDBC Connection&quot;); } connection = dataSource.getConnection(); if (level != null) { connection.setTransactionIsolation(level.getLevel()); } setDesiredAutoCommit(autoCommmit); } @Override public Integer getTimeout() throws SQLException { return null; } } 2.6. ManagedTransaction ManagedTransaction让容器来管理事务Transaction的整个生命周期，意思就是说，使用ManagedTransaction的commit和rollback功能不会对事务有任何的影响，它什么都不会做，它将事务管理的权利移交给了容器来实现。看如下Managed的实现代码大家就会一目了然： /** * {@link Transaction} 让容器管理事务transaction的整个生命周期 * connection的获取延迟到getConnection()方法的调用 * 忽略所有的commit和rollback操作 * 默认情况下，可以关闭一个连接connection，也可以配置它不可以关闭一个连接 * 让容器来管理transaction的整个生命周期 * * @author Clinton Begin * * @see ManagedTransactionFactory */ public class ManagedTransaction implements Transaction { private static final Log log = LogFactory.getLog(ManagedTransaction.class); private DataSource dataSource; private TransactionIsolationLevel level; private Connection connection; private final boolean closeConnection; public ManagedTransaction(Connection connection, boolean closeConnection) { this.connection = connection; this.closeConnection = closeConnection; } public ManagedTransaction(DataSource ds, TransactionIsolationLevel level, boolean closeConnection) { this.dataSource = ds; this.level = level; this.closeConnection = closeConnection; } @Override public Connection getConnection() throws SQLException { if (this.connection == null) { openConnection(); } return this.connection; } @Override public void commit() throws SQLException { // Does nothing } @Override public void rollback() throws SQLException { // Does nothing } @Override public void close() throws SQLException { if (this.closeConnection &amp;amp;&amp;amp; this.connection != null) { if (log.isDebugEnabled()) { log.debug(&quot;Closing JDBC Connection [&quot; + this.connection + &quot;]&quot;); } this.connection.close(); } } protected void openConnection() throws SQLException { if (log.isDebugEnabled()) { log.debug(&quot;Opening JDBC Connection&quot;); } this.connection = this.dataSource.getConnection(); if (this.level != null) { this.connection.setTransactionIsolation(this.level.getLevel()); } } @Override public Integer getTimeout() throws SQLException { return null; } } 注意如果我们使用MyBatis构建本地程序，即不是WEB程序，若将type设置成”MANAGED”，那么，我们执行的任何update操作，即使我们最后执行了commit操作，数据也不会保留，不会对数据库造成任何影响。因为我们将MyBatis配置成了“MANAGED”，即MyBatis自己不管理事务，而我们又是运行的本地程序，没有事务管理功能，所以对数据库的update操作都是无效的。 TODO:Spring+Mybatis事务是如何运转的？ 原文地址http://blog.csdn.net/luanlouis/article/details/37992171</summary></entry><entry><title type="html">Mybatis数据源和连接池</title><link href="http://localhost:4000/ProgramNote/2017/12/07/Mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0.html" rel="alternate" type="text/html" title="Mybatis数据源和连接池" /><published>2017-12-07T00:00:00+08:00</published><updated>2017-12-07T00:00:00+08:00</updated><id>http://localhost:4000/ProgramNote/2017/12/07/Mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0</id><content type="html" xml:base="http://localhost:4000/ProgramNote/2017/12/07/Mybatis%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0.html">&lt;p&gt;对于ORM框架而言，数据源的组织是一个非常重要的一部分，这直接影响到框架的性能问题。
&lt;!-- TOC --&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis%E6%95%B0%E6%8D%AE%E6%BA%90datasource%E5%88%86%E7%B1%BB&quot;&gt;1. MyBatis数据源DataSource分类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-datasource%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B&quot;&gt;2. DataSource的创建过程&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90&quot;&gt;2.1. 文件解析&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F&quot;&gt;2.2. 创建模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#23-%E5%AD%98%E5%82%A8&quot;&gt;2.3. 存储&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-datasource%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BAconnection%E5%AF%B9%E8%B1%A1&quot;&gt;3. DataSource什么时候创建Connection对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-unpooleddatasource&quot;&gt;4. UnpooledDataSource&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#41-%E5%88%9B%E5%BB%BAconnection%E8%BF%87%E7%A8%8B&quot;&gt;4.1. 创建Connection过程&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0&quot;&gt;5. 使用连接池&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#51-%E5%88%86%E6%9E%90&quot;&gt;5.1. 分析&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-pooleddatasource&quot;&gt;6. PooledDataSource&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#61-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&quot;&gt;6.1. 基本原理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#62-%E8%8E%B7%E5%8F%96javasqlconnection%E5%AF%B9%E8%B1%A1&quot;&gt;6.2. 获取java.sql.Connection对象&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#63-javasqlconnection%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6&quot;&gt;6.3. java.sql.Connection对象回收&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#64-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9B%9E%E6%94%B6connection&quot;&gt;6.4. 代理模式回收Connection&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-jndi%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90datasource&quot;&gt;7. JNDI类型的数据源DataSource&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#71-mybatis-jndi%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E7%8E%B0&quot;&gt;7.1. Mybatis JNDI数据源实现&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#72-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8jndi&quot;&gt;7.2. 为什么使用JNDI&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis数据源datasource分类&quot;&gt;1. MyBatis数据源DataSource分类&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;MyBatis数据源&lt;/strong&gt;实现是在以下四个包中&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.apache.ibatis.datasource&lt;/li&gt;
  &lt;li&gt;org.apache.ibatis.datasource.jndi&lt;/li&gt;
  &lt;li&gt;org.apache.ibatis.datasource.pooled&lt;/li&gt;
  &lt;li&gt;org.apache.ibatis.datasource.unpooled&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数据源&lt;/strong&gt;分类三类&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;数据源分类&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;UNPOOLED&lt;/td&gt;&lt;td&gt;不使用连接池的数据源&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;POOLED&lt;/td&gt;&lt;td&gt;使用连接池的数据源&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;JNDI&lt;/td&gt;&lt;td&gt;使用JNDI实现的数据源&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Mybatis 内部定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.sql.DataSource&lt;/code&gt;接口
&lt;code class=&quot;highlighter-rouge&quot;&gt;UnpooledDataSource 和 PooledDataSource实现了DataSource接口&lt;/code&gt;
&lt;img src=&quot;/Image/mybatis/8.png&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JNDI类型的数据源DataSource，通过JNDI上下文取值。（&lt;strong&gt;What it means？&lt;/strong&gt;）&lt;/p&gt;

&lt;h1 id=&quot;2-datasource的创建过程&quot;&gt;2. DataSource的创建过程&lt;/h1&gt;

&lt;p&gt;Mybatis数据源DataSource的创建发生在Mybatis初始化的过程中。&lt;/p&gt;

&lt;p&gt;Mybatis配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
  &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
  &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
  &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
  &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
&amp;lt;/dataSource&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;21-文件解析&quot;&gt;2.1. 文件解析&lt;/h2&gt;
&lt;p&gt;DataSource类型通过type决定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;type=”POOLED”  ：MyBatis会创建PooledDataSource实例&lt;/li&gt;
  &lt;li&gt;type=”UNPOOLED” ：MyBatis会创建UnpooledDataSource实例&lt;/li&gt;
  &lt;li&gt;type=”JNDI”     ：MyBatis会从JNDI服务上查找DataSource实例，然后返回使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-创建模式&quot;&gt;2.2. 创建模式&lt;/h2&gt;
&lt;p&gt;Mybatis通过工厂模式来创建DataSource对象，Mybatis定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.ibatis.datasource.DataSourceFactory&lt;/code&gt;接口，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getDataSource()&lt;/code&gt; 方法返回数据源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public interface DataSourceFactory {

  void setProperties(Properties props);

  DataSource getDataSource();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对三种类型的Type，对应有三种实现工厂&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;POOLED        PooledDataSourceFactory&lt;/li&gt;
  &lt;li&gt;UNPOOLED     UnpooledDataSourceFactory&lt;/li&gt;
  &lt;li&gt;9JNDI          JndiDataSourceFactory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/9.png&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-存储&quot;&gt;2.3. 存储&lt;/h2&gt;
&lt;p&gt;Mybatis创建&lt;code class=&quot;highlighter-rouge&quot;&gt;DataSource&lt;/code&gt;实例以后，放置到&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Environment&lt;/code&gt;对象中，供调用。&lt;/p&gt;

&lt;h1 id=&quot;3-datasource什么时候创建connection对象&quot;&gt;3. DataSource什么时候创建Connection对象&lt;/h1&gt;
&lt;p&gt;当需要创建SqlSession对象并且需要执行SQL语句的时候，Mybatis才会调用DataSource对象创建Connection对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;String resource = &quot;mybatis-config.xml&quot;;  
InputStream inputStream = Resources.getResourceAsStream(resource);  
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  
SqlSession sqlSession = sqlSessionFactory.openSession();  
sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码一直到了&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;);&lt;/code&gt;才会创建Connection。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  protected void openConnection() throws SQLException {
    if (log.isDebugEnabled()) {
      log.debug(&quot;Opening JDBC Connection&quot;);
    }
    connection = dataSource.getConnection();
    if (level != null) {
      connection.setTransactionIsolation(level.getLevel());
    }
    setDesiredAutoCommit(autoCommmit);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4-unpooleddatasource&quot;&gt;4. UnpooledDataSource&lt;/h1&gt;
&lt;p&gt;当DataSource的type属性配置成&lt;strong&gt;UNPOOLED&lt;/strong&gt;，MyBatis首先会实例化一个&lt;strong&gt;UnpooledDataSourceFactory&lt;/strong&gt;工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。
使用UnpooledDataSource的getConnection(),每调用一次就会产生一个新的Connection实例对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public Connection getConnection() throws SQLException {
    return doGetConnection(username, password);
  }

  @Override
  public Connection getConnection(String username, String password) throws SQLException {
    return doGetConnection(username, password);
  }

  private Connection doGetConnection(String username, String password) throws SQLException {
    Properties props = new Properties();
    if (driverProperties != null) {
      props.putAll(driverProperties);
    }
    if (username != null) {
      props.setProperty(&quot;user&quot;, username);
    }
    if (password != null) {
      props.setProperty(&quot;password&quot;, password);
    }
    return doGetConnection(props);
  }

  private Connection doGetConnection(Properties properties) throws SQLException {
    //初始化驱动
    initializeDriver();
    //获取连接，获取新的Connection对象
    Connection connection = DriverManager.getConnection(url, properties);
    //配置Connection
    configureConnection(connection);
    return connection;
  }

  private void configureConnection(Connection conn) throws SQLException {
    if (autoCommit != null &amp;amp;&amp;amp; autoCommit != conn.getAutoCommit()) {
      conn.setAutoCommit(autoCommit);
    }
    if (defaultTransactionIsolationLevel != null) {
      conn.setTransactionIsolation(defaultTransactionIsolationLevel);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建connection过程&quot;&gt;4.1. 创建Connection过程&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;初始化驱动&lt;/code&gt;：判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;创建Connection对象&lt;/code&gt;：使用DriverManager.getConnection()方法创建连接。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;配置Connection对象&lt;/code&gt;：设置是否自动提交autoCommit和隔离级别isolationLevel。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;返回Connection对象&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/Image/mybatis/10.png&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：每调用一次getConnection()都会返回一个新的java.sql.Connection实例。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-使用连接池&quot;&gt;5. 使用连接池&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static void main(String[] args) throws Exception
{

    String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;;
    PreparedStatement st = null;
    ResultSet rs = null;

    long beforeTimeOffset = -1L; //创建Connection对象前时间
    long afterTimeOffset = -1L; //创建Connection对象后时间
    long executeTimeOffset = -1L; //创建Connection对象后时间

    Connection con = null;
    Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);

    beforeTimeOffset = new Date().getTime();
    System.out.println(&quot;before:\t&quot; + beforeTimeOffset);

    con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;);

    afterTimeOffset = new Date().getTime();
    System.out.println(&quot;after:\t\t&quot; + afterTimeOffset);
    System.out.println(&quot;Create Costs:\t\t&quot; + (afterTimeOffset - beforeTimeOffset) + &quot; ms&quot;);

    st = con.prepareStatement(sql);
    //设置参数
    st.setInt(1, 101);
    st.setInt(2, 0);
    //查询，得出结果集
    rs = st.executeQuery();
    executeTimeOffset = new Date().getTime();
    System.out.println(&quot;Exec Costs:\t\t&quot; + (executeTimeOffset - afterTimeOffset) + &quot; ms&quot;);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;before：1404363138126&lt;/p&gt;

&lt;p&gt;after：1404363138376&lt;/p&gt;

&lt;p&gt;Create Costs：250ms&lt;/p&gt;

&lt;p&gt;Exec Costs：170ms&lt;/p&gt;

&lt;p&gt;结果显示：创建一个Connection对象需要250ms，执行sql需要170ms。&lt;/p&gt;

&lt;h2 id=&quot;51-分析&quot;&gt;5.1. 分析&lt;/h2&gt;
&lt;p&gt;创建Connection对象代价巨大，仅仅建立通讯连接就消耗了非常多的时间。&lt;/p&gt;

&lt;p&gt;对于需要频繁地跟数据库交互的应用程序，可以在创建了Connection对象，并操作完数据库后，可以不释放掉资源，而是将它放到内存中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。&lt;/p&gt;

&lt;p&gt;同时，由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。&lt;/p&gt;

&lt;p&gt;我们将在内存中存放Connection对象的容器称之为 &lt;code class=&quot;highlighter-rouge&quot;&gt;连接池（Connection Pool）&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;6-pooleddatasource&quot;&gt;6. PooledDataSource&lt;/h1&gt;
&lt;h2 id=&quot;61-基本原理&quot;&gt;6.1. 基本原理&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledDataSource&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;java.sql.Connection&lt;/code&gt;对象包裹成&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledConnection&lt;/code&gt;对象放到了&lt;code class=&quot;highlighter-rouge&quot;&gt;PoolState&lt;/code&gt;类型的容器中维护。&lt;/p&gt;

&lt;p&gt;MyBatis将连接池中的&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledConnection分为两种状态&lt;/code&gt;： &lt;code class=&quot;highlighter-rouge&quot;&gt;空闲状态（idle）&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;活动状态(active)&lt;/code&gt;，这两种状态的PooledConnection对象分别被存储到PoolState容器内的&lt;code class=&quot;highlighter-rouge&quot;&gt;idleConnections&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;activeConnections&lt;/code&gt;两个List集合中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;idleConnections:空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，&lt;code class=&quot;highlighter-rouge&quot;&gt;会优先从此集合中取PooledConnection对象&lt;/code&gt;。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;activeConnections:活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象,如果没有，则看此集合是否已满，&lt;code class=&quot;highlighter-rouge&quot;&gt;如果未满，PooledDataSource会创建出一个PooledConnection&lt;/code&gt;，添加到此集合中，并返回。(先获取空闲的，没有空闲的而且活动的未满，就创造一个新的，放到活动中)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PoolState连接池的大致结构：
![连接池](/Image/mybatis/11.png ‘’)&lt;/p&gt;

&lt;h2 id=&quot;62-获取javasqlconnection对象&quot;&gt;6.2. 获取java.sql.Connection对象&lt;/h2&gt;
&lt;p&gt;获取Connection的实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  @Override
  public Connection getConnection() throws SQLException {
    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();
  }

  @Override
  public Connection getConnection(String username, String password) throws SQLException {
    return popConnection(username, password).getProxyConnection();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的popConnection()会从连接池返回一个PooledConnection对象，然后调用getProxyConnection()获取最终的Connection对象。（getProxyConnection()稍后在介绍）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;popConnection()方法到底做了什么&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;先看是否有空闲(idle)状态下的PooledConnection对象，如果有，就直接返回一个可用的PooledConnection对象；否则进行第2步。&lt;/li&gt;
  &lt;li&gt;查看活动状态的PooledConnection池activeConnections是否已满；如果没有满，则创建一个新的PooledConnection对象，然后放到activeConnections池中，然后返回此PooledConnection对象；否则进行第三步；&lt;/li&gt;
  &lt;li&gt;看最先进入activeConnections池中的PooledConnection对象是否已经过期：如果已经过期，从activeConnections池中移除此对象，然后创建一个新的PooledConnection对象，添加到activeConnections中，然后将此对象返回；否则进行第4步。&lt;/li&gt;
  &lt;li&gt;线程等待，循环2步&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  private final PoolState state = new PoolState(this);

  private final UnpooledDataSource dataSource;
  
  private PooledConnection popConnection(String username, String password) throws SQLException {
    boolean countedWait = false;
    PooledConnection conn = null;
    long t = System.currentTimeMillis();
    int localBadConnectionCount = 0;

    while (conn == null) {
      synchronized (state) {
        if (!state.idleConnections.isEmpty()) {
          // idelConnections中有空闲的Connection对象，直接取出使用
          conn = state.idleConnections.remove(0);
          if (log.isDebugEnabled()) {
            log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);
          }
        } else {
          // idelConnections中没有空闲的Connection对象，但是activeConnections还没有达到最大活动上限
          if (state.activeConnections.size() &amp;lt; poolMaximumActiveConnections) {
            // 创建一个新的Connection
            conn = new PooledConnection(dataSource.getConnection(), this);
            if (log.isDebugEnabled()) {
              log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
            }
          } else {
            // activeConnections已经达到最大活动上限，不能创建新的
            // 获取最老的活动连接，检查超时
            PooledConnection oldestActiveConnection = state.activeConnections.get(0);
            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();
            if (longestCheckoutTime &amp;gt; poolMaximumCheckoutTime) {
              // 最老的活动连接判定超时
              state.claimedOverdueConnectionCount++;
              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;
              state.accumulatedCheckoutTime += longestCheckoutTime;
              state.activeConnections.remove(oldestActiveConnection);
              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {
                try {
                  oldestActiveConnection.getRealConnection().rollback();
                } catch (SQLException e) {
                  /*
                     只需为debug记录一条消息，并继续执行下面的语句，就像没有发生任何事情一样。
                     用一个新的Pooled连接包装the bad connection，这将有助于不影响当前的执行线程，
                     并给当前线程一个机会，使其能够与另一个valid/good database
                     connection一起参加下一个竞争。在这个循环结束时，bad {@link @conn}将被设置为null。
                   */
                  log.debug(&quot;Bad connection. Could not roll back&quot;);
                }  
              }
              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);
              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());
              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());
              oldestActiveConnection.invalidate();
              if (log.isDebugEnabled()) {
                log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);
              }
            } else {
              // 上面的条件都不符合，需要循环等待
              try {
                if (!countedWait) {
                  state.hadToWaitCount++;
                  countedWait = true;
                }
                if (log.isDebugEnabled()) {
                  log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);
                }
                long wt = System.currentTimeMillis();
                state.wait(poolTimeToWait);
                state.accumulatedWaitTime += System.currentTimeMillis() - wt;
              } catch (InterruptedException e) {
                break;
              }
            }
          }
        }
        if (conn != null) {
          // ping to server and 检查Connection是否有效，无效的话badConnectionCount加一个
          if (conn.isValid()) {
            if (!conn.getRealConnection().getAutoCommit()) {//我的理解：如果连接不是自动提交，那么连接中可能有未完成的操作，需要手动回滚，如果自动提交，那么这个操作就没有意义了，所以不需要执行
              conn.getRealConnection().rollback();
            }
            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));
            conn.setCheckoutTimestamp(System.currentTimeMillis());
            conn.setLastUsedTimestamp(System.currentTimeMillis());
            state.activeConnections.add(conn);
            state.requestCount++;
            state.accumulatedRequestTime += System.currentTimeMillis() - t;
          } else {
            if (log.isDebugEnabled()) {
              log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;);
            }
            state.badConnectionCount++;
            localBadConnectionCount++;
            conn = null;
            if (localBadConnectionCount &amp;gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {
              if (log.isDebugEnabled()) {
                log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);
              }
              throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);
            }
          }
        }
      }

    }

    if (conn == null) {
      if (log.isDebugEnabled()) {
        log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);
      }
      throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);
    }

    return conn;
  }12

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流程图
&lt;img src=&quot;/Image/mybatis/12.png&quot; alt=&quot;流程图&quot; title=&quot;流程图&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;63-javasqlconnection对象回收&quot;&gt;6.3. java.sql.Connection对象回收&lt;/h2&gt;

&lt;p&gt;通常情况下释放Connection连接使用的是connection.close()，关闭Connection，释放资源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private void test() throws ClassNotFoundException, SQLException
{
    String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;;
    PreparedStatement st = null;
    ResultSet rs = null;

    Connection con = null;
    Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
    try
    {
        con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;);
        st = con.prepareStatement(sql);
        //设置参数
        st.setInt(1, 101);
        st.setInt(2, 0);
        //查询，得出结果集
        rs = st.executeQuery();
        //取数据，省略
        //关闭，释放资源
        con.close();
    }
    catch (SQLException e)
    {
        con.close();
        e.printStackTrace();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;调用了Connection的Close()方法以后，对象资源被释放，对象也就无法使用了，但是使用连接池以后需要放到连接池以后供后续使用，该怎么做呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先使用下面的代码实现一个简单的连接池&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
package com.foo.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Vector;

/**
 * 
 * 一个线程安全的简易连接池实现，此连接池是单例的
 *  putConnection()将Connection添加到连接池中
 *  getConnection()返回一个Connection对象
 */
public class Pool {

    private static Vector&amp;lt;Connection&amp;gt; pool = new Vector&amp;lt;Connection&amp;gt;();
    
    private static int MAX_CONNECTION =100;
    
    private static String DRIVER=&quot;oracle.jdbc.driver.OracleDriver&quot;;
    private static String URL = &quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;;
    private static String USERNAME = &quot;louluan&quot;;
    private static String PASSWROD = &quot;123456&quot;;
    
    static {
        try {
            Class.forName(DRIVER);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * 将一个Connection对象放置到连接池中 
     */
    public static  void putConnection(Connection connection){
        
        synchronized(pool)
        {
            if(pool.size()&amp;lt;MAX_CONNECTION)
            {
                pool.add(connection);       
            }
        }
    }
    
    
    /**
     * 返回一个Connection对象，如果连接池内有元素，则pop出第一个元素；
     * 如果连接池Pool中没有元素，则创建一个connection对象，然后添加到pool中
     * @return Connection
     */
    public static Connection getConnection(){
        Connection connection = null;
        synchronized(pool)
        {
            if(pool.size()&amp;gt;0)
            {
                connection = pool.get(0);
                pool.remove(0);
            }
            else
            {
                connection = createConnection();
                pool.add(connection);
            }
        }
        return connection;
    }
    
    /**
     * 创建一个新的Connection对象
     */
    private static Connection createConnection()
    {
        Connection connection = null;
        try {
            connection = DriverManager.getConnection(URL, USERNAME,PASSWROD);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return connection;
    }
    
}

package com.foo.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Vector;

public class PoolTest
{

    private void test() throws ClassNotFoundException, SQLException
    {
        String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;;
        PreparedStatement st = null;
        ResultSet rs = null;

        Connection con = null;
        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
        try
        {
            con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;);
            st = con.prepareStatement(sql);
            //设置参数
            st.setInt(1, 101);
            st.setInt(2, 0);
            //查询，得出结果集
            rs = st.executeQuery();
            //取数据，省略
            //将不再使用的Connection对象放到连接池中，供以后使用
            Pool.putConnection(con);
        }
        catch (SQLException e)
        {
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上述代码可以实现使用完成一个Connection以后放到Pool中，但是不优雅，通常我们调用的都是Close释放资源，为了保持一致，代理机制就顺理成章的出现了。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;64-代理模式回收connection&quot;&gt;6.4. 代理模式回收Connection&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;使用代理模式&lt;/code&gt;，为真正的Connection对象创建一个代理对象，代理对象所有的方法都是调用相应的真正Connection对象的方法实现。当代理对象执行close()方法时，要特殊处理，不调用真正Connection对象的close()方法，而是将Connection对象添加到连接池中。&lt;/p&gt;

&lt;p&gt;MyBatis的PooledDataSource的PoolState内部维护的对象是PooledConnection类型的对象，而PooledConnection则是对真正的数据库连接java.sql.Connection实例对象的包裹器。&lt;/p&gt;

&lt;p&gt;PooledConnection对象内持有一个真正的数据库连接java.sql.Connection实例对象和一个java.sql.Connection的代理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * @author Clinton Begin
 */
class PooledConnection implements InvocationHandler {

  private static final String CLOSE = &quot;close&quot;;
  private static final Class&amp;lt;?&amp;gt;[] IFACES = new Class&amp;lt;?&amp;gt;[] { Connection.class };

  private final int hashCode;
  private final PooledDataSource dataSource;
  private final Connection realConnection;
  private final Connection proxyConnection;
  private long checkoutTimestamp;
  private long createdTimestamp;
  private long lastUsedTimestamp;
  private int connectionTypeCode;
  private boolean valid;

  /*
   * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in
   *
   * @param connection - the connection that is to be presented as a pooled connection
   * @param dataSource - the dataSource that the connection is from
   */
  public PooledConnection(Connection connection, PooledDataSource dataSource) {
    this.hashCode = connection.hashCode();
    this.realConnection = connection;
    this.dataSource = dataSource;
    this.createdTimestamp = System.currentTimeMillis();
    this.lastUsedTimestamp = System.currentTimeMillis();
    this.valid = true;
    this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PooledConenction实现了InvocationHandler接口，并且，proxyConnection对象也是根据这个它来生成的代理对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们调用此proxyConnection对象上的任何方法时，都会调用PooledConnection对象内invoke()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /*
   * Required for InvocationHandler implementation.
   *
   * @param proxy  - not used
   * @param method - the method to be executed
   * @param args   - the parameters to be passed to the method
   * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])
   */
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    String methodName = method.getName();
    if (CLOSE.hashCode() == methodName.hashCode() &amp;amp;&amp;amp; CLOSE.equals(methodName)) {
      dataSource.pushConnection(this);
      return null;
    } else {
      try {
        if (!Object.class.equals(method.getDeclaringClass())) {
          // issue #579 toString() should never fail
          // throw an SQLException instead of a Runtime
          checkConnection();
        }
        return method.invoke(realConnection, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;7-jndi类型的数据源datasource&quot;&gt;7. JNDI类型的数据源DataSource&lt;/h1&gt;

&lt;h2 id=&quot;71-mybatis-jndi数据源实现&quot;&gt;7.1. Mybatis JNDI数据源实现&lt;/h2&gt;
&lt;p&gt;对于JNDI类型的数据源DataSource的获取就比较简单，MyBatis定义了一个JndiDataSourceFactory工厂来创建通过JNDI形式生成的DataSource。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * @author Clinton Begin
 */
public class JndiDataSourceFactory implements DataSourceFactory {

  public static final String INITIAL_CONTEXT = &quot;initial_context&quot;;
  public static final String DATA_SOURCE = &quot;data_source&quot;;
  public static final String ENV_PREFIX = &quot;env.&quot;;

  private DataSource dataSource;

  @Override
  public void setProperties(Properties properties) {
    try {
      InitialContext initCtx;
      Properties env = getEnvProperties(properties);
      if (env == null) {
        initCtx = new InitialContext();
      } else {
        initCtx = new InitialContext(env);
      }

      if (properties.containsKey(INITIAL_CONTEXT)
          &amp;amp;&amp;amp; properties.containsKey(DATA_SOURCE)) {
        Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));
        dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));
      } else if (properties.containsKey(DATA_SOURCE)) {
        dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));
      }

    } catch (NamingException e) {
      throw new DataSourceException(&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot; + e, e);
    }
  }

  @Override
  public DataSource getDataSource() {
    return dataSource;
  }

  private static Properties getEnvProperties(Properties allProps) {
    final String PREFIX = ENV_PREFIX;
    Properties contextProperties = null;
    for (Entry&amp;lt;Object, Object&amp;gt; entry : allProps.entrySet()) {
      String key = (String) entry.getKey();
      String value = (String) entry.getValue();
      if (key.startsWith(PREFIX)) {
        if (contextProperties == null) {
          contextProperties = new Properties();
        }
        contextProperties.put(key.substring(PREFIX.length()), value);
      }
    }
    return contextProperties;
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;72-为什么使用jndi&quot;&gt;7.2. 为什么使用JNDI&lt;/h2&gt;

&lt;p&gt;没有JNDI的做法存在的问题： &lt;br /&gt;
1、数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改； &lt;br /&gt;
2、数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改； &lt;br /&gt;
3、随着实际使用终端的增加，原配置的连接池参数可能需要调整；&lt;br /&gt;
4、…… &lt;br /&gt;
 解决办法： &lt;br /&gt;
 程序员应该不需要关心“具体的数据库后台是什么？JDBC驱动程序是什么？JDBC URL格式是什么？访问数据库的用户名和口令是什么？”等等这些问题，程序员编写的程序应该没有对 JDBC 驱动程序的引用，没有服务器名称，没有用户名称或口令 —— 甚至没有数据库池或连接管理。而是把这些问题交给J2EE容器来配置和管理，程序员只需要对这些配置和管理进行引用即可。&lt;/p&gt;

&lt;p&gt;由此，就有了JNDI。&lt;/p&gt;

&lt;p&gt;JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luanlouis/article/details/37671851&quot;&gt;原文地址http://blog.csdn.net/luanlouis/article/details/37671851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wenku.baidu.com/view/1ac6a181964bcf84b8d57b21.html&quot;&gt;参考文章https://wenku.baidu.com/view/1ac6a181964bcf84b8d57b21.html&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><summary type="html">对于ORM框架而言，数据源的组织是一个非常重要的一部分，这直接影响到框架的性能问题。 1. MyBatis数据源DataSource分类 2. DataSource的创建过程 2.1. 文件解析 2.2. 创建模式 2.3. 存储 3. DataSource什么时候创建Connection对象 4. UnpooledDataSource 4.1. 创建Connection过程 5. 使用连接池 5.1. 分析 6. PooledDataSource 6.1. 基本原理 6.2. 获取java.sql.Connection对象 6.3. java.sql.Connection对象回收 6.4. 代理模式回收Connection 7. JNDI类型的数据源DataSource 7.1. Mybatis JNDI数据源实现 7.2. 为什么使用JNDI 1. MyBatis数据源DataSource分类 MyBatis数据源实现是在以下四个包中 org.apache.ibatis.datasource org.apache.ibatis.datasource.jndi org.apache.ibatis.datasource.pooled org.apache.ibatis.datasource.unpooled 数据源分类三类 数据源分类说明 UNPOOLED不使用连接池的数据源 POOLED使用连接池的数据源 JNDI使用JNDI实现的数据源 Mybatis 内部定义了java.sql.DataSource接口 UnpooledDataSource 和 PooledDataSource实现了DataSource接口 JNDI类型的数据源DataSource，通过JNDI上下文取值。（What it means？） 2. DataSource的创建过程 Mybatis数据源DataSource的创建发生在Mybatis初始化的过程中。 Mybatis配置 &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; 2.1. 文件解析 DataSource类型通过type决定 type=”POOLED” ：MyBatis会创建PooledDataSource实例 type=”UNPOOLED” ：MyBatis会创建UnpooledDataSource实例 type=”JNDI” ：MyBatis会从JNDI服务上查找DataSource实例，然后返回使用 2.2. 创建模式 Mybatis通过工厂模式来创建DataSource对象，Mybatis定义了org.apache.ibatis.datasource.DataSourceFactory接口，通过getDataSource() 方法返回数据源。 public interface DataSourceFactory { void setProperties(Properties props); DataSource getDataSource(); } 针对三种类型的Type，对应有三种实现工厂 POOLED PooledDataSourceFactory UNPOOLED UnpooledDataSourceFactory 9JNDI JndiDataSourceFactory 2.3. 存储 Mybatis创建DataSource实例以后，放置到Configuration的Environment对象中，供调用。 3. DataSource什么时候创建Connection对象 当需要创建SqlSession对象并且需要执行SQL语句的时候，Mybatis才会调用DataSource对象创建Connection对象。 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;); 上面的代码一直到了sqlSession.selectList(&quot;SELECT * FROM STUDENTS&quot;);才会创建Connection。 protected void openConnection() throws SQLException { if (log.isDebugEnabled()) { log.debug(&quot;Opening JDBC Connection&quot;); } connection = dataSource.getConnection(); if (level != null) { connection.setTransactionIsolation(level.getLevel()); } setDesiredAutoCommit(autoCommmit); } 4. UnpooledDataSource 当DataSource的type属性配置成UNPOOLED，MyBatis首先会实例化一个UnpooledDataSourceFactory工厂实例，然后通过.getDataSource()方法返回一个UnpooledDataSource实例对象引用，我们假定为dataSource。 使用UnpooledDataSource的getConnection(),每调用一次就会产生一个新的Connection实例对象。 @Override public Connection getConnection() throws SQLException { return doGetConnection(username, password); } @Override public Connection getConnection(String username, String password) throws SQLException { return doGetConnection(username, password); } private Connection doGetConnection(String username, String password) throws SQLException { Properties props = new Properties(); if (driverProperties != null) { props.putAll(driverProperties); } if (username != null) { props.setProperty(&quot;user&quot;, username); } if (password != null) { props.setProperty(&quot;password&quot;, password); } return doGetConnection(props); } private Connection doGetConnection(Properties properties) throws SQLException { //初始化驱动 initializeDriver(); //获取连接，获取新的Connection对象 Connection connection = DriverManager.getConnection(url, properties); //配置Connection configureConnection(connection); return connection; } private void configureConnection(Connection conn) throws SQLException { if (autoCommit != null &amp;amp;&amp;amp; autoCommit != conn.getAutoCommit()) { conn.setAutoCommit(autoCommit); } if (defaultTransactionIsolationLevel != null) { conn.setTransactionIsolation(defaultTransactionIsolationLevel); } } 4.1. 创建Connection过程 初始化驱动：判断driver驱动是否已经加载到内存中，如果还没有加载，则会动态地加载driver类，并实例化一个Driver对象，使用DriverManager.registerDriver()方法将其注册到内存中，以供后续使用。 创建Connection对象：使用DriverManager.getConnection()方法创建连接。 配置Connection对象：设置是否自动提交autoCommit和隔离级别isolationLevel。 返回Connection对象。 总结：每调用一次getConnection()都会返回一个新的java.sql.Connection实例。 5. 使用连接池 public static void main(String[] args) throws Exception { String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;; PreparedStatement st = null; ResultSet rs = null; long beforeTimeOffset = -1L; //创建Connection对象前时间 long afterTimeOffset = -1L; //创建Connection对象后时间 long executeTimeOffset = -1L; //创建Connection对象后时间 Connection con = null; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); beforeTimeOffset = new Date().getTime(); System.out.println(&quot;before:\t&quot; + beforeTimeOffset); con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;); afterTimeOffset = new Date().getTime(); System.out.println(&quot;after:\t\t&quot; + afterTimeOffset); System.out.println(&quot;Create Costs:\t\t&quot; + (afterTimeOffset - beforeTimeOffset) + &quot; ms&quot;); st = con.prepareStatement(sql); //设置参数 st.setInt(1, 101); st.setInt(2, 0); //查询，得出结果集 rs = st.executeQuery(); executeTimeOffset = new Date().getTime(); System.out.println(&quot;Exec Costs:\t\t&quot; + (executeTimeOffset - afterTimeOffset) + &quot; ms&quot;); } 执行结果： before：1404363138126 after：1404363138376 Create Costs：250ms Exec Costs：170ms 结果显示：创建一个Connection对象需要250ms，执行sql需要170ms。 5.1. 分析 创建Connection对象代价巨大，仅仅建立通讯连接就消耗了非常多的时间。 对于需要频繁地跟数据库交互的应用程序，可以在创建了Connection对象，并操作完数据库后，可以不释放掉资源，而是将它放到内存中，当下次需要操作数据库时，可以直接从内存中取出Connection对象，不需要再创建了，这样就极大地节省了创建Connection对象的资源消耗。 同时，由于内存也是有限和宝贵的，这又对我们对内存中的Connection对象怎么有效地维护提出了很高的要求。 我们将在内存中存放Connection对象的容器称之为 连接池（Connection Pool）。 6. PooledDataSource 6.1. 基本原理 PooledDataSource将java.sql.Connection对象包裹成PooledConnection对象放到了PoolState类型的容器中维护。 MyBatis将连接池中的PooledConnection分为两种状态： 空闲状态（idle）和活动状态(active)，这两种状态的PooledConnection对象分别被存储到PoolState容器内的idleConnections和activeConnections两个List集合中 idleConnections:空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。 activeConnections:活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象,如果没有，则看此集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。(先获取空闲的，没有空闲的而且活动的未满，就创造一个新的，放到活动中) PoolState连接池的大致结构： ![连接池](/Image/mybatis/11.png ‘’) 6.2. 获取java.sql.Connection对象 获取Connection的实现代码： @Override public Connection getConnection() throws SQLException { return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection(); } @Override public Connection getConnection(String username, String password) throws SQLException { return popConnection(username, password).getProxyConnection(); } 上面的popConnection()会从连接池返回一个PooledConnection对象，然后调用getProxyConnection()获取最终的Connection对象。（getProxyConnection()稍后在介绍） popConnection()方法到底做了什么 先看是否有空闲(idle)状态下的PooledConnection对象，如果有，就直接返回一个可用的PooledConnection对象；否则进行第2步。 查看活动状态的PooledConnection池activeConnections是否已满；如果没有满，则创建一个新的PooledConnection对象，然后放到activeConnections池中，然后返回此PooledConnection对象；否则进行第三步； 看最先进入activeConnections池中的PooledConnection对象是否已经过期：如果已经过期，从activeConnections池中移除此对象，然后创建一个新的PooledConnection对象，添加到activeConnections中，然后将此对象返回；否则进行第4步。 线程等待，循环2步 private final PoolState state = new PoolState(this); private final UnpooledDataSource dataSource; private PooledConnection popConnection(String username, String password) throws SQLException { boolean countedWait = false; PooledConnection conn = null; long t = System.currentTimeMillis(); int localBadConnectionCount = 0; while (conn == null) { synchronized (state) { if (!state.idleConnections.isEmpty()) { // idelConnections中有空闲的Connection对象，直接取出使用 conn = state.idleConnections.remove(0); if (log.isDebugEnabled()) { log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;); } } else { // idelConnections中没有空闲的Connection对象，但是activeConnections还没有达到最大活动上限 if (state.activeConnections.size() &amp;lt; poolMaximumActiveConnections) { // 创建一个新的Connection conn = new PooledConnection(dataSource.getConnection(), this); if (log.isDebugEnabled()) { log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;); } } else { // activeConnections已经达到最大活动上限，不能创建新的 // 获取最老的活动连接，检查超时 PooledConnection oldestActiveConnection = state.activeConnections.get(0); long longestCheckoutTime = oldestActiveConnection.getCheckoutTime(); if (longestCheckoutTime &amp;gt; poolMaximumCheckoutTime) { // 最老的活动连接判定超时 state.claimedOverdueConnectionCount++; state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime; state.accumulatedCheckoutTime += longestCheckoutTime; state.activeConnections.remove(oldestActiveConnection); if (!oldestActiveConnection.getRealConnection().getAutoCommit()) { try { oldestActiveConnection.getRealConnection().rollback(); } catch (SQLException e) { /* 只需为debug记录一条消息，并继续执行下面的语句，就像没有发生任何事情一样。 用一个新的Pooled连接包装the bad connection，这将有助于不影响当前的执行线程， 并给当前线程一个机会，使其能够与另一个valid/good database connection一起参加下一个竞争。在这个循环结束时，bad {@link @conn}将被设置为null。 */ log.debug(&quot;Bad connection. Could not roll back&quot;); } } conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this); conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp()); conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp()); oldestActiveConnection.invalidate(); if (log.isDebugEnabled()) { log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;); } } else { // 上面的条件都不符合，需要循环等待 try { if (!countedWait) { state.hadToWaitCount++; countedWait = true; } if (log.isDebugEnabled()) { log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;); } long wt = System.currentTimeMillis(); state.wait(poolTimeToWait); state.accumulatedWaitTime += System.currentTimeMillis() - wt; } catch (InterruptedException e) { break; } } } } if (conn != null) { // ping to server and 检查Connection是否有效，无效的话badConnectionCount加一个 if (conn.isValid()) { if (!conn.getRealConnection().getAutoCommit()) {//我的理解：如果连接不是自动提交，那么连接中可能有未完成的操作，需要手动回滚，如果自动提交，那么这个操作就没有意义了，所以不需要执行 conn.getRealConnection().rollback(); } conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password)); conn.setCheckoutTimestamp(System.currentTimeMillis()); conn.setLastUsedTimestamp(System.currentTimeMillis()); state.activeConnections.add(conn); state.requestCount++; state.accumulatedRequestTime += System.currentTimeMillis() - t; } else { if (log.isDebugEnabled()) { log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;); } state.badConnectionCount++; localBadConnectionCount++; conn = null; if (localBadConnectionCount &amp;gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) { if (log.isDebugEnabled()) { log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;); } throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;); } } } } } if (conn == null) { if (log.isDebugEnabled()) { log.debug(&quot;PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.&quot;); } throw new SQLException(&quot;PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.&quot;); } return conn; }12 流程图 6.3. java.sql.Connection对象回收 通常情况下释放Connection连接使用的是connection.close()，关闭Connection，释放资源。 private void test() throws ClassNotFoundException, SQLException { String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;; PreparedStatement st = null; ResultSet rs = null; Connection con = null; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); try { con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;); st = con.prepareStatement(sql); //设置参数 st.setInt(1, 101); st.setInt(2, 0); //查询，得出结果集 rs = st.executeQuery(); //取数据，省略 //关闭，释放资源 con.close(); } catch (SQLException e) { con.close(); e.printStackTrace(); } } 调用了Connection的Close()方法以后，对象资源被释放，对象也就无法使用了，但是使用连接池以后需要放到连接池以后供后续使用，该怎么做呢？ 先使用下面的代码实现一个简单的连接池 package com.foo.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Vector; /** * * 一个线程安全的简易连接池实现，此连接池是单例的 * putConnection()将Connection添加到连接池中 * getConnection()返回一个Connection对象 */ public class Pool { private static Vector&amp;lt;Connection&amp;gt; pool = new Vector&amp;lt;Connection&amp;gt;(); private static int MAX_CONNECTION =100; private static String DRIVER=&quot;oracle.jdbc.driver.OracleDriver&quot;; private static String URL = &quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;; private static String USERNAME = &quot;louluan&quot;; private static String PASSWROD = &quot;123456&quot;; static { try { Class.forName(DRIVER); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 将一个Connection对象放置到连接池中 */ public static void putConnection(Connection connection){ synchronized(pool) { if(pool.size()&amp;lt;MAX_CONNECTION) { pool.add(connection); } } } /** * 返回一个Connection对象，如果连接池内有元素，则pop出第一个元素； * 如果连接池Pool中没有元素，则创建一个connection对象，然后添加到pool中 * @return Connection */ public static Connection getConnection(){ Connection connection = null; synchronized(pool) { if(pool.size()&amp;gt;0) { connection = pool.get(0); pool.remove(0); } else { connection = createConnection(); pool.add(connection); } } return connection; } /** * 创建一个新的Connection对象 */ private static Connection createConnection() { Connection connection = null; try { connection = DriverManager.getConnection(URL, USERNAME,PASSWROD); } catch (SQLException e) { e.printStackTrace(); } return connection; } } package com.foo.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Vector; public class PoolTest { private void test() throws ClassNotFoundException, SQLException { String sql = &quot;select * from hr.employees where employee_id &amp;lt; ? and employee_id &amp;gt;= ?&quot;; PreparedStatement st = null; ResultSet rs = null; Connection con = null; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); try { con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:xe&quot;, &quot;louluan&quot;, &quot;123456&quot;); st = con.prepareStatement(sql); //设置参数 st.setInt(1, 101); st.setInt(2, 0); //查询，得出结果集 rs = st.executeQuery(); //取数据，省略 //将不再使用的Connection对象放到连接池中，供以后使用 Pool.putConnection(con); } catch (SQLException e) { e.printStackTrace(); } } } 上述代码可以实现使用完成一个Connection以后放到Pool中，但是不优雅，通常我们调用的都是Close释放资源，为了保持一致，代理机制就顺理成章的出现了。 6.4. 代理模式回收Connection 使用代理模式，为真正的Connection对象创建一个代理对象，代理对象所有的方法都是调用相应的真正Connection对象的方法实现。当代理对象执行close()方法时，要特殊处理，不调用真正Connection对象的close()方法，而是将Connection对象添加到连接池中。 MyBatis的PooledDataSource的PoolState内部维护的对象是PooledConnection类型的对象，而PooledConnection则是对真正的数据库连接java.sql.Connection实例对象的包裹器。 PooledConnection对象内持有一个真正的数据库连接java.sql.Connection实例对象和一个java.sql.Connection的代理. /** * @author Clinton Begin */ class PooledConnection implements InvocationHandler { private static final String CLOSE = &quot;close&quot;; private static final Class&amp;lt;?&amp;gt;[] IFACES = new Class&amp;lt;?&amp;gt;[] { Connection.class }; private final int hashCode; private final PooledDataSource dataSource; private final Connection realConnection; private final Connection proxyConnection; private long checkoutTimestamp; private long createdTimestamp; private long lastUsedTimestamp; private int connectionTypeCode; private boolean valid; /* * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in * * @param connection - the connection that is to be presented as a pooled connection * @param dataSource - the dataSource that the connection is from */ public PooledConnection(Connection connection, PooledDataSource dataSource) { this.hashCode = connection.hashCode(); this.realConnection = connection; this.dataSource = dataSource; this.createdTimestamp = System.currentTimeMillis(); this.lastUsedTimestamp = System.currentTimeMillis(); this.valid = true; this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this); } ... } PooledConenction实现了InvocationHandler接口，并且，proxyConnection对象也是根据这个它来生成的代理对象 this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this); 当我们调用此proxyConnection对象上的任何方法时，都会调用PooledConnection对象内invoke()方法。 /* * Required for InvocationHandler implementation. * * @param proxy - not used * @param method - the method to be executed * @param args - the parameters to be passed to the method * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[]) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); if (CLOSE.hashCode() == methodName.hashCode() &amp;amp;&amp;amp; CLOSE.equals(methodName)) { dataSource.pushConnection(this); return null; } else { try { if (!Object.class.equals(method.getDeclaringClass())) { // issue #579 toString() should never fail // throw an SQLException instead of a Runtime checkConnection(); } return method.invoke(realConnection, args); } catch (Throwable t) { throw ExceptionUtil.unwrapThrowable(t); } } } 7. JNDI类型的数据源DataSource 7.1. Mybatis JNDI数据源实现 对于JNDI类型的数据源DataSource的获取就比较简单，MyBatis定义了一个JndiDataSourceFactory工厂来创建通过JNDI形式生成的DataSource。 /** * @author Clinton Begin */ public class JndiDataSourceFactory implements DataSourceFactory { public static final String INITIAL_CONTEXT = &quot;initial_context&quot;; public static final String DATA_SOURCE = &quot;data_source&quot;; public static final String ENV_PREFIX = &quot;env.&quot;; private DataSource dataSource; @Override public void setProperties(Properties properties) { try { InitialContext initCtx; Properties env = getEnvProperties(properties); if (env == null) { initCtx = new InitialContext(); } else { initCtx = new InitialContext(env); } if (properties.containsKey(INITIAL_CONTEXT) &amp;amp;&amp;amp; properties.containsKey(DATA_SOURCE)) { Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT)); dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE)); } else if (properties.containsKey(DATA_SOURCE)) { dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE)); } } catch (NamingException e) { throw new DataSourceException(&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot; + e, e); } } @Override public DataSource getDataSource() { return dataSource; } private static Properties getEnvProperties(Properties allProps) { final String PREFIX = ENV_PREFIX; Properties contextProperties = null; for (Entry&amp;lt;Object, Object&amp;gt; entry : allProps.entrySet()) { String key = (String) entry.getKey(); String value = (String) entry.getValue(); if (key.startsWith(PREFIX)) { if (contextProperties == null) { contextProperties = new Properties(); } contextProperties.put(key.substring(PREFIX.length()), value); } } return contextProperties; } } 7.2. 为什么使用JNDI 没有JNDI的做法存在的问题： 1、数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改； 2、数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改； 3、随着实际使用终端的增加，原配置的连接池参数可能需要调整； 4、…… 解决办法： 程序员应该不需要关心“具体的数据库后台是什么？JDBC驱动程序是什么？JDBC URL格式是什么？访问数据库的用户名和口令是什么？”等等这些问题，程序员编写的程序应该没有对 JDBC 驱动程序的引用，没有服务器名称，没有用户名称或口令 —— 甚至没有数据库池或连接管理。而是把这些问题交给J2EE容器来配置和管理，程序员只需要对这些配置和管理进行引用即可。 由此，就有了JNDI。 JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。 原文地址http://blog.csdn.net/luanlouis/article/details/37671851 参考文章https://wenku.baidu.com/view/1ac6a181964bcf84b8d57b21.html</summary></entry></feed>