<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ProgramNote/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ProgramNote/" rel="alternate" type="text/html" hreflang="zh" /><updated>2018-01-04T12:01:04+08:00</updated><id>http://localhost:4000/ProgramNote/</id><title type="html">lipeng’s blog</title><subtitle>lipeng's Blog
</subtitle><author><name>lipeng</name><email>lipeng3g@gmail.com</email></author><entry><title type="html">Hashcode和equals</title><link href="http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals.html" rel="alternate" type="text/html" title="Hashcode和equals" /><published>2018-01-04T10:46:08+08:00</published><updated>2018-01-04T10:46:08+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/04/Hashcode%E5%92%8Cequals.html">&lt;h1 id=&quot;问题&quot;&gt;问题&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;两个对象的Hashcode相同，相象是否相相等？equals呢？ 为了解决这个问题，先要了解一下`java.lang.Object`的`Hashcode`和`equals`方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;equals方法详解&quot;&gt;equals()方法详解&lt;/h1&gt;
&lt;p&gt;先看java.lang.Object的默认实现，部分内容进行了翻译。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   /**
     * 表示某个其他对象是否“等于”这一个。
     * &amp;lt;p&amp;gt;
     * equals方法在非null对象引用上实现等价关系
     * 自反: 对于任何非null的引用值 x，x.equals(x) 应该返回 true。
     * 对称: 对任何非空的引用值 x 和 y, 如果 y.equals(x) 返回true， 那么x.equals(y)必须返回true
     * 传递: 对任何非空的引用值 x, y, z, 如果 x.equals(y)返回 true ，y.equals(z)返回 true, 那么 x.equals(z)也必须返回true
     * 一致: 如果x.equals(y)返回是true，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是true。
     * 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。
     * &amp;lt;p&amp;gt;
     * Object类的equals方法实现了对象上最可能的等价关系;也就是说，对于任何非null的引用值x和y，当且仅当x和y引用同一个对象x == y时返回 true。
     * &amp;lt;p&amp;gt;
     * 请注意，无论何时重写此方法，通常都必须重写hashCode方法，以维护hashCode方法的一般约定，该方法声明相等的对象必须具有相同的哈希码。
     *
     * @param   obj   the reference object with which to compare.
     * @return  true} if this object is the same as the obj
     *          argument; false} otherwise.
     * @see     #hashCode()
     * @see     java.util.HashMap
     */
    public boolean equals(Object obj) {
        return (this == obj);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，非空的对象只有引用地址相同的情况下，equals 才会返回 true，上面说的很清晰 “ == “表示的就是引用地址的比较。&lt;/p&gt;

&lt;p&gt;但是，很多时候，equals方法会被重写，例如 java.lang.String&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String) anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                            return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java.lang.String的equals方法不是进行引用地址比较，而是内容比较。&lt;/p&gt;

&lt;p&gt;下面举个形象的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class User {
    private int id;
    private String name;
    private String password;

    &amp;lt;get and set&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    User user1 = new User();
    User user2 = new User();
    assert user1.equals(user2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果直接运行上面的内容，会显示异常java.lang.AssertionError，表示两个对象不一样，因为这个时候equals方法是最初的java.lang.Object的 “==” 比较。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class User {
    private int id;
    private String name;
    private String password;

    &amp;lt;get and set&amp;gt;

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        User user = (User) o;
        return id == user.id &amp;amp;&amp;amp;
                Objects.equals(name, user.name) &amp;amp;&amp;amp;
                Objects.equals(password, user.password);
    }

    @Override
    public int hashCode() {

        return Objects.hash(id, name, password);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面重写了 equals方法，此时再次进行比较的时候，从引用值比较改成了内容比较，此时返回的就是true了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是，上面同时重写了 equals 和 Hashcode 方法，在这个简单对象中不重写可能不会有太大的问题，但是后面再集合中，如果不重写可能会导致意想不到的问题发生。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;hashcode&quot;&gt;hashCode()&lt;/h1&gt;
&lt;p&gt;先看java.lang.Object的实现，这里native表示是本地方法，有java以外的语言实现，重点看javaDoc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
     * 返回该对象的哈希码值。 这种方法支持哈希表，如由{@link java.util.HashMap}提供的哈希表。
     * &amp;lt;p&amp;gt;
     * hashCode通常情况下遵守的合约是：
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;只要在Java应用程序的执行过程中多次调用同一个对象，{@code hashCode}方法必须始终返回相同的整数，前提是在对象上的比较中没有使用任何信息被修改。 从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。
     * &amp;lt;li&amp;gt;如果两个对象根据equals方法相等，则在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。
     * &amp;lt;li&amp;gt;如果两个对象根据equals（Object）方法不相等，则不要求对两个对象中的每一个调用hashCode方法都必须产生不同的整数结果。 但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。
     * &amp;lt;/ul&amp;gt;
     * &amp;lt;p&amp;gt;
     * 尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。 （这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。）
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
    public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，String等对象类型会重写这些方法，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    public int hashCode() {
        int h = hash;
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单理解就是 String 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&lt;/code&gt;重写了hashcode 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请注意，下面只是简单介绍集合的存储原理，关于地址值的部分不准备，这部分等我看完jdk8的代码以后再修改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要弄明白hashCode的作用，必须要先知道Java中的集合。　　 
总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？&lt;/p&gt;

&lt;p&gt;这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 &lt;br /&gt;
于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，这个地址上的key值就是hashcode值，而value值则记录了这个对象存储的真是地址。&lt;br /&gt;
这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。&lt;/p&gt;

&lt;p&gt;所以，Java对于eqauls方法和hashCode方法是这样规定的：
1.如果两个对象相同，那么它们的hashCode值一定要相同；
2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。  如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。
3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。

在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，Hashcode()方法根据String类的重写代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;hashsethashmaphashtable与hashcode和equals的密切关系&quot;&gt;Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系&lt;/h1&gt;

&lt;p&gt;Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么Hashset、Hashmap、Hashtable中的存储操作是根据什么原理来存取对象的呢？&lt;/p&gt;

&lt;p&gt;以HashSet为例，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是：&lt;br /&gt;
1.判断两个对象的hashCode是否相等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果不相等，认为两个对象也不相等，完毕
如果相等，转入2 (这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.判断两个对象用equals运算是否相等&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果不相等，认为两个对象也不相等
如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。&lt;/p&gt;

&lt;h1 id=&quot;答案&quot;&gt;答案&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;两个对象的hashcode相同，对象不一定相等，如果hashcode一致，比较equals，equals返回true，可以判定两者相等&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">问题 两个对象的Hashcode相同，相象是否相相等？equals呢？ 为了解决这个问题，先要了解一下`java.lang.Object`的`Hashcode`和`equals`方法。 equals()方法详解 先看java.lang.Object的默认实现，部分内容进行了翻译。 /** * 表示某个其他对象是否“等于”这一个。 * &amp;lt;p&amp;gt; * equals方法在非null对象引用上实现等价关系 * 自反: 对于任何非null的引用值 x，x.equals(x) 应该返回 true。 * 对称: 对任何非空的引用值 x 和 y, 如果 y.equals(x) 返回true， 那么x.equals(y)必须返回true * 传递: 对任何非空的引用值 x, y, z, 如果 x.equals(y)返回 true ，y.equals(z)返回 true, 那么 x.equals(z)也必须返回true * 一致: 如果x.equals(y)返回是true，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是true。 * 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 * &amp;lt;p&amp;gt; * Object类的equals方法实现了对象上最可能的等价关系;也就是说，对于任何非null的引用值x和y，当且仅当x和y引用同一个对象x == y时返回 true。 * &amp;lt;p&amp;gt; * 请注意，无论何时重写此方法，通常都必须重写hashCode方法，以维护hashCode方法的一般约定，该方法声明相等的对象必须具有相同的哈希码。 * * @param obj the reference object with which to compare. * @return true} if this object is the same as the obj * argument; false} otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) { return (this == obj); } 通常情况下，非空的对象只有引用地址相同的情况下，equals 才会返回 true，上面说的很清晰 “ == “表示的就是引用地址的比较。 但是，很多时候，equals方法会被重写，例如 java.lang.String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } java.lang.String的equals方法不是进行引用地址比较，而是内容比较。 下面举个形象的例子 public class User { private int id; private String name; private String password; &amp;lt;get and set&amp;gt; } 测试方法 User user1 = new User(); User user2 = new User(); assert user1.equals(user2); 如果直接运行上面的内容，会显示异常java.lang.AssertionError，表示两个对象不一样，因为这个时候equals方法是最初的java.lang.Object的 “==” 比较。 public class User { private int id; private String name; private String password; &amp;lt;get and set&amp;gt; @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } User user = (User) o; return id == user.id &amp;amp;&amp;amp; Objects.equals(name, user.name) &amp;amp;&amp;amp; Objects.equals(password, user.password); } @Override public int hashCode() { return Objects.hash(id, name, password); } } 上面重写了 equals方法，此时再次进行比较的时候，从引用值比较改成了内容比较，此时返回的就是true了。 需要注意的是，上面同时重写了 equals 和 Hashcode 方法，在这个简单对象中不重写可能不会有太大的问题，但是后面再集合中，如果不重写可能会导致意想不到的问题发生。 hashCode() 先看java.lang.Object的实现，这里native表示是本地方法，有java以外的语言实现，重点看javaDoc /** * 返回该对象的哈希码值。 这种方法支持哈希表，如由{@link java.util.HashMap}提供的哈希表。 * &amp;lt;p&amp;gt; * hashCode通常情况下遵守的合约是： * &amp;lt;ul&amp;gt; * &amp;lt;li&amp;gt;只要在Java应用程序的执行过程中多次调用同一个对象，{@code hashCode}方法必须始终返回相同的整数，前提是在对象上的比较中没有使用任何信息被修改。 从应用程序的一次执行到同一应用程序的另一次执行，此整数不必保持一致。 * &amp;lt;li&amp;gt;如果两个对象根据equals方法相等，则在两个对象的每一个上调用hashCode方法必须产生相同的整数结果。 * &amp;lt;li&amp;gt;如果两个对象根据equals（Object）方法不相等，则不要求对两个对象中的每一个调用hashCode方法都必须产生不同的整数结果。 但是，程序员应该知道，为不相等的对象生成不同的整数结果可以提高散列表的性能。 * &amp;lt;/ul&amp;gt; * &amp;lt;p&amp;gt; * 尽可能多地合理实用，由类Object定义的hashCode方法确实为不同的对象返回不同的整数。 （这通常通过将对象的内部地址转换为整数来实现，但JavaTM编程语言不需要此实现技术。） * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */ public native int hashCode(); 通常情况下，String等对象类型会重写这些方法，例如 public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 简单理解就是 String 使用 s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]重写了hashcode 的值。 请注意，下面只是简单介绍集合的存储原理，关于地址值的部分不准备，这部分等我看完jdk8的代码以后再修改 想要弄明白hashCode的作用，必须要先知道Java中的集合。　　 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，这个地址上的key值就是hashcode值，而value值则记录了这个对象存储的真是地址。 这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 所以，Java对于eqauls方法和hashCode方法是这样规定的： 1.如果两个对象相同，那么它们的hashCode值一定要相同； 2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。 如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。 3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。 换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 在object类中，hashcode()方法是本地方法，返回的是对象的地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，Hashcode()方法根据String类的重写代码的分析，也可知道hashcode()返回结果也会相等。以此类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。 Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系 Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么Hashset、Hashmap、Hashtable中的存储操作是根据什么原理来存取对象的呢？ 以HashSet为例，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是： 1.判断两个对象的hashCode是否相等 如果不相等，认为两个对象也不相等，完毕 如果相等，转入2 (这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。） 2.判断两个对象用equals运算是否相等 如果不相等，认为两个对象也不相等 如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键） 为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。 答案 两个对象的hashcode相同，对象不一定相等，如果hashcode一致，比较equals，equals返回true，可以判定两者相等</summary></entry><entry><title type="html">Java中hashcode和一致性哈希算法</title><link href="http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html" rel="alternate" type="text/html" title="Java中hashcode和一致性哈希算法" /><published>2018-01-03T17:13:29+08:00</published><updated>2018-01-03T17:13:29+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/03/Java%E4%B8%ADHashcode%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html">&lt;h1 id=&quot;哈希算法&quot;&gt;哈希算法&lt;/h1&gt;
&lt;h2 id=&quot;什么是哈希算法&quot;&gt;什么是哈希算法&lt;/h2&gt;
&lt;p&gt;哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。&lt;/p&gt;

&lt;h2 id=&quot;哈希算法的特点&quot;&gt;哈希算法的特点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;哈希值是二进制值&lt;/li&gt;
  &lt;li&gt;哈希值具有一定的唯一性&lt;/li&gt;
  &lt;li&gt;哈希值极其紧凑&lt;/li&gt;
  &lt;li&gt;要找到生成同一个哈希值的两个不同输入，在一定时间范围内容是不可能的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正因为哈希值的这些特点，使得哈希算法应用在加密领域成为可能。哈希算法在加密领域的应用，源于哈希算法的不可逆性，对于用户输入的密码，通过哈希算法可以得到一个哈希值。并且，同一个密码，生成的哈希值总是相等的。这样，服务器就可以在不知道用户输入的密码的情况下，判断用户输入的密码是否正确。&lt;/p&gt;

&lt;h2 id=&quot;哈希表&quot;&gt;哈希表&lt;/h2&gt;
&lt;p&gt;哈希表是一种数据机构。&lt;br /&gt;
哈希表根据关键字（key），生成关键字的哈希值，然后通过哈希值映射关键字对应的值。哈希表存储了多余的key（我们本可以只存储值的），是一种用空间换时间的做法。在内存足够的情况下，这种“空间换时间”的做法是值得的。&lt;br /&gt;
哈希表的产生，灵感来源于数组。我们知道，数组号称查询效率最高的数据结构，因为不管数组的容量多大，查询的时间复杂度都是O(1)。如果所有的key都是不重复的整数，那么这就完美了，不需要新增一张哈希表，来做关键字（key）到值（value）的映射。但是，如果key是字符串，情况就不一样了。我们必须要来建一张哈希表，进行映射。数据库索引的原理，其实和哈希表是相同的。&lt;br /&gt;
数据库索引也是用空间换时间的做法。&lt;/p&gt;

&lt;h1 id=&quot;java应用&quot;&gt;Java应用&lt;/h1&gt;
&lt;h2 id=&quot;hashmap应用&quot;&gt;HashMap应用&lt;/h2&gt;

&lt;p&gt;java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道这个元素是否已经存在。&lt;br /&gt;
从实现上来说，java是借助hashcode()方法和equals()方法来实现判断元素是否已经存在的。当我们向HashMap中插入元素A时，&lt;strong&gt;首先&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;调用hashcode()方法，判断元素A在容器中是否已经存在&lt;/code&gt;。如果A元素的hashcode值在HashMap中不存在，则直接插入。&lt;strong&gt;否则&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;接着调用equals()方法，判断A元素在容器中是否已经存在&lt;/code&gt;。&lt;br /&gt;
&lt;strong&gt;hashcode()的时间复杂度为O(1)&lt;/strong&gt;，&lt;strong&gt;equals()方法的时间复杂度为O(m)&lt;/strong&gt;，整体的时间复杂度就是：&lt;strong&gt;O(1) + O(m)&lt;/strong&gt;。  其中，m是桶的深度。&lt;br /&gt;
桶的深度是一个什么概念呢，桶的深度是指具有相同hashcode值得元素的个数，也就是发生哈希碰撞的元素的个数。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;一个好的哈希算法应该尽量减少哈希碰撞的次数。&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关于hashmap中详细的计算方式以后在集合中慢慢学习。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;string应用&quot;&gt;String应用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
     * 返回该字符串的哈希代码。 
     * 哈希值的计算方式 ： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
     * s[i]代表字符串数组中的元素
     * 如果是空字符串，默认hash值是0.
     *
     * @return  a hash code value for this object.
     */
    public int hashCode() {
        int h = hash;
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    /**
     * 将此字符串与指定的对象进行比较。只有参数不是 null，并且和该对象字符序列相同的时候结果是true
     *
     * @param  anObject
     *         The object to compare this {@code String} against
     *
     * @return  {@code true} if the given object represents a {@code String}
     *          equivalent to this string, {@code false} otherwise
     *
     * @see  #compareTo(String)
     * @see  #equalsIgnoreCase(String)
     */
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;一致性哈希算法&quot;&gt;一致性哈希算法&lt;/h1&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;多台机器需要协同作业，保证数据在分布式环境下的一致性，就成为了亟待解决的问题。一致性哈希算法，就是为了解决多台机器，在动态增删的情况下，能够最大限度地保证信息的一致性。&lt;/p&gt;

&lt;p&gt;一致性哈希算法是一种分布式哈希算法，设计目标是为了解决互联网中的热点(Hot spot)问题。&lt;/p&gt;
&lt;h2 id=&quot;参考标准&quot;&gt;参考标准&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;平衡性(Balance)
    &lt;ul&gt;
      &lt;li&gt;平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;单调性(Monotonicity)
    &lt;ul&gt;
      &lt;li&gt;单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分散性(Spread)
    &lt;ul&gt;
      &lt;li&gt;在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;负载(Load)
    &lt;ul&gt;
      &lt;li&gt;负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;

&lt;h3 id=&quot;环形hash空间&quot;&gt;环形Hash空间&lt;/h3&gt;
&lt;p&gt;按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_001.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;把数据通过一定的hash算法处理后映射到环上&quot;&gt;把数据通过一定的hash算法处理后映射到环上&lt;/h3&gt;
&lt;p&gt;现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_002.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hash(object1) = key1；
Hash(object2) = key2；
Hash(object3) = key3；
Hash(object4) = key4；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;将机器通过hash算法映射到环上&quot;&gt;将机器通过hash算法映射到环上&lt;/h3&gt;
&lt;p&gt;在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。
假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：  &lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_003.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hash(NODE1) = KEY1;
Hash(NODE2) = KEY2;
Hash(NODE3) = KEY3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。&lt;/p&gt;

&lt;h3 id=&quot;机器的删除与添加&quot;&gt;机器的删除与添加&lt;/h3&gt;
&lt;p&gt;普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。&lt;/p&gt;
&lt;h4 id=&quot;节点机器的删除&quot;&gt;节点（机器）的删除&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：   ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_004.jpg &quot;title&quot;)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;节点机器的添加&quot;&gt;节点（机器）的添加&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：   ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_005.jpg &quot;title&quot;)  
                                                          
通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;平衡性&quot;&gt;平衡性&lt;/h3&gt;
&lt;p&gt;根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ）,实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_006.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据上图可知对象的映射关系：object1-&amp;gt;NODE1-1，object2-&amp;gt;NODE1-2，object3-&amp;gt;NODE3-2，object4-&amp;gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：&lt;br /&gt;
&lt;img src=&quot;http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_007.jpg&quot; alt=&quot;Alt text&quot; title=&quot;title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：
Hash(“192.168.1.100”);
引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：
Hash(“192.168.1.100#1”); // NODE1-1
Hash(“192.168.1.100#2”); // NODE1-2&lt;/p&gt;

&lt;h2 id=&quot;java实现&quot;&gt;Java实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class ConsistentHash&amp;lt;T&amp;gt; {
    private final HashFunction hashFunction;
    private final int numberOfReplicas;// 节点的复制因子,实际节点个数 *  numberOfReplicas =
                                        // 虚拟节点个数
    private final SortedMap&amp;lt;Long, T&amp;gt; circle = new TreeMap&amp;lt;Long, T&amp;gt;();// 存储虚拟节点的hash值到真实节点的映射

    public ConsistentHash(HashFunction hashFunction, int numberOfReplicas,
            Collection&amp;lt;T&amp;gt; nodes) {
        this.hashFunction = hashFunction;
        this.numberOfReplicas = numberOfReplicas;
        for (T node : nodes)
            add(node);
    }

    public void add(T node) {
        for (int i = 0; i &amp;lt; numberOfReplicas; i++)
            // 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点
            /*
             * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node
             * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上
             */
            circle.put(hashFunction.hash(node.toString() + i), node);
    }

    public void remove(T node) {
        for (int i = 0; i &amp;lt; numberOfReplicas; i++)
            circle.remove(hashFunction.hash(node.toString() + i));
    }

    /*
     * 获得一个最近的顺时针节点,根据给定的key 取Hash
     * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点
     * 再从实际节点中取得 数据
     */
    public T get(Object key) {
        if (circle.isEmpty())
            return null;
        long hash = hashFunction.hash((String) key);// node 用String来表示,获得node在哈希环中的hashCode
        if (!circle.containsKey(hash)) {//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器
            SortedMap&amp;lt;Long, T&amp;gt; tailMap = circle.tailMap(hash);
            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
        }
        return circle.get(hash);
    }

    public long getSize() {
        return circle.size();
    }
    
    /*
     * 查看MD5算法生成的hashCode值---表示整个哈希环中各个虚拟节点位置
     */
    public void testBalance(){
        Set&amp;lt;Long&amp;gt; sets  = circle.keySet();//获得TreeMap中所有的Key
        SortedSet&amp;lt;Long&amp;gt; sortedSets= new TreeSet&amp;lt;Long&amp;gt;(sets);//将获得的Key集合排序
        for(Long hashCode : sortedSets){
            System.out.println(hashCode);
        }
        
        System.out.println(&quot;----each location 's distance are follows: ----&quot;);
        /*
         * 查看用MD5算法生成的long hashCode 相邻两个hashCode的差值
         */
        Iterator&amp;lt;Long&amp;gt; it = sortedSets.iterator();
        Iterator&amp;lt;Long&amp;gt; it2 = sortedSets.iterator();
        if(it2.hasNext())
            it2.next();
        long keyPre, keyAfter;
        while(it.hasNext() &amp;amp;&amp;amp; it2.hasNext()){
            keyPre = it.next();
            keyAfter = it2.next();
            System.out.println(keyAfter - keyPre);
        }
    }
    
    public static void main(String[] args) {
        Set&amp;lt;String&amp;gt; nodes = new HashSet&amp;lt;String&amp;gt;();
        nodes.add(&quot;A&quot;);
        nodes.add(&quot;B&quot;);
        nodes.add(&quot;C&quot;);
        
        ConsistentHash&amp;lt;String&amp;gt; consistentHash = new ConsistentHash&amp;lt;String&amp;gt;(new HashFunction(), 2, nodes);
        consistentHash.add(&quot;D&quot;);
        
        System.out.println(&quot;hash circle size: &quot; + consistentHash.getSize());
        System.out.println(&quot;location of each node are follows: &quot;);
        consistentHash.testBalance();
    }
    
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">哈希算法 什么是哈希算法 哈希算法可以将任意长度的二进制值映射为较短的，固定长度的二进制值。我们把这个二进制值成为哈希值。 哈希算法的特点 哈希值是二进制值 哈希值具有一定的唯一性 哈希值极其紧凑 要找到生成同一个哈希值的两个不同输入，在一定时间范围内容是不可能的 正因为哈希值的这些特点，使得哈希算法应用在加密领域成为可能。哈希算法在加密领域的应用，源于哈希算法的不可逆性，对于用户输入的密码，通过哈希算法可以得到一个哈希值。并且，同一个密码，生成的哈希值总是相等的。这样，服务器就可以在不知道用户输入的密码的情况下，判断用户输入的密码是否正确。 哈希表 哈希表是一种数据机构。 哈希表根据关键字（key），生成关键字的哈希值，然后通过哈希值映射关键字对应的值。哈希表存储了多余的key（我们本可以只存储值的），是一种用空间换时间的做法。在内存足够的情况下，这种“空间换时间”的做法是值得的。 哈希表的产生，灵感来源于数组。我们知道，数组号称查询效率最高的数据结构，因为不管数组的容量多大，查询的时间复杂度都是O(1)。如果所有的key都是不重复的整数，那么这就完美了，不需要新增一张哈希表，来做关键字（key）到值（value）的映射。但是，如果key是字符串，情况就不一样了。我们必须要来建一张哈希表，进行映射。数据库索引的原理，其实和哈希表是相同的。 数据库索引也是用空间换时间的做法。 Java应用 HashMap应用 java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道这个元素是否已经存在。 从实现上来说，java是借助hashcode()方法和equals()方法来实现判断元素是否已经存在的。当我们向HashMap中插入元素A时，首先，调用hashcode()方法，判断元素A在容器中是否已经存在。如果A元素的hashcode值在HashMap中不存在，则直接插入。否则，接着调用equals()方法，判断A元素在容器中是否已经存在。 hashcode()的时间复杂度为O(1)，equals()方法的时间复杂度为O(m)，整体的时间复杂度就是：O(1) + O(m)。 其中，m是桶的深度。 桶的深度是一个什么概念呢，桶的深度是指具有相同hashcode值得元素的个数，也就是发生哈希碰撞的元素的个数。 一个好的哈希算法应该尽量减少哈希碰撞的次数。 关于hashmap中详细的计算方式以后在集合中慢慢学习。 String应用 /** * 返回该字符串的哈希代码。 * 哈希值的计算方式 ： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * s[i]代表字符串数组中的元素 * 如果是空字符串，默认hash值是0. * * @return a hash code value for this object. */ public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } /** * 将此字符串与指定的对象进行比较。只有参数不是 null，并且和该对象字符序列相同的时候结果是true * * @param anObject * The object to compare this {@code String} against * * @return {@code true} if the given object represents a {@code String} * equivalent to this string, {@code false} otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 一致性哈希算法 基本介绍 多台机器需要协同作业，保证数据在分布式环境下的一致性，就成为了亟待解决的问题。一致性哈希算法，就是为了解决多台机器，在动态增删的情况下，能够最大限度地保证信息的一致性。 一致性哈希算法是一种分布式哈希算法，设计目标是为了解决互联网中的热点(Hot spot)问题。 参考标准 平衡性(Balance) 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。 单调性(Monotonicity) 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 分散性(Spread) 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 负载(Load) 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 实现过程 环形Hash空间 按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图 把数据通过一定的hash算法处理后映射到环上 现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图： Hash(object1) = key1； Hash(object2) = key2； Hash(object3) = key3； Hash(object4) = key4； 将机器通过hash算法映射到环上 在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。 假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下： Hash(NODE1) = KEY1; Hash(NODE2) = KEY2; Hash(NODE3) = KEY3; 通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。 机器的删除与添加 普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。 节点（机器）的删除 以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图： ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_004.jpg &quot;title&quot;) 节点（机器）的添加 如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图： ![Alt text](http://on8ygi8ap.bkt.clouddn.com/image/blog/pic_005.jpg &quot;title&quot;) 通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。 平衡性 根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。 “虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ）,实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。 以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下： 根据上图可知对象的映射关系：object1-&amp;gt;NODE1-1，object2-&amp;gt;NODE1-2，object3-&amp;gt;NODE3-2，object4-&amp;gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图： “虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值： Hash(“192.168.1.100”); 引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值： Hash(“192.168.1.100#1”); // NODE1-1 Hash(“192.168.1.100#2”); // NODE1-2 Java实现 import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.Set; import java.util.SortedMap; import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; public class ConsistentHash&amp;lt;T&amp;gt; { private final HashFunction hashFunction; private final int numberOfReplicas;// 节点的复制因子,实际节点个数 * numberOfReplicas = // 虚拟节点个数 private final SortedMap&amp;lt;Long, T&amp;gt; circle = new TreeMap&amp;lt;Long, T&amp;gt;();// 存储虚拟节点的hash值到真实节点的映射 public ConsistentHash(HashFunction hashFunction, int numberOfReplicas, Collection&amp;lt;T&amp;gt; nodes) { this.hashFunction = hashFunction; this.numberOfReplicas = numberOfReplicas; for (T node : nodes) add(node); } public void add(T node) { for (int i = 0; i &amp;lt; numberOfReplicas; i++) // 对于一个实际机器节点 node, 对应 numberOfReplicas 个虚拟节点 /* * 不同的虚拟节点(i不同)有不同的hash值,但都对应同一个实际机器node * 虚拟node一般是均衡分布在环上的,数据存储在顺时针方向的虚拟node上 */ circle.put(hashFunction.hash(node.toString() + i), node); } public void remove(T node) { for (int i = 0; i &amp;lt; numberOfReplicas; i++) circle.remove(hashFunction.hash(node.toString() + i)); } /* * 获得一个最近的顺时针节点,根据给定的key 取Hash * 然后再取得顺时针方向上最近的一个虚拟节点对应的实际节点 * 再从实际节点中取得 数据 */ public T get(Object key) { if (circle.isEmpty()) return null; long hash = hashFunction.hash((String) key);// node 用String来表示,获得node在哈希环中的hashCode if (!circle.containsKey(hash)) {//数据映射在两台虚拟机器所在环之间,就需要按顺时针方向寻找机器 SortedMap&amp;lt;Long, T&amp;gt; tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); } return circle.get(hash); } public long getSize() { return circle.size(); } /* * 查看MD5算法生成的hashCode值---表示整个哈希环中各个虚拟节点位置 */ public void testBalance(){ Set&amp;lt;Long&amp;gt; sets = circle.keySet();//获得TreeMap中所有的Key SortedSet&amp;lt;Long&amp;gt; sortedSets= new TreeSet&amp;lt;Long&amp;gt;(sets);//将获得的Key集合排序 for(Long hashCode : sortedSets){ System.out.println(hashCode); } System.out.println(&quot;----each location 's distance are follows: ----&quot;); /* * 查看用MD5算法生成的long hashCode 相邻两个hashCode的差值 */ Iterator&amp;lt;Long&amp;gt; it = sortedSets.iterator(); Iterator&amp;lt;Long&amp;gt; it2 = sortedSets.iterator(); if(it2.hasNext()) it2.next(); long keyPre, keyAfter; while(it.hasNext() &amp;amp;&amp;amp; it2.hasNext()){ keyPre = it.next(); keyAfter = it2.next(); System.out.println(keyAfter - keyPre); } } public static void main(String[] args) { Set&amp;lt;String&amp;gt; nodes = new HashSet&amp;lt;String&amp;gt;(); nodes.add(&quot;A&quot;); nodes.add(&quot;B&quot;); nodes.add(&quot;C&quot;); ConsistentHash&amp;lt;String&amp;gt; consistentHash = new ConsistentHash&amp;lt;String&amp;gt;(new HashFunction(), 2, nodes); consistentHash.add(&quot;D&quot;); System.out.println(&quot;hash circle size: &quot; + consistentHash.getSize()); System.out.println(&quot;location of each node are follows: &quot;); consistentHash.testBalance(); } }</summary></entry><entry><title type="html">Java常用关键字总结</title><link href="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html" rel="alternate" type="text/html" title="Java常用关键字总结" /><published>2018-01-02T16:47:46+08:00</published><updated>2018-01-02T16:47:46+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html">&lt;h1 id=&quot;abstrate&quot;&gt;abstrate&lt;/h1&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;abstract 关键字可以&lt;strong&gt;修改类或方法&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 类可以扩展（增加子类），但&lt;strong&gt;不能直接实例化&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。&lt;/p&gt;

&lt;p&gt;如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。&lt;/p&gt;

&lt;p&gt;abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。&lt;/p&gt;

&lt;p&gt;final 类的方法都不能是 abstract，因为 final 类不能有子类。&lt;/p&gt;

&lt;h1 id=&quot;break&quot;&gt;break&lt;/h1&gt;
&lt;h2 id=&quot;说明-1&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;break 总是退出最深层的 while、for、do 或 switch 语句。&lt;/p&gt;

&lt;h1 id=&quot;case&quot;&gt;case&lt;/h1&gt;
&lt;h2 id=&quot;说明-2&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用来标记 switch 语句中的每个分支。&lt;/p&gt;

&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;case 块没有隐式结束点。&lt;/p&gt;

&lt;p&gt;break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。&lt;/p&gt;

&lt;p&gt;如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。&lt;/p&gt;

&lt;h1 id=&quot;catch&quot;&gt;catch&lt;/h1&gt;
&lt;h2 id=&quot;说明-3&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块&lt;/p&gt;

&lt;h2 id=&quot;总结-3&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;br /&gt;
如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。&lt;br /&gt;
如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。&lt;/p&gt;

&lt;h1 id=&quot;continue&quot;&gt;continue&lt;/h1&gt;
&lt;h2 id=&quot;说明-4&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。&lt;/p&gt;

&lt;h2 id=&quot;总结-4&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。&lt;/p&gt;

&lt;h1 id=&quot;extends&quot;&gt;extends&lt;/h1&gt;
&lt;h2 id=&quot;说明-5&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。&lt;/p&gt;

&lt;h2 id=&quot;总结-5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类只能扩展一个其他类。&lt;/p&gt;

&lt;h1 id=&quot;final&quot;&gt;final&lt;/h1&gt;
&lt;h2 id=&quot;说明-6&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。&lt;br /&gt;
final 关键字可以应用于方法，以指示不能重写任何子类中的方法。&lt;/p&gt;

&lt;h2 id=&quot;总结-6&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。&lt;/p&gt;

&lt;p&gt;一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。&lt;/p&gt;

&lt;h1 id=&quot;finally&quot;&gt;finally&lt;/h1&gt;
&lt;h2 id=&quot;说明-7&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。&lt;br /&gt;
finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。&lt;/p&gt;

&lt;h2 id=&quot;总结-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;finally语句在return语句执行之后return返回之前执行的。&lt;/li&gt;
  &lt;li&gt;finally块中的return语句会覆盖try块中的return返回。&lt;/li&gt;
  &lt;li&gt;如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题）&lt;/li&gt;
  &lt;li&gt;try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。&lt;/li&gt;
  &lt;li&gt;当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lanxuezaipiao/p/3440471.html&quot;&gt;阅读更多&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;implements&quot;&gt;implements&lt;/h1&gt;
&lt;h2 id=&quot;说明-8&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。&lt;/p&gt;

&lt;h2 id=&quot;总结-8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;子类必须提供在 接口中所声明的所有方法的实现。&lt;br /&gt;
子类可以声明其他方法和变量，并扩展另一个类。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;instanceof&quot;&gt;instanceof&lt;/h1&gt;
&lt;h2 id=&quot;说明-9&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;instanceof 关键字用来确定对象所属的类。&lt;/p&gt;

&lt;h1 id=&quot;interface&quot;&gt;interface&lt;/h1&gt;
&lt;h2 id=&quot;说明-10&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;interface 关键字用来声明新的 Java 接口，接口是方法的集合。&lt;/p&gt;

&lt;h2 id=&quot;总结-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;实现了接口的任何类都必须提供在该接口中的所有方法的实现。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;native&quot;&gt;native&lt;/h1&gt;
&lt;h2 id=&quot;说明-11&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。&lt;/p&gt;

&lt;h1 id=&quot;private&quot;&gt;private&lt;/h1&gt;
&lt;h2 id=&quot;说明-12&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      private class MyPrivateClass
      {
      }
      private int i;
      private String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-10&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;protected&quot;&gt;protected&lt;/h1&gt;
&lt;h2 id=&quot;说明-13&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      protected class MyPrivateClass
      {
      }
      protected int i;
      protected String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-11&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;public&quot;&gt;public&lt;/h1&gt;
&lt;h2 id=&quot;说明-14&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public class MyPrivateClass
      {
      }
      public int i;
      public String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-12&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在其他任何类或包中引用 public 类、方法或字段。&lt;/p&gt;

&lt;h1 id=&quot;static&quot;&gt;static&lt;/h1&gt;
&lt;h2 id=&quot;说明-15&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public final static int MAX_OBJECTS = 100;
      static int _numObjects = 0;
      static class MyStaticClass
      {
      }
    
      static int getNumObjects()
      {
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-13&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。&lt;br /&gt;
static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。&lt;br /&gt;
static 字段（类的成员变量）在类的所有实例中只存在一次。&lt;br /&gt;
可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。&lt;br /&gt;
模式：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; &lt;/code&gt;&lt;br /&gt;
通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。&lt;/p&gt;

&lt;h1 id=&quot;super&quot;&gt;super&lt;/h1&gt;
&lt;h2 id=&quot;说明-16&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;super 关键字用于引用使用该关键字的类的超类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public MyClass(String arg)
      {
         super(arg);
      }
      public String myStringMethod()
      {
         return super.otherStringMethod();
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-14&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为独立语句出现的 super 表示调用超类的构造方法。&lt;br /&gt;
super.&lt;methodName&gt;() 表示调用超类的方法。&lt;/methodName&gt;&lt;/p&gt;

&lt;h1 id=&quot;synchronized&quot;&gt;synchronized&lt;/h1&gt;
&lt;h2 id=&quot;说明-17&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public synchronized static String mySyncStaticMethod()
      {
      }
      public synchronized String mySyncMethod()
      {
      }
   {
   public class MyOtherClass
   {
      Object someObj;
      public String myMethod()
      {
         &amp;lt;statements&amp;gt;
         synchronized (someObj)
         {
            &amp;lt;statements affecting someObj&amp;gt;
         }
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-15&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可防止代码的关键代码段一次被多个线程执行。&lt;br /&gt;
如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。&lt;br /&gt;
如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。&lt;br /&gt;
如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。  &lt;br /&gt;
每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。   &lt;br /&gt;
实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/p&gt;

&lt;h1 id=&quot;transient&quot;&gt;transient&lt;/h1&gt;
&lt;h2 id=&quot;说明-18&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。&lt;/p&gt;

&lt;h2 id=&quot;总结-16&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。&lt;/li&gt;
  &lt;li&gt;transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。&lt;/li&gt;
  &lt;li&gt;被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特殊说明&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。&lt;br /&gt;
若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。&lt;/p&gt;

&lt;h1 id=&quot;volatile&quot;&gt;volatile&lt;/h1&gt;
&lt;h2 id=&quot;说明-19&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字用于表示可以被多个线程异步修改的成员变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      volatile int sharedValue;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-17&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。&lt;/p&gt;

&lt;p&gt;当一个变量定义为 volatile 之后，将具备两种特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/p&gt;

&lt;p&gt;在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。&lt;/p&gt;

&lt;h2 id=&quot;特殊说明-1&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字在许多 Java 虚拟机中都没有实现。&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">abstrate 说明 abstract 关键字可以修改类或方法。 abstract 类可以扩展（增加子类），但不能直接实例化。 abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。 总结 仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。 如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。 break 说明 用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 总结 break 总是退出最深层的 while、for、do 或 switch 语句。 case 说明 用来标记 switch 语句中的每个分支。 总结 case 块没有隐式结束点。 break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 catch 说明 catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块 总结 开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。 如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 continue 说明 continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 总结 continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。 extends 说明 用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。 总结 一个类只能扩展一个其他类。 final 说明 final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。 final 关键字可以应用于方法，以指示不能重写任何子类中的方法。 总结 一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。 一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。 finally 说明 finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。 finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。 总结 开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 finally语句在return语句执行之后return返回之前执行的。 finally块中的return语句会覆盖try块中的return返回。 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题） try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。 阅读更多 implements 说明 implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。 总结 子类必须提供在 接口中所声明的所有方法的实现。 子类可以声明其他方法和变量，并扩展另一个类。 一个类可以实现多个接口。 instanceof 说明 instanceof 关键字用来确定对象所属的类。 interface 说明 interface 关键字用来声明新的 Java 接口，接口是方法的集合。 总结 实现了接口的任何类都必须提供在该接口中的所有方法的实现。 一个类可以实现多个接口。 native 说明 native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。 private 说明 private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 public class MyPublicClass { private class MyPrivateClass { } private int i; private String myMethod() { &amp;lt;statements&amp;gt; } } 总结 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 protected 说明 protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { protected class MyPrivateClass { } protected int i; protected String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 public 说明 public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { public class MyPrivateClass { } public int i; public String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在其他任何类或包中引用 public 类、方法或字段。 static 说明 static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 public class MyPublicClass { public final static int MAX_OBJECTS = 100; static int _numObjects = 0; static class MyStaticClass { } static int getNumObjects() { } } 总结 通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。 模式： public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; 通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。 super 说明 super 关键字用于引用使用该关键字的类的超类。 public class MyClass { public MyClass(String arg) { super(arg); } public String myStringMethod() { return super.otherStringMethod(); } } 总结 作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法。 synchronized 说明 synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 public class MyClass { public synchronized static String mySyncStaticMethod() { } public synchronized String mySyncMethod() { } { public class MyOtherClass { Object someObj; public String myMethod() { &amp;lt;statements&amp;gt; synchronized (someObj) { &amp;lt;statements affecting someObj&amp;gt; } } } 总结 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 transient 说明 transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 总结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 特殊说明 对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。 若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。 volatile 说明 volatile 关键字用于表示可以被多个线程异步修改的成员变量。 public class MyClass { volatile int sharedValue; } 总结 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 当一个变量定义为 volatile 之后，将具备两种特性： 保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。 volatile 性能： 　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 特殊说明 volatile 关键字在许多 Java 虚拟机中都没有实现。</summary></entry><entry><title type="html">Mybatis初始化(2)</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html" rel="alternate" type="text/html" title="Mybatis初始化(2)" /><published>2017-12-25T20:27:29+08:00</published><updated>2017-12-25T20:27:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html">&lt;h1 id=&quot;mybatis源码解析一mybatis初始化过程解析&quot;&gt;MyBatis源码解析(一)——MyBatis初始化过程解析&lt;/h1&gt;

&lt;h1 id=&quot;1-准备工作&quot;&gt;1. 准备工作&lt;/h1&gt;

&lt;p&gt;为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-94ca3998bee0abb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/294&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-product-产品实体类&quot;&gt;1.1 Product 产品实体类&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;12-productmapper-产品持久化接口&quot;&gt;1.2 ProductMapper 产品持久化接口&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&amp;lt;Product&amp;gt; selectProductList();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-productmapperxml-产品映射文件&quot;&gt;1.3 ProductMapper.xml 产品映射文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectProductList&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.entity.Product&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        select * from product
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;14-dbproperties-数据库配置文件&quot;&gt;1.4 db.properties 数据库配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8
username=root
password=xxxxxx

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-mybatisxml-mybatis的配置文件&quot;&gt;1.5 mybatis.xml MyBatis的配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${driver}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${username}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${password}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team/njupt/mapper/ProductMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;16-main-主函数&quot;&gt;1.6 Main 主函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        String resource = &quot;mybatis.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-mybatis初始化过程&quot;&gt;2. MyBatis初始化过程&lt;/h1&gt;

&lt;h2 id=&quot;21-获取配置文件&quot;&gt;2.1 获取配置文件&lt;/h2&gt;

&lt;p&gt;当系统初始化时，首先会读取配置文件，并将其解析成InputStream&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String resource = &quot;mybatis.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;22-创建sqlsessionfactorybuilder对象&quot;&gt;2.2 创建SqlSessionFactoryBuilder对象&lt;/h2&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;的名字中可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;是用来创建&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;对象的。
来看一下SqlSessionFactoryBuilder源码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-b0f3e995ac56f20a.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;h2 id=&quot;23-sqlsessionfactory创建过程&quot;&gt;2.3 SqlSessionFactory创建过程&lt;/h2&gt;

&lt;p&gt;下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;231-构造xmlconfigbuilder对象&quot;&gt;2.3.1 构造XMLConfigBuilder对象&lt;/h4&gt;

&lt;p&gt;build函数首先会构造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;的体系结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-3998f972a6a4e251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;是用来解析XML配置文件的，不同类型&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;用来解析MyBatis配置文件的不同部位。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;用来解析MyBatis的配置文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;用来解析MyBatis中的映射文件（如上文提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProductMapper.xml&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLStatementBuilder&lt;/code&gt;用来解析映射文件中的SQL语句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这些&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;都有一个共同的父类——&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;。这个父类维护了一个全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，MyBatis的配置文件解析后就以&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的形式存储。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象时，就会初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，并且在初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的时候，一些别名会被注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
super(new Configuration());
ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
this.configuration.setVariables(props);
this.parsed = false;
this.environment = environment;
this.parser = parser;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Configuration() {
typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);

typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);
typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);
typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);
……
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;232-解析配置文件&quot;&gt;2.3.2 解析配置文件&lt;/h3&gt;

&lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象之后，接下来就可以用它来解析配置文件了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void parseConfiguration(XNode root) {
  try {
    // 解析&amp;lt;properties&amp;gt;节点
    propertiesElement(root.evalNode(&quot;properties&quot;));
    // 解析&amp;lt;settings&amp;gt;节点
    Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
    loadCustomVfs(settings);
    // 解析&amp;lt;typeAliases&amp;gt;节点
    typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
    // 解析&amp;lt;plugins&amp;gt;节点
    pluginElement(root.evalNode(&quot;plugins&quot;));
    // 解析&amp;lt;objectFactory&amp;gt;节点
    objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
    objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
    // 解析&amp;lt;reflectorFactory&amp;gt;节点
    reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
    settingsElement(settings);
    // 解析&amp;lt;environments&amp;gt;节点
    environmentsElement(root.evalNode(&quot;environments&quot;));
    databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
    typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
    // 解析&amp;lt;mappers&amp;gt;节点
    mapperElement(root.evalNode(&quot;mappers&quot;));
  } catch (Exception e) {
    throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;会依次解析配置文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; settings &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; environments&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; typeAliases &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; plugins &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; mappers &amp;gt;&lt;/code&gt;等属性。下面介绍下几个重要属性的解析过程。&lt;/p&gt;

&lt;h4 id=&quot;2321-properties节点的解析过程&quot;&gt;2.3.2.1 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;节点的解析过程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的定义如下：

    
&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;
  &amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的解析过程：

&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
      * @Param context &amp;lt;properties&amp;gt;节点
      */
    private void propertiesElement(XNode context) throws Exception {
      if (context != null) {
        // 获取&amp;lt;properties&amp;gt;节点的所有子节点
        Properties defaults = context.getChildrenAsProperties();
        // 获取&amp;lt;properties&amp;gt;节点上的resource属性
        String resource = context.getStringAttribute(&quot;resource&quot;);
        // 获取&amp;lt;properties&amp;gt;节点上的url属性
        String url = context.getStringAttribute(&quot;url&quot;);
        // resource和url不能同时存在
        if (resource != null &amp;amp;&amp;amp; url != null) {
          throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);
        }
        if (resource != null) {
          // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中        
          defaults.putAll(Resources.getResourceAsProperties(resource));
        } else if (url != null) {
          // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中
          defaults.putAll(Resources.getUrlAsProperties(url));
        }
        // 获取configuration中原本的属性，并添加至defaults容器中
        Properties vars = configuration.getVariables();
        if (vars != null) {
          defaults.putAll(vars);
        }
        parser.setVariables(defaults);
        // 将defaults容器添加至configuration中
        configuration.setVariables(defaults);
      }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。
*   然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。）
*   最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2322-节点的解析过程&quot;&gt;2.3.2.2 &lt;settings&gt;节点的解析过程&lt;/settings&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的定义如下：

&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;settings&amp;gt;
      &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的解析过程：
`&lt;settings&gt;`属性的解析过程和 `&lt;properties&gt;`属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。

&lt;/properties&gt;&lt;/settings&gt;&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2323-属性的解析过程&quot;&gt;2.3.2.3 &lt;typeAliases&gt;属性的解析过程&lt;/typeAliases&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;属性的定义方式有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方式1：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt;
  &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方式2：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&amp;lt; typeAlias &amp;gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute(&quot;alias&quot;);
        String type = child.getStringAttribute(&quot;type&quot;);
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAlias&amp;gt;&lt;/code&gt;节点，那么MyBatis就会给指定的类起指定的别名。&lt;/li&gt;
  &lt;li&gt;这些别名都会被存入&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2324-节点的解析过程&quot;&gt;2.3.2.4 &lt;mappers&gt;节点的解析过程&lt;/mappers&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的定义方式有如下四种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方式1：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式2：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式3：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式4：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&amp;lt;mappers&amp;gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&amp;lt;mapper&amp;gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis会遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;下所有的子节点，如果当前遍历到的节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;，则MyBatis会将该包下的所有Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
  &lt;li&gt;如果当前节点为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在解析前，首先需要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;，创建过程如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) {
  // 将configuration赋给BaseBuilder
  super(configuration);
  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）
  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);
  this.parser = parser;
  this.sqlFragments = sqlFragments;
  this.resource = resource;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;首先会初始化父类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
      &lt;li&gt;然后创建&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void parse() {
  // 若当前的Mapper.xml尚未被解析，则开始解析
  // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了
  if (!configuration.isResourceLoaded(resource)) {
    // 解析&amp;lt;mapper&amp;gt;节点
    configurationElement(parser.evalNode(&quot;/mapper&quot;));
    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析
    configuration.addLoadedResource(resource);
    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中
    bindMapperForNamespace();
  }

  parsePendingResultMaps();
  parsePendingCacheRefs();
  parsePendingStatements();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configurationElement&lt;/code&gt;函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void configurationElement(XNode context) {
try {
  // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁
  String namespace = context.getStringAttribute(&quot;namespace&quot;);
  if (namespace == null || namespace.equals(&quot;&quot;)) {
    throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;);
  }
  // 将namespace属性值赋给builderAssistant
  builderAssistant.setCurrentNamespace(namespace);
  // 解析&amp;lt;cache-ref&amp;gt;节点
  cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
  // 解析&amp;lt;cache&amp;gt;节点
  cacheElement(context.evalNode(&quot;cache&quot;));
  // 解析&amp;lt;parameterMap&amp;gt;节点
  parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
  // 解析&amp;lt;resultMap&amp;gt;节点
  resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
  // 解析&amp;lt;sql&amp;gt;节点
  sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
  // 解析sql语句      
  buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
} catch (Exception e) {
  throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMapElements&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点，这些节点会被解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMaps&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt;
  &amp;lt;constructor&amp;gt;
     &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt;
     &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt;
  &amp;lt;/constructor&amp;gt;
  &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt;
  &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception {
  ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的id属性
  String id = resultMapNode.getStringAttribute(&quot;id&quot;,
    resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型）
  String type = resultMapNode.getStringAttribute(&quot;type&quot;,
    resultMapNode.getStringAttribute(&quot;ofType&quot;,
        resultMapNode.getStringAttribute(&quot;resultType&quot;,
            resultMapNode.getStringAttribute(&quot;javaType&quot;))));
  // 获取extends属性
  String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);
  // 获取autoMapping属性
  Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);
  // 将resultMap的返回值类型转换成Class对象
  Class&amp;lt;?&amp;gt; typeClass = resolveClass(type);
  Discriminator discriminator = null;
  // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;();
  resultMappings.addAll(additionalResultMappings);
  // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren();
  for (XNode resultChild : resultChildren) {
    // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去
    if (&quot;constructor&quot;.equals(resultChild.getName())) {
      processConstructorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去
    else if (&quot;discriminator&quot;.equals(resultChild.getName())) {
      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去
    else {
      // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property
      List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;();
      if (&quot;id&quot;.equals(resultChild.getName())) {
        flags.add(ResultFlag.ID);
      }
      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
    }
  }
  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）
  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
  try {
    return resultMapResolver.resolve();
  } catch (IncompleteElementException  e) {
    configuration.addIncompleteResultMap(resultMapResolver);
    throw e;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;，用于构造&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ResultMap resolve() {
  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlElement&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildStatementFromContext&lt;/code&gt;函数
该函数会将映射文件中的sql语句解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;MappedStatement&lt;/code&gt;对象，并存在&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mappedStatements&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;233-创建sqlsessionfactory对象&quot;&gt;2.3.3 创建SqlSessionFactory对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回过头来再看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;函数，刚才说了半天，介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;解析映射文件的过程，解析完成之后&lt;code class=&quot;highlighter-rouge&quot;&gt;parser.parse()&lt;/code&gt;函数会返回一个包含了映射文件解析结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;作为参数，创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;对象。
&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;是接口&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的一个实现类，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的体系结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-da2dbd8f1f2ac844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;创建完毕！&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">MyBatis源码解析(一)——MyBatis初始化过程解析 1. 准备工作 为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示： 1.1 Product 产品实体类 public class Product { private long id; private String productName; private String productContent; private String price; private int sort; private int falseSales; private long category_id; private byte type; private byte state; // PS：省略setter、getter函数 } 1.2 ProductMapper 产品持久化接口 public interface ProductMapper { /** * 查询所有的产品 * @return */ List&amp;lt;Product&amp;gt; selectProductList(); } 1.3 ProductMapper.xml 产品映射文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;team.njupt.mapper.ProductMapper&quot;&amp;gt; &amp;lt;select id=&quot;selectProductList&quot; resultType=&quot;team.njupt.entity.Product&quot;&amp;gt; select * from product &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 1.4 db.properties 数据库配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8 username=root password=xxxxxx 1.5 mybatis.xml MyBatis的配置文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;properties resource=&quot;db.properties&quot;&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;team/njupt/mapper/ProductMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 1.6 Main 主函数 public class Main { public static void main(String[] args) throws IOException { String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); try { ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class); List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList(); for (Product product : productList) { System.out.printf(product.toString()); } } finally { sqlSession.close(); } } } 2. MyBatis初始化过程 2.1 获取配置文件 当系统初始化时，首先会读取配置文件，并将其解析成InputStream String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); 2.2 创建SqlSessionFactoryBuilder对象 从SqlSessionFactoryBuilder的名字中可以看出，SqlSessionFactoryBuilder是用来创建SqlSessionFactory对象的。 来看一下SqlSessionFactoryBuilder源码： SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。 2.3 SqlSessionFactory创建过程 下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 2.3.1 构造XMLConfigBuilder对象 build函数首先会构造一个XMLConfigBuilder对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下XMLConfigBuilder的体系结构。 XMLxxxBuilder是用来解析XML配置文件的，不同类型XMLxxxBuilder用来解析MyBatis配置文件的不同部位。比如：XMLConfigBuilder用来解析MyBatis的配置文件，XMLMapperBuilder用来解析MyBatis中的映射文件（如上文提到的ProductMapper.xml），XMLStatementBuilder用来解析映射文件中的SQL语句。 这些XMLxxxBuilder都有一个共同的父类——BaseBuilder。这个父类维护了一个全局的Configuration对象，MyBatis的配置文件解析后就以Configuration对象的形式存储。 当创建XMLConfigBuilder对象时，就会初始化Configuration对象，并且在初始化Configuration对象的时候，一些别名会被注册到Configuration的typeAliasRegistry容器中。 private XMLConfigBuilder(XPathParser parser, String environment, Properties props) { super(new Configuration()); ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; } public Configuration() { typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); …… } 2.3.2 解析配置文件 当有了XMLConfigBuilder对象之后，接下来就可以用它来解析配置文件了。 private void parseConfiguration(XNode root) { try { // 解析&amp;lt;properties&amp;gt;节点 propertiesElement(root.evalNode(&quot;properties&quot;)); // 解析&amp;lt;settings&amp;gt;节点 Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); // 解析&amp;lt;typeAliases&amp;gt;节点 typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); // 解析&amp;lt;plugins&amp;gt;节点 pluginElement(root.evalNode(&quot;plugins&quot;)); // 解析&amp;lt;objectFactory&amp;gt;节点 objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); // 解析&amp;lt;reflectorFactory&amp;gt;节点 reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // 解析&amp;lt;environments&amp;gt;节点 environmentsElement(root.evalNode(&quot;environments&quot;)); databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); // 解析&amp;lt;mappers&amp;gt;节点 mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } 从上述代码中可以看到，XMLConfigBuilder会依次解析配置文件中的&amp;lt;properties&amp;gt;、&amp;lt; settings &amp;gt;、&amp;lt; environments&amp;gt;、&amp;lt; typeAliases &amp;gt;、&amp;lt; plugins &amp;gt;、&amp;lt; mappers &amp;gt;等属性。下面介绍下几个重要属性的解析过程。 2.3.2.1 &amp;lt;properties&amp;gt;节点的解析过程 节点的定义如下： &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt; &amp;lt;/properties&amp;gt; 节点的解析过程： /** * @Param context &amp;lt;properties&amp;gt;节点 */ private void propertiesElement(XNode context) throws Exception { if (context != null) { // 获取&amp;lt;properties&amp;gt;节点的所有子节点 Properties defaults = context.getChildrenAsProperties(); // 获取&amp;lt;properties&amp;gt;节点上的resource属性 String resource = context.getStringAttribute(&quot;resource&quot;); // 获取&amp;lt;properties&amp;gt;节点上的url属性 String url = context.getStringAttribute(&quot;url&quot;); // resource和url不能同时存在 if (resource != null &amp;amp;&amp;amp; url != null) { throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other.&quot;); } if (resource != null) { // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getResourceAsProperties(resource)); } else if (url != null) { // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getUrlAsProperties(url)); } // 获取configuration中原本的属性，并添加至defaults容器中 Properties vars = configuration.getVariables(); if (vars != null) { defaults.putAll(vars); } parser.setVariables(defaults); // 将defaults容器添加至configuration中 configuration.setVariables(defaults); } } * 首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。 * 然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。） * 最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。 2.3.2.2 节点的解析过程 节点的定义如下： &amp;lt;settings&amp;gt; &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;/settings&amp;gt; 节点的解析过程： ``属性的解析过程和 ``属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。 2.3.2.3 属性的解析过程 &amp;lt;typeAliases&amp;gt;属性的定义方式有如下两种： 方式1： &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt; &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 方式2： &amp;lt;typeAliases&amp;gt; &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。 &amp;lt;typeAliases&amp;gt;节点的解析过程如下： private void typeAliasesElement(XNode parent) { if (parent != null) { // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点 for (XNode child : parent.getChildren()) { // 若当前结点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;上的name属性（包名） String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中 configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } // 如果当前结点为&amp;lt; typeAlias &amp;gt; else { // 获取alias和type属性 String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); // 注册进configuration的typeAliasRegistry中 try { Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e); } } } } } 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;package&amp;gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名） 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;typeAlias&amp;gt;节点，那么MyBatis就会给指定的类起指定的别名。 这些别名都会被存入configuration的typeAliasRegistry容器中。 2.3.2.4 节点的解析过程 &amp;lt;mappers&amp;gt;节点的定义方式有如下四种： 方式1： &amp;lt;mappers&amp;gt; &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式2： &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式3： &amp;lt;mappers&amp;gt; &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式4： &amp;lt;mappers&amp;gt; &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;mappers&amp;gt;节点的解析过程如下： private void mapperElement(XNode parent) throws Exception { if (parent != null) { // 遍历&amp;lt;mappers&amp;gt;下所有子节点 for (XNode child : parent.getChildren()) { // 如果当前节点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名） String mapperPackage = child.getStringAttribute(&quot;name&quot;); // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中 configuration.addMappers(mapperPackage); } // 如果当前节点为&amp;lt;mapper&amp;gt; else { // 依次获取resource、url、class属性 String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); // 解析resource属性（Mapper.xml文件的路径） if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(resource); // 将Mapper.xml文件解析成输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } // 解析url属性（Mapper.xml文件的路径） else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } // 解析class属性（Mapper Class的全限定名） else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) { // 将Mapper Class的权限定名转化成Class对象 Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass); // 注册进configuration对象的mapperRegistry容器中 configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } MyBatis会遍历&amp;lt;mappers&amp;gt;下所有的子节点，如果当前遍历到的节点是&amp;lt;package&amp;gt;，则MyBatis会将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中。 如果当前节点为&amp;lt;mapper&amp;gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到configuration的mapperRegistry容器中。 其中，&amp;lt;mapper&amp;gt;节点的解析过程如下： XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); 在解析前，首先需要创建XMLMapperBuilder，创建过程如下： private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) { // 将configuration赋给BaseBuilder super(configuration); // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者） this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } 首先会初始化父类BaseBuilder，并将configuration赋给BaseBuilder； 然后创建MapperBuilderAssistant对象，该对象为XMLMapperBuilder的协助者，用来协助XMLMapperBuilder完成一些解析映射文件的动作。 当有了XMLMapperBuilder后，便可进入解析&amp;lt;mapper&amp;gt;的过程： public void parse() { // 若当前的Mapper.xml尚未被解析，则开始解析 // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了 if (!configuration.isResourceLoaded(resource)) { // 解析&amp;lt;mapper&amp;gt;节点 configurationElement(parser.evalNode(&quot;/mapper&quot;)); // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析 configuration.addLoadedResource(resource); // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中 bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements(); } configurationElement函数 private void configurationElement(XNode context) { try { // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁 String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;); } // 将namespace属性值赋给builderAssistant builderAssistant.setCurrentNamespace(namespace); // 解析&amp;lt;cache-ref&amp;gt;节点 cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); // 解析&amp;lt;cache&amp;gt;节点 cacheElement(context.evalNode(&quot;cache&quot;)); // 解析&amp;lt;parameterMap&amp;gt;节点 parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // 解析&amp;lt;resultMap&amp;gt;节点 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // 解析&amp;lt;sql&amp;gt;节点 sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 解析sql语句 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e); } } resultMapElements函数 该函数用于解析映射文件中所有的&amp;lt;resultMap&amp;gt;节点，这些节点会被解析成ResultMap对象，存储在Configuration对象的resultMaps容器中。 &amp;lt;resultMap&amp;gt;节点定义如下： &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt; &amp;lt;constructor&amp;gt; &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt; &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt; &amp;lt;/constructor&amp;gt; &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt; &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap&amp;gt;节点的解析过程： private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的id属性 String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型） String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // 获取extends属性 String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // 获取autoMapping属性 Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); // 将resultMap的返回值类型转换成Class对象 Class&amp;lt;?&amp;gt; typeClass = resolveClass(type); Discriminator discriminator = null; // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;(); resultMappings.addAll(additionalResultMappings); // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去 if (&quot;constructor&quot;.equals(resultChild.getName())) { processConstructorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去 else if (&quot;discriminator&quot;.equals(resultChild.getName())) { discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去 else { // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下） ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } ResultMapResolver这个类很纯粹，有且仅有一个函数resolve，用于构造ResultMap对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于MapperBuilderAssistant.addResultMap完成的。 public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } sqlElement函数 该函数用于解析映射文件中所有的&amp;lt;sql&amp;gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。 &amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt; buildStatementFromContext函数 该函数会将映射文件中的sql语句解析成MappedStatement对象，并存在configuration的mappedStatements。 2.3.3 创建SqlSessionFactory对象 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 回过头来再看一下SqlSessionFactory的build函数，刚才说了半天，介绍了XMLConfigBuilder解析映射文件的过程，解析完成之后parser.parse()函数会返回一个包含了映射文件解析结果的configuration对象，紧接着，这个对象将作为参数传递给另一个build函数，如下： public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 这个函数将configuration作为参数，创建了DefaultSqlSessionFactory对象。 DefaultSqlSessionFactory是接口SqlSessionFactory的一个实现类，SqlSessionFactory的体系结构如下图所示： 此时，SqlSessionFactory创建完毕！</summary></entry><entry><title type="html">Spring手动提交事务</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html" rel="alternate" type="text/html" title="Spring手动提交事务" /><published>2017-12-23T10:12:47+08:00</published><updated>2017-12-23T10:12:47+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html">&lt;p&gt;开篇之前先说一下问题来源，我是用了&lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;redisson&lt;/a&gt;作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;);
	if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
		RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;);
		if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
			// 吧啦吧啦
			// 这里是业务逻辑代码
			// 修改对象状态等等
		} else {
			//操作超时，请重新操作
		}
		if (BLock.isLocked()) {
			BLock.unlock();
		}
	} else {
		//操作超时，请重新操作
	}
	if (ALock.isLocked()) {
		ALock.unlock();
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。&lt;/p&gt;

&lt;p&gt;两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。&lt;/p&gt;

&lt;p&gt;结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。&lt;/p&gt;

&lt;p&gt;解决方案1：
	把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题
	这种方法也有缺点，部分业务处理需要在controller中进行&lt;/p&gt;

&lt;p&gt;解决方案2：
	service层手动提交事务，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	@Resource 
    private DataSourceTransactionManager transactionManager; 


	// 下面是手动提交
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();  
	// 事物隔离级别，开启新事务，这样会比较安全些。  
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); 
	// 获得事务状态 
	TransactionStatus status = transactionManager.getTransaction(def);  
	try {  
		transactionManager.commit(status);  
	} catch (Exception e) {  
		transactionManager.rollback(status);  
	}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><summary type="html">开篇之前先说一下问题来源，我是用了redisson作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。 RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;); if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;); if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { // 吧啦吧啦 // 这里是业务逻辑代码 // 修改对象状态等等 } else { //操作超时，请重新操作 } if (BLock.isLocked()) { BLock.unlock(); } } else { //操作超时，请重新操作 } if (ALock.isLocked()) { ALock.unlock(); } 这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。 两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。 结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。 解决方案1： 把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题 这种方法也有缺点，部分业务处理需要在controller中进行 解决方案2： service层手动提交事务，代码如下 @Resource private DataSourceTransactionManager transactionManager; // 下面是手动提交 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // 事物隔离级别，开启新事务，这样会比较安全些。 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); // 获得事务状态 TransactionStatus status = transactionManager.getTransaction(def); try { transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } 以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。 由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。</summary></entry><entry><title type="html">Mybatis二级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis二级缓存" /><published>2017-12-19T19:51:29+08:00</published><updated>2017-12-19T19:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/27.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。&lt;/p&gt;

&lt;p&gt;如果用户配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cacheEnabled=true&quot;&lt;/code&gt;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：&lt;code class=&quot;highlighter-rouge&quot;&gt;CachingExecutor&lt;/code&gt;，这时SqlSession使用CachingExecutor对象来完成操作请求。&lt;/p&gt;

&lt;p&gt;CachingExecutor对于查询请求，会先判断该查询请求在Application级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;二级缓存中是否有缓存结果&lt;/code&gt;，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。&lt;/p&gt;

&lt;h1 id=&quot;2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/28.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，&lt;/p&gt;

&lt;p&gt;CachingExecutor和Executor的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/29.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/h1&gt;

&lt;p&gt;Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置 为一个Mapper分配一个Cache缓存对象&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置 为多个Mapper分配相同的Cache对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/30.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID&lt;/p&gt;
&lt;h2 id=&quot;32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;如果你想让多个Mapper公用一个Cache的话，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;&lt;/code&gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/31.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/h1&gt;
&lt;p&gt;二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。&lt;/p&gt;

&lt;p&gt;虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`&lt;select&gt; `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。&lt;/select&gt;&lt;/cache&gt;&lt;/p&gt;

&lt;p&gt;如下所示，Select语句配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;useCache=&quot;true&quot;&lt;/code&gt;，则表明这条Select语句的查询会使用二级缓存。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;useCache=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开启二级缓存的条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true&lt;/li&gt;
  &lt;li&gt;该select语句所在的Mapper，配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cached-ref&amp;gt;&lt;/code&gt;节点，并且有效&lt;/li&gt;
  &lt;li&gt;该select语句的参数 useCache=true&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/h1&gt;
&lt;p&gt;二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库&lt;/p&gt;

&lt;h1 id=&quot;6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;使用MyBatis的二级缓存有三个选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis自身提供的缓存实现&lt;/p&gt;

    &lt;p&gt;MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义的Cache接口实现&lt;/p&gt;

    &lt;p&gt;MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache type=&quot;&quot;&amp;gt;&lt;/code&gt;节点的type属性上即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟第三方内存缓存库的集成&lt;/p&gt;

    &lt;p&gt;MyBatis还支持跟第三方内存缓存库如Memecached的集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/h1&gt;
&lt;p&gt;MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/32.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；&lt;/li&gt;
  &lt;li&gt;FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；&lt;/li&gt;
  &lt;li&gt;Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">1. Mybatis缓存机制整体设计 2. 二级缓存的基本原理 3. 二级缓存的划分 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 4. 开启二级缓存的条件 5. 缓存使用顺序 6. 二级缓存的实现方式 7. Mybatis自身提供的二级缓存实现 1. Mybatis缓存机制整体设计   当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。 如果用户配置了&quot;cacheEnabled=true&quot;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。 CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。 2. 二级缓存的基本原理 CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式， CachingExecutor和Executor的关系图 3. 二级缓存的划分 Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象 使用&amp;lt;cache&amp;gt;节点配置 为一个Mapper分配一个Cache缓存对象 使用&amp;lt;cache-ref&amp;gt;节点配置 为多个Mapper分配相同的Cache对象 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&amp;lt;cache&amp;gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象 每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 如果你想让多个Mapper公用一个Cache的话，你可以使用&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。 4. 开启二级缓存的条件 二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。 虽然在Mapper中配置了,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在` `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。 如下所示，Select语句配置了useCache=&quot;true&quot;，则表明这条Select语句的查询会使用二级缓存。 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&amp;gt; 开启二级缓存的条件 MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了&amp;lt;cache&amp;gt; 或&amp;lt;cached-ref&amp;gt;节点，并且有效 该select语句的参数 useCache=true 5. 缓存使用顺序 二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库 6. 二级缓存的实现方式 使用MyBatis的二级缓存有三个选择 MyBatis自身提供的缓存实现 MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等 用户自定义的Cache接口实现 MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&amp;lt;cache type=&quot;&quot;&amp;gt;节点的type属性上即可 跟第三方内存缓存库的集成 MyBatis还支持跟第三方内存缓存库如Memecached的集成 7. Mybatis自身提供的二级缓存实现 MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略： LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录； FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉； Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</summary></entry><entry><title type="html">装饰者模式简单理解</title><link href="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="装饰者模式简单理解" /><published>2017-12-19T13:51:29+08:00</published><updated>2017-12-19T13:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html">&lt;h1 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#装饰者模式&quot;&gt;装饰者模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#基本描述&quot;&gt;基本描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#代码实例&quot;&gt;代码实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;基本描述&quot;&gt;基本描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给对象动态地添加附加功能。&lt;/li&gt;
  &lt;li&gt;装饰者提供了一个灵活的拓展子类功能的备选方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个程序猿
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员
 */
public class Coder {

 public void coding() {
     System.out.println(&quot;我在写程序。。。&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个程序猿的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员装饰器
 */
public class CoderDecorator extends Coder {

 private Coder coder;

 public CoderDecorator(Coder coder) {
     this.coder = coder;
 }

 @Override
 public void coding() {
     coder.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个专门更换键盘的装饰器
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;写代码以前换键盘
 */
public class CoderDecoratorA extends CoderDecorator {&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;public CoderDecoratorA(Coder coder) {
     super(coder);
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public void coding() {
     this.addNewKeyBoard();
     super.coding();
 }&lt;/p&gt;

    &lt;p&gt;private void addNewKeyBoard() {
     System.out.println(“更换了新的机械键盘，噼里啪啦”);
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
4. 定义一个专门更换鼠标的装饰器
```Java

/**
 * 写代码以前换鼠标
 */
public class CoderDecoratorB extends CoderDecorator {

    public CoderDecoratorB(Coder coder) {
        super(coder);
    }

    @Override
    public void coding() {
        this.addNewMouse();
        super.coding();
    }

    private void addNewMouse() {
        System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个更换电脑的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 写代码以前换电脑
 */
public class CoderDecoratorC extends CoderDecorator {

 public CoderDecoratorC(Coder coder) {
     super(coder);
 }

 @Override
 public void coding() {
     this.changeToMacbookPro();
     super.coding();
 }

 private void changeToMacbookPro() {
     System.out.println(&quot;电脑不好使，换了，美滋滋&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;好了，现在老板可以根据不同程序猿的要求一一满足了
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序猿写代码
 */
public class Client {

 public static void main(String[] args) {
     //创造一个程序猿A，并且开始写代码
     Coder coderA = new Coder();
     //换个键盘在写
     CoderDecorator decoratorA = new CoderDecoratorA(coderA);
     //换个鼠标在写
     decoratorA = new CoderDecoratorB(decoratorA);
     //把电脑也换了
     decoratorA = new CoderDecoratorC(decoratorA);
     decoratorA.coding();

     //创造一个程序猿B，并且开始写代码
     Coder coderB = new Coder();
     //换个键盘在写
     CoderDecorator decoratorB = new CoderDecoratorA(coderB);
     //把电脑也换了
     decoratorB = new CoderDecoratorC(decoratorB);
     decoratorB.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这里满足程序猿A的要求
电脑不好使，换了，美滋滋
换了新的鼠标，哒哒哒，哒哒哒
更换了新的机械键盘，噼里啪啦
我在写程序。。。
//这里满足程序猿B的要求
电脑不好使，换了，美滋滋
更换了新的机械键盘，噼里啪啦
我在写程序。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">装饰者模式 装饰者模式 基本描述 代码实例 基本描述 目的 给对象动态地添加附加功能。 装饰者提供了一个灵活的拓展子类功能的备选方案。 代码实例 公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。） 定义一个程序猿 /** * 程序员 */ public class Coder { public void coding() { System.out.println(&quot;我在写程序。。。&quot;); } } 定义一个程序猿的装饰器 /** * 程序员装饰器 */ public class CoderDecorator extends Coder { private Coder coder; public CoderDecorator(Coder coder) { this.coder = coder; } @Override public void coding() { coder.coding(); } } 定义一个专门更换键盘的装饰器 ```Java /** 写代码以前换键盘 */ public class CoderDecoratorA extends CoderDecorator { public CoderDecoratorA(Coder coder) { super(coder); } @Override public void coding() { this.addNewKeyBoard(); super.coding(); } private void addNewKeyBoard() { System.out.println(“更换了新的机械键盘，噼里啪啦”); } } 4. 定义一个专门更换鼠标的装饰器 ```Java /** * 写代码以前换鼠标 */ public class CoderDecoratorB extends CoderDecorator { public CoderDecoratorB(Coder coder) { super(coder); } @Override public void coding() { this.addNewMouse(); super.coding(); } private void addNewMouse() { System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;); } } 定义一个更换电脑的装饰器 /** * 写代码以前换电脑 */ public class CoderDecoratorC extends CoderDecorator { public CoderDecoratorC(Coder coder) { super(coder); } @Override public void coding() { this.changeToMacbookPro(); super.coding(); } private void changeToMacbookPro() { System.out.println(&quot;电脑不好使，换了，美滋滋&quot;); } } 好了，现在老板可以根据不同程序猿的要求一一满足了 /** * 程序猿写代码 */ public class Client { public static void main(String[] args) { //创造一个程序猿A，并且开始写代码 Coder coderA = new Coder(); //换个键盘在写 CoderDecorator decoratorA = new CoderDecoratorA(coderA); //换个鼠标在写 decoratorA = new CoderDecoratorB(decoratorA); //把电脑也换了 decoratorA = new CoderDecoratorC(decoratorA); decoratorA.coding(); //创造一个程序猿B，并且开始写代码 Coder coderB = new Coder(); //换个键盘在写 CoderDecorator decoratorB = new CoderDecoratorA(coderB); //把电脑也换了 decoratorB = new CoderDecoratorC(decoratorB); decoratorB.coding(); } } 执行结果 //这里满足程序猿A的要求 电脑不好使，换了，美滋滋 换了新的鼠标，哒哒哒，哒哒哒 更换了新的机械键盘，噼里啪啦 我在写程序。。。 //这里满足程序猿B的要求 电脑不好使，换了，美滋滋 更换了新的机械键盘，噼里啪啦 我在写程序。。。</summary></entry><entry><title type="html">Javascript过滤前后空格</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html" rel="alternate" type="text/html" title="Javascript过滤前后空格" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html">&lt;h1 id=&quot;javascript过滤前后空格&quot;&gt;Javascript过滤前后空格&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript%E8%BF%87%E6%BB%A4%E5%89%8D%E5%90%8E%E7%A9%BA%E6%A0%BC&quot;&gt;Javascript过滤前后空格&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%9F%A5&quot;&gt;循环检查&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2&quot;&gt;正则表达式替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;JQuery&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;循环检查&quot;&gt;循环检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;//供使用者调用 
function trim(s){ 
  return trimRight(trimLeft(s)); 
} 
//去掉左边的空白 
function trimLeft(s){ 
  if(s == null) { 
    return &quot;&quot;; 
  } 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(0)) != -1) { 
    var j=0, i = str.length; 
    while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ 
      j++; 
    } 
    str = str.substring(j, i); 
  } 
  return str; 
} 

//去掉右边的空白
function trimRight(s){ 
  if(s == null) return &quot;&quot;; 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ 
    var i = str.length - 1; 
    while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ 
      i--; 
    } 
    str = str.substring(0, i+1); 
  } 
  return str; 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式替换&quot;&gt;正则表达式替换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;
String.prototype.Trim = function() //去左右空格;
{ 
    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
} 
String.prototype.LTrim = function() //去左空格;
{ 
    return this.replace(/(^\s*)/g, &quot;&quot;); 
} 
String.prototype.RTrim = function() //去右空格;
{ 
    return this.replace(/(\s*$)/g, &quot;&quot;); 
} 

//去左空格;
function ltrim(s){
    return s.replace(/(^\s*)/g, &quot;&quot;);
}
//去右空格;
function rtrim(s){
    return s.replace(/(\s*$)/g, &quot;&quot;);
}
//去左右空格;
function trim(s){
    return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;JQuery&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;// 使用方法
$.trim(str) 
// Jquery实现方法
function trim(str){  
    return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');  
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><summary type="html">Javascript过滤前后空格 Javascript过滤前后空格 循环检查 正则表达式替换 JQuery 循环检查 推荐 ☆☆☆ //供使用者调用 function trim(s){ return trimRight(trimLeft(s)); } //去掉左边的空白 function trimLeft(s){ if(s == null) { return &quot;&quot;; } var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(0)) != -1) { var j=0, i = str.length; while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ j++; } str = str.substring(j, i); } return str; } //去掉右边的空白 function trimRight(s){ if(s == null) return &quot;&quot;; var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ var i = str.length - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ i--; } str = str.substring(0, i+1); } return str; } 正则表达式替换 推荐 ☆☆☆☆ String.prototype.Trim = function() //去左右空格; { return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } String.prototype.LTrim = function() //去左空格; { return this.replace(/(^\s*)/g, &quot;&quot;); } String.prototype.RTrim = function() //去右空格; { return this.replace(/(\s*$)/g, &quot;&quot;); } //去左空格; function ltrim(s){ return s.replace(/(^\s*)/g, &quot;&quot;); } //去右空格; function rtrim(s){ return s.replace(/(\s*$)/g, &quot;&quot;); } //去左右空格; function trim(s){ return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } JQuery 推荐 ☆☆☆☆☆ // 使用方法 $.trim(str) // Jquery实现方法 function trim(str){ return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,''); }</summary></entry><entry><title type="html">Function.apply and Function.call in JavaScript</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&Function.call.html" rel="alternate" type="text/html" title="Function.apply and Function.call in JavaScript" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call.html">&lt;h1 id=&quot;functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%87%BD%E6%95%B0%E6%98%AF%E5%AF%B9%E8%B1%A1&quot;&gt;函数是对象&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#call&quot;&gt;Call()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apply&quot;&gt;Apply()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E6%95%B0&quot;&gt;参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;函数是对象&quot;&gt;函数是对象&lt;/h2&gt;
&lt;p&gt;JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。&lt;/p&gt;

&lt;p&gt;您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。&lt;/p&gt;

&lt;p&gt;函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。&lt;/p&gt;

&lt;p&gt;例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;function foo()
{
    alert('x');
}
 
alert(foo.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的执行结果是(请注意，这是一个字符串)
&lt;code class=&quot;highlighter-rouge&quot;&gt;function foo()
{
    alert('x');
}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;Call()&lt;/h2&gt;
&lt;p&gt;因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。
“函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。&lt;/p&gt;

&lt;p&gt;让我们从下面的代码开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
 
function f()
{
    alert(this.x);
}
 
f();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们有一个名为f()的全局函数。f()使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;这个关键字来引用x，但是注意我们不通过对象的实例调用函数。
那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。&lt;/p&gt;

&lt;p&gt;call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。
例如，下面是我们如何使用call()方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
 
function f()
{
    alert(this.x);
}
 
f();
f.call(o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f()的第一个调用将显示10的值，因为这引用了全局对象。
但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。&lt;/p&gt;

&lt;p&gt;摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。&lt;/p&gt;

&lt;p&gt;我们还可以通过call()将参数传递给目标函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.call(o, &quot;invoking f via call&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;apply&quot;&gt;Apply()&lt;/h2&gt;
&lt;p&gt;apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.apply(o, [&quot;invoking f through apply&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f1(message1)
{
    alert(message1 + this.x);
}
 
function f2(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func, args)
{
    func.apply(object, args);
}
 
g(o, f1, [&quot;the value of x = &quot;]);
g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。&lt;/p&gt;

&lt;p&gt;在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    alert(message);
}
 
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    // message param is the same as arguments[0]    
    // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的
    for(var i = 1; i &amp;lt; arguments.length; i++)
    {
        message += arguments[i];
    }
     
    alert(message); 
}
 
// this will say &quot;Hello&quot;
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。
在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func)
{           
    // arguments[0] == object
    // arguments[1] == func
    
    var args = []; // empty array
    // copy all other arguments we want to &quot;pass through&quot; 
    for(var i = 2; i &amp;lt; arguments.length; i++)
    {
        args.push(arguments[i]);
    }
 
    func.apply(object, args);
}
 
g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><summary type="html">Function.apply and Function.call in JavaScript Function.apply and Function.call in JavaScript 函数是对象 Call() Apply() 参数 函数是对象 JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。 您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。 函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。 例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码： function foo() { alert('x'); } alert(foo.toString()); 上面的执行结果是(请注意，这是一个字符串) function foo() { alert('x'); } Call() 因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。 “函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。 让我们从下面的代码开始： var x = 10; function f() { alert(this.x); } f(); 在这里，我们有一个名为f()的全局函数。f()使用this这个关键字来引用x，但是注意我们不通过对象的实例调用函数。 那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。 call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。 例如，下面是我们如何使用call()方法: var x = 10; var o = { x: 15 }; function f() { alert(this.x); } f(); f.call(o); f()的第一个调用将显示10的值，因为这引用了全局对象。 但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。 摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。 我们还可以通过call()将参数传递给目标函数: var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.call(o, &quot;invoking f via call&quot;); Apply() apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。 var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.apply(o, [&quot;invoking f through apply&quot;]); apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。 var o = { x: 15 }; function f1(message1) { alert(message1 + this.x); } function f2(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func, args) { func.apply(object, args); } g(o, f1, [&quot;the value of x = &quot;]); g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]); 参数 上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。 在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”: function f(message) { alert(message); } f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。 function f(message) { // message param is the same as arguments[0] // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的 for(var i = 1; i &amp;lt; arguments.length; i++) { message += arguments[i]; } alert(message); } // this will say &quot;Hello&quot; f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。 在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。 var o = { x: 15 }; function f(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func) { // arguments[0] == object // arguments[1] == func var args = []; // empty array // copy all other arguments we want to &quot;pass through&quot; for(var i = 2; i &amp;lt; arguments.length; i++) { args.push(arguments[i]); } func.apply(object, args); } g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;); 当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。 原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx</summary></entry><entry><title type="html">Mybatis一级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis一级缓存" /><published>2017-12-15T15:51:29+08:00</published><updated>2017-12-15T15:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-cache接口&quot;&gt;5. Cache接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-性能问题&quot;&gt;6. 性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/h1&gt;

&lt;p&gt;每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。&lt;/p&gt;

&lt;p&gt;肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/21.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SqlSession级别的数据缓存，称为一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/h1&gt;

&lt;p&gt;一级缓存由SqlSession控制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/22.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSession&lt;/code&gt;将它的工作交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;中拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;，则对于&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;对象而言，它将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;对象维护缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/23.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PerpetualCache的实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * @author Clinton Begin
 */
public class PerpetualCache implements Cache {

  private final String id;

  private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;();

  public PerpetualCache(String id) {
    this.id = id;
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public int getSize() {
    return cache.size();
  }

  @Override
  public void putObject(Object key, Object value) {
    cache.put(key, value);
  }

  @Override
  public Object getObject(Object key) {
    return cache.get(key);
  }

  @Override
  public Object removeObject(Object key) {
    return cache.remove(key);
  }

  @Override
  public void clear() {
    cache.clear();
  }

  @Override
  public ReadWriteLock getReadWriteLock() {
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    if (this == o) {
      return true;
    }
    if (!(o instanceof Cache)) {
      return false;
    }

    Cache otherCache = (Cache) o;
    return getId().equals(otherCache.getId());
  }

  @Override
  public int hashCode() {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    return getId().hashCode();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/24.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果命中，则直接将缓存结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没命中：&lt;/p&gt;

    &lt;p&gt;4.1  去数据库中查询数据，得到查询结果；&lt;/p&gt;

    &lt;p&gt;4.2  将key和查询到的结果分别作为key,value对存储到Cache中；&lt;/p&gt;

    &lt;p&gt;4.3. 将查询结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/25.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-cache接口&quot;&gt;5. Cache接口&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/26.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。&lt;/p&gt;

&lt;p&gt;MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。&lt;/p&gt;

&lt;p&gt;Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。&lt;/p&gt;

&lt;p&gt;现在最核心的问题出现了：怎样来确定一次查询的特征值？&lt;/p&gt;

&lt;p&gt;换句话说就是：怎样判断某两次查询是完全相同的查询？&lt;/p&gt;

&lt;p&gt;也可以这样说：如何确定Cache中的key值？&lt;/p&gt;

&lt;p&gt;MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;传入的 statementId&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传递给java.sql.Statement要设置的参数值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CacheKey由以下条件决定：
&lt;strong&gt;statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CacheKey的创建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    CacheKey cacheKey = new CacheKey();
    cacheKey.update(ms.getId());//StatementId
    cacheKey.update(rowBounds.getOffset());//rowBounds.offset
    cacheKey.update(rowBounds.getLimit());//rowBounds.limit
    cacheKey.update(boundSql.getSql());//Sql
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    // mimic DefaultParameterHandler logic
    for (ParameterMapping parameterMapping : parameterMappings) {
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        String propertyName = parameterMapping.getProperty();
        if (boundSql.hasAdditionalParameter(propertyName)) {
          value = boundSql.getAdditionalParameter(propertyName);
        } else if (parameterObject == null) {
          value = null;
        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        cacheKey.update(value);
      }
    }
    if (configuration.getEnvironment() != null) {
      // issue #176
      cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-性能问题&quot;&gt;6. 性能问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;一级缓存没有维护容量和大小限制&lt;/li&gt;
  &lt;li&gt;一级缓存没有更新缓存和缓存过期的概念&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">1. 一级缓存的作用 2. 一级缓存的依赖关系 3. 一级缓存的生命周期 4. 一级缓存的实现 5. Cache接口 6. 性能问题 1. 一级缓存的作用 每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。 肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。 SqlSession级别的数据缓存，称为一级缓存 2. 一级缓存的依赖关系 一级缓存由SqlSession控制。 SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。 Executor接口的实现类BaseExecutor中拥有一个Cache接口的实现类PerpetualCache，则对于BaseExecutor对象而言，它将使用PerpetualCache对象维护缓存。 PerpetualCache的实现代码 /** * @author Clinton Begin */ public class PerpetualCache implements Cache { private final String id; private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;(); public PerpetualCache(String id) { this.id = id; } @Override public String getId() { return id; } @Override public int getSize() { return cache.size(); } @Override public void putObject(Object key, Object value) { cache.put(key, value); } @Override public Object getObject(Object key) { return cache.get(key); } @Override public Object removeObject(Object key) { return cache.remove(key); } @Override public void clear() { cache.clear(); } @Override public ReadWriteLock getReadWriteLock() { return null; } @Override public boolean equals(Object o) { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } if (this == o) { return true; } if (!(o instanceof Cache)) { return false; } Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); } @Override public int hashCode() { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } return getId().hashCode(); } } 3. 一级缓存的生命周期 MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 4. 一级缓存的实现 对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 4.1 去数据库中查询数据，得到查询结果； 4.2 将key和查询到的结果分别作为key,value对存储到Cache中； 4.3. 将查询结果返回； 结束。 5. Cache接口 MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。 MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ 换句话说就是：怎样判断某两次查询是完全相同的查询？ 也可以这样说：如何确定Cache中的key值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 传入的 statementId 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）； 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 传递给java.sql.Statement要设置的参数值 CacheKey由以下条件决定： statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值 CacheKey的创建 @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { if (closed) { throw new ExecutorException(&quot;Executor was closed.&quot;); } CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId());//StatementId cacheKey.update(rowBounds.getOffset());//rowBounds.offset cacheKey.update(rowBounds.getLimit());//rowBounds.limit cacheKey.update(boundSql.getSql());//Sql List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数 TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic for (ParameterMapping parameterMapping : parameterMappings) { if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } cacheKey.update(value); } } if (configuration.getEnvironment() != null) { // issue #176 cacheKey.update(configuration.getEnvironment().getId()); } return cacheKey; } 构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法. public void update(Object object) { int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); } 6. 性能问题 一级缓存没有维护容量和大小限制 一级缓存没有更新缓存和缓存过期的概念</summary></entry></feed>