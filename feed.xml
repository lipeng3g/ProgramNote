<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ProgramNote/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ProgramNote/" rel="alternate" type="text/html" hreflang="zh" /><updated>2018-01-02T16:54:22+08:00</updated><id>http://localhost:4000/ProgramNote/</id><title type="html">lipeng’s blog</title><subtitle>lipeng's Blog
</subtitle><author><name>lipeng</name><email>lipeng3g@gmail.com</email></author><entry><title type="html">Java常用关键字总结</title><link href="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html" rel="alternate" type="text/html" title="Java常用关键字总结" /><published>2018-01-02T16:47:46+08:00</published><updated>2018-01-02T16:47:46+08:00</updated><id>http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2018/01/02/Java%E5%85%B3%E9%94%AE%E5%AD%97.html">&lt;h1 id=&quot;abstrate&quot;&gt;abstrate&lt;/h1&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;abstract 关键字可以&lt;strong&gt;修改类或方法&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 类可以扩展（增加子类），但&lt;strong&gt;不能直接实例化&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。&lt;/p&gt;

&lt;p&gt;如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。&lt;/p&gt;

&lt;p&gt;abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。&lt;/p&gt;

&lt;p&gt;final 类的方法都不能是 abstract，因为 final 类不能有子类。&lt;/p&gt;

&lt;h1 id=&quot;break&quot;&gt;break&lt;/h1&gt;
&lt;h2 id=&quot;说明-1&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;break 总是退出最深层的 while、for、do 或 switch 语句。&lt;/p&gt;

&lt;h1 id=&quot;case&quot;&gt;case&lt;/h1&gt;
&lt;h2 id=&quot;说明-2&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用来标记 switch 语句中的每个分支。&lt;/p&gt;

&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;case 块没有隐式结束点。&lt;/p&gt;

&lt;p&gt;break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。&lt;/p&gt;

&lt;p&gt;如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。&lt;/p&gt;

&lt;h1 id=&quot;catch&quot;&gt;catch&lt;/h1&gt;
&lt;h2 id=&quot;说明-3&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块&lt;/p&gt;

&lt;h2 id=&quot;总结-3&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;br /&gt;
如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。&lt;br /&gt;
如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。&lt;/p&gt;

&lt;h1 id=&quot;continue&quot;&gt;continue&lt;/h1&gt;
&lt;h2 id=&quot;说明-4&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。&lt;/p&gt;

&lt;h2 id=&quot;总结-4&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。&lt;/p&gt;

&lt;h1 id=&quot;extends&quot;&gt;extends&lt;/h1&gt;
&lt;h2 id=&quot;说明-5&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。&lt;/p&gt;

&lt;h2 id=&quot;总结-5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类只能扩展一个其他类。&lt;/p&gt;

&lt;h1 id=&quot;final&quot;&gt;final&lt;/h1&gt;
&lt;h2 id=&quot;说明-6&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。&lt;br /&gt;
final 关键字可以应用于方法，以指示不能重写任何子类中的方法。&lt;/p&gt;

&lt;h2 id=&quot;总结-6&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。&lt;/p&gt;

&lt;p&gt;一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。&lt;/p&gt;

&lt;h1 id=&quot;finally&quot;&gt;finally&lt;/h1&gt;
&lt;h2 id=&quot;说明-7&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。&lt;br /&gt;
finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。&lt;/p&gt;

&lt;h2 id=&quot;总结-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。&lt;br /&gt;
每个 try 块都必须至少有一个 catch 或 finally 子句。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;finally语句在return语句执行之后return返回之前执行的。&lt;/li&gt;
  &lt;li&gt;finally块中的return语句会覆盖try块中的return返回。&lt;/li&gt;
  &lt;li&gt;如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题）&lt;/li&gt;
  &lt;li&gt;try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。&lt;/li&gt;
  &lt;li&gt;当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lanxuezaipiao/p/3440471.html&quot;&gt;阅读更多&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;implements&quot;&gt;implements&lt;/h1&gt;
&lt;h2 id=&quot;说明-8&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。&lt;/p&gt;

&lt;h2 id=&quot;总结-8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;子类必须提供在 接口中所声明的所有方法的实现。&lt;br /&gt;
子类可以声明其他方法和变量，并扩展另一个类。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;instanceof&quot;&gt;instanceof&lt;/h1&gt;
&lt;h2 id=&quot;说明-9&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;instanceof 关键字用来确定对象所属的类。&lt;/p&gt;

&lt;h1 id=&quot;interface&quot;&gt;interface&lt;/h1&gt;
&lt;h2 id=&quot;说明-10&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;interface 关键字用来声明新的 Java 接口，接口是方法的集合。&lt;/p&gt;

&lt;h2 id=&quot;总结-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;实现了接口的任何类都必须提供在该接口中的所有方法的实现。&lt;br /&gt;
一个类可以实现多个接口。&lt;/p&gt;

&lt;h1 id=&quot;native&quot;&gt;native&lt;/h1&gt;
&lt;h2 id=&quot;说明-11&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。&lt;/p&gt;

&lt;h1 id=&quot;private&quot;&gt;private&lt;/h1&gt;
&lt;h2 id=&quot;说明-12&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      private class MyPrivateClass
      {
      }
      private int i;
      private String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-10&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;protected&quot;&gt;protected&lt;/h1&gt;
&lt;h2 id=&quot;说明-13&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      protected class MyPrivateClass
      {
      }
      protected int i;
      protected String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-11&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。&lt;br /&gt;
所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。&lt;/p&gt;

&lt;h1 id=&quot;public&quot;&gt;public&lt;/h1&gt;
&lt;h2 id=&quot;说明-14&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public class MyPrivateClass
      {
      }
      public int i;
      public String myMethod()
      {
        &amp;lt;statements&amp;gt;
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-12&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以在其他任何类或包中引用 public 类、方法或字段。&lt;/p&gt;

&lt;h1 id=&quot;static&quot;&gt;static&lt;/h1&gt;
&lt;h2 id=&quot;说明-15&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyPublicClass
   {
      public final static int MAX_OBJECTS = 100;
      static int _numObjects = 0;
      static class MyStaticClass
      {
      }
    
      static int getNumObjects()
      {
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-13&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。&lt;br /&gt;
static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。&lt;br /&gt;
static 字段（类的成员变量）在类的所有实例中只存在一次。&lt;br /&gt;
可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。&lt;br /&gt;
模式：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; &lt;/code&gt;&lt;br /&gt;
通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。&lt;/p&gt;

&lt;h1 id=&quot;super&quot;&gt;super&lt;/h1&gt;
&lt;h2 id=&quot;说明-16&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;super 关键字用于引用使用该关键字的类的超类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public MyClass(String arg)
      {
         super(arg);
      }
      public String myStringMethod()
      {
         return super.otherStringMethod();
      }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;总结-14&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为独立语句出现的 super 表示调用超类的构造方法。&lt;br /&gt;
super.&lt;methodName&gt;() 表示调用超类的方法。&lt;/methodName&gt;&lt;/p&gt;

&lt;h1 id=&quot;synchronized&quot;&gt;synchronized&lt;/h1&gt;
&lt;h2 id=&quot;说明-17&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      public synchronized static String mySyncStaticMethod()
      {
      }
      public synchronized String mySyncMethod()
      {
      }
   {
   public class MyOtherClass
   {
      Object someObj;
      public String myMethod()
      {
         &amp;lt;statements&amp;gt;
         synchronized (someObj)
         {
            &amp;lt;statements affecting someObj&amp;gt;
         }
      }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-15&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;synchronized 关键字可防止代码的关键代码段一次被多个线程执行。&lt;br /&gt;
如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。&lt;br /&gt;
如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。&lt;br /&gt;
如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。  &lt;br /&gt;
每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。   &lt;br /&gt;
实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/p&gt;

&lt;h1 id=&quot;transient&quot;&gt;transient&lt;/h1&gt;
&lt;h2 id=&quot;说明-18&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。&lt;/p&gt;

&lt;h2 id=&quot;总结-16&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。&lt;/li&gt;
  &lt;li&gt;transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。&lt;/li&gt;
  &lt;li&gt;被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特殊说明&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。&lt;br /&gt;
若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。&lt;/p&gt;

&lt;h1 id=&quot;volatile&quot;&gt;volatile&lt;/h1&gt;
&lt;h2 id=&quot;说明-19&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字用于表示可以被多个线程异步修改的成员变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   public class MyClass
   {
      volatile int sharedValue;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结-17&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。&lt;/p&gt;

&lt;p&gt;当一个变量定义为 volatile 之后，将具备两种特性：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;volatile 性能：
　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/p&gt;

&lt;p&gt;在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。&lt;/p&gt;

&lt;h2 id=&quot;特殊说明-1&quot;&gt;特殊说明&lt;/h2&gt;
&lt;p&gt;volatile 关键字在许多 Java 虚拟机中都没有实现。&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">abstrate 说明 abstract 关键字可以修改类或方法。 abstract 类可以扩展（增加子类），但不能直接实例化。 abstract 方法必须在某个子类中重写，abstract 方法的类本来就是抽象类，并且必须声明为 abstract。 总结 仅当 abstract 类的子类实现其超类的所有 abstract 方法时，才能实例化 abstract 类的子类。这种类称为具体类，以区别于 abstract 类 。 如果 abstract 类的子类没有实现其超类的所有 abstract 方法，该子类也是 abstract 类。 abstract 关键字不能应用于 static、private 或 final 方法，因为这些方法不能被重写，因此，不能在子类中实现。 final 类的方法都不能是 abstract，因为 final 类不能有子类。 break 说明 用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 总结 break 总是退出最深层的 while、for、do 或 switch 语句。 case 说明 用来标记 switch 语句中的每个分支。 总结 case 块没有隐式结束点。 break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 catch 说明 catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块 总结 开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。 如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 continue 说明 continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 总结 continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。 extends 说明 用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。 总结 一个类只能扩展一个其他类。 final 说明 final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。 final 关键字可以应用于方法，以指示不能重写任何子类中的方法。 总结 一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。 一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。 finally 说明 finally 关键字用来定义始终在 try-catch-finally 语句中执行的块。 finally 块通常包含清理代码，用在部分执行 try 块后恢复正常运行。 总结 开始和结束标记 { 和 } 是 finally 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 finally语句在return语句执行之后return返回之前执行的。 finally块中的return语句会覆盖try块中的return返回。 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。（涉及到Java传值得问题） try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。 阅读更多 implements 说明 implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。 总结 子类必须提供在 接口中所声明的所有方法的实现。 子类可以声明其他方法和变量，并扩展另一个类。 一个类可以实现多个接口。 instanceof 说明 instanceof 关键字用来确定对象所属的类。 interface 说明 interface 关键字用来声明新的 Java 接口，接口是方法的集合。 总结 实现了接口的任何类都必须提供在该接口中的所有方法的实现。 一个类可以实现多个接口。 native 说明 native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。 private 说明 private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 public class MyPublicClass { private class MyPrivateClass { } private int i; private String myMethod() { &amp;lt;statements&amp;gt; } } 总结 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 protected 说明 protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { protected class MyPrivateClass { } protected int i; protected String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 public 说明 public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 public class MyPublicClass { public class MyPrivateClass { } public int i; public String myMethod() { &amp;lt;statements&amp;gt; } } 总结 可以在其他任何类或包中引用 public 类、方法或字段。 static 说明 static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 public class MyPublicClass { public final static int MAX_OBJECTS = 100; static int _numObjects = 0; static class MyStaticClass { } static int getNumObjects() { } } 总结 通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。在上面的示例中，MyClass 类外部的代码以 MyClass.getNumObjects() 的形式调用 getNumObjects() static 方法。 模式： public final static &amp;lt;type&amp;gt; varName = &amp;lt;value&amp;gt;; 通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。 super 说明 super 关键字用于引用使用该关键字的类的超类。 public class MyClass { public MyClass(String arg) { super(arg); } public String myStringMethod() { return super.otherStringMethod(); } } 总结 作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法。 synchronized 说明 synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 public class MyClass { public synchronized static String mySyncStaticMethod() { } public synchronized String mySyncMethod() { } { public class MyOtherClass { Object someObj; public String myMethod() { &amp;lt;statements&amp;gt; synchronized (someObj) { &amp;lt;statements affecting someObj&amp;gt; } } } 总结 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法（如上例中的 MySyncStaticMethod），那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法（如上例中的 MySyncMethod），那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 transient 说明 transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 总结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 特殊说明 对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行。 若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。 volatile 说明 volatile 关键字用于表示可以被多个线程异步修改的成员变量。 public class MyClass { volatile int sharedValue; } 总结 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 当一个变量定义为 volatile 之后，将具备两种特性： 保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障。 volatile 性能： 　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 特殊说明 volatile 关键字在许多 Java 虚拟机中都没有实现。</summary></entry><entry><title type="html">Mybatis初始化(2)</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html" rel="alternate" type="text/html" title="Mybatis初始化(2)" /><published>2017-12-25T20:27:29+08:00</published><updated>2017-12-25T20:27:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html">&lt;h1 id=&quot;mybatis源码解析一mybatis初始化过程解析&quot;&gt;MyBatis源码解析(一)——MyBatis初始化过程解析&lt;/h1&gt;

&lt;h1 id=&quot;1-准备工作&quot;&gt;1. 准备工作&lt;/h1&gt;

&lt;p&gt;为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-94ca3998bee0abb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/294&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-product-产品实体类&quot;&gt;1.1 Product 产品实体类&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;12-productmapper-产品持久化接口&quot;&gt;1.2 ProductMapper 产品持久化接口&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&amp;lt;Product&amp;gt; selectProductList();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-productmapperxml-产品映射文件&quot;&gt;1.3 ProductMapper.xml 产品映射文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectProductList&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.entity.Product&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        select * from product
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;14-dbproperties-数据库配置文件&quot;&gt;1.4 db.properties 数据库配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8
username=root
password=xxxxxx

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-mybatisxml-mybatis的配置文件&quot;&gt;1.5 mybatis.xml MyBatis的配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${driver}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${username}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${password}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team/njupt/mapper/ProductMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;16-main-主函数&quot;&gt;1.6 Main 主函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        String resource = &quot;mybatis.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-mybatis初始化过程&quot;&gt;2. MyBatis初始化过程&lt;/h1&gt;

&lt;h2 id=&quot;21-获取配置文件&quot;&gt;2.1 获取配置文件&lt;/h2&gt;

&lt;p&gt;当系统初始化时，首先会读取配置文件，并将其解析成InputStream&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String resource = &quot;mybatis.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;22-创建sqlsessionfactorybuilder对象&quot;&gt;2.2 创建SqlSessionFactoryBuilder对象&lt;/h2&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;的名字中可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;是用来创建&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;对象的。
来看一下SqlSessionFactoryBuilder源码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-b0f3e995ac56f20a.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;h2 id=&quot;23-sqlsessionfactory创建过程&quot;&gt;2.3 SqlSessionFactory创建过程&lt;/h2&gt;

&lt;p&gt;下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;231-构造xmlconfigbuilder对象&quot;&gt;2.3.1 构造XMLConfigBuilder对象&lt;/h4&gt;

&lt;p&gt;build函数首先会构造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;的体系结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-3998f972a6a4e251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;是用来解析XML配置文件的，不同类型&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;用来解析MyBatis配置文件的不同部位。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;用来解析MyBatis的配置文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;用来解析MyBatis中的映射文件（如上文提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProductMapper.xml&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLStatementBuilder&lt;/code&gt;用来解析映射文件中的SQL语句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这些&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;都有一个共同的父类——&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;。这个父类维护了一个全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，MyBatis的配置文件解析后就以&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的形式存储。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象时，就会初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，并且在初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的时候，一些别名会被注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
super(new Configuration());
ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
this.configuration.setVariables(props);
this.parsed = false;
this.environment = environment;
this.parser = parser;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Configuration() {
typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);

typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);
typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);
typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);
……
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;232-解析配置文件&quot;&gt;2.3.2 解析配置文件&lt;/h3&gt;

&lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象之后，接下来就可以用它来解析配置文件了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void parseConfiguration(XNode root) {
  try {
    // 解析&amp;lt;properties&amp;gt;节点
    propertiesElement(root.evalNode(&quot;properties&quot;));
    // 解析&amp;lt;settings&amp;gt;节点
    Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
    loadCustomVfs(settings);
    // 解析&amp;lt;typeAliases&amp;gt;节点
    typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
    // 解析&amp;lt;plugins&amp;gt;节点
    pluginElement(root.evalNode(&quot;plugins&quot;));
    // 解析&amp;lt;objectFactory&amp;gt;节点
    objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
    objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
    // 解析&amp;lt;reflectorFactory&amp;gt;节点
    reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
    settingsElement(settings);
    // 解析&amp;lt;environments&amp;gt;节点
    environmentsElement(root.evalNode(&quot;environments&quot;));
    databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
    typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
    // 解析&amp;lt;mappers&amp;gt;节点
    mapperElement(root.evalNode(&quot;mappers&quot;));
  } catch (Exception e) {
    throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;会依次解析配置文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; settings &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; environments&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; typeAliases &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; plugins &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; mappers &amp;gt;&lt;/code&gt;等属性。下面介绍下几个重要属性的解析过程。&lt;/p&gt;

&lt;h4 id=&quot;2321-properties节点的解析过程&quot;&gt;2.3.2.1 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;节点的解析过程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的定义如下：

    
&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;
  &amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的解析过程：

&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
      * @Param context &amp;lt;properties&amp;gt;节点
      */
    private void propertiesElement(XNode context) throws Exception {
      if (context != null) {
        // 获取&amp;lt;properties&amp;gt;节点的所有子节点
        Properties defaults = context.getChildrenAsProperties();
        // 获取&amp;lt;properties&amp;gt;节点上的resource属性
        String resource = context.getStringAttribute(&quot;resource&quot;);
        // 获取&amp;lt;properties&amp;gt;节点上的url属性
        String url = context.getStringAttribute(&quot;url&quot;);
        // resource和url不能同时存在
        if (resource != null &amp;amp;&amp;amp; url != null) {
          throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);
        }
        if (resource != null) {
          // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中        
          defaults.putAll(Resources.getResourceAsProperties(resource));
        } else if (url != null) {
          // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中
          defaults.putAll(Resources.getUrlAsProperties(url));
        }
        // 获取configuration中原本的属性，并添加至defaults容器中
        Properties vars = configuration.getVariables();
        if (vars != null) {
          defaults.putAll(vars);
        }
        parser.setVariables(defaults);
        // 将defaults容器添加至configuration中
        configuration.setVariables(defaults);
      }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。
*   然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。）
*   最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2322-节点的解析过程&quot;&gt;2.3.2.2 &lt;settings&gt;节点的解析过程&lt;/settings&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的定义如下：

&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;settings&amp;gt;
      &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的解析过程：
`&lt;settings&gt;`属性的解析过程和 `&lt;properties&gt;`属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。

&lt;/properties&gt;&lt;/settings&gt;&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2323-属性的解析过程&quot;&gt;2.3.2.3 &lt;typeAliases&gt;属性的解析过程&lt;/typeAliases&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;属性的定义方式有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方式1：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt;
  &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方式2：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&amp;lt; typeAlias &amp;gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute(&quot;alias&quot;);
        String type = child.getStringAttribute(&quot;type&quot;);
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAlias&amp;gt;&lt;/code&gt;节点，那么MyBatis就会给指定的类起指定的别名。&lt;/li&gt;
  &lt;li&gt;这些别名都会被存入&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2324-节点的解析过程&quot;&gt;2.3.2.4 &lt;mappers&gt;节点的解析过程&lt;/mappers&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的定义方式有如下四种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方式1：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式2：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式3：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式4：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&amp;lt;mappers&amp;gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&amp;lt;mapper&amp;gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis会遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;下所有的子节点，如果当前遍历到的节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;，则MyBatis会将该包下的所有Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
  &lt;li&gt;如果当前节点为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在解析前，首先需要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;，创建过程如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) {
  // 将configuration赋给BaseBuilder
  super(configuration);
  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）
  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);
  this.parser = parser;
  this.sqlFragments = sqlFragments;
  this.resource = resource;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;首先会初始化父类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
      &lt;li&gt;然后创建&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void parse() {
  // 若当前的Mapper.xml尚未被解析，则开始解析
  // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了
  if (!configuration.isResourceLoaded(resource)) {
    // 解析&amp;lt;mapper&amp;gt;节点
    configurationElement(parser.evalNode(&quot;/mapper&quot;));
    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析
    configuration.addLoadedResource(resource);
    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中
    bindMapperForNamespace();
  }

  parsePendingResultMaps();
  parsePendingCacheRefs();
  parsePendingStatements();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configurationElement&lt;/code&gt;函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void configurationElement(XNode context) {
try {
  // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁
  String namespace = context.getStringAttribute(&quot;namespace&quot;);
  if (namespace == null || namespace.equals(&quot;&quot;)) {
    throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;);
  }
  // 将namespace属性值赋给builderAssistant
  builderAssistant.setCurrentNamespace(namespace);
  // 解析&amp;lt;cache-ref&amp;gt;节点
  cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
  // 解析&amp;lt;cache&amp;gt;节点
  cacheElement(context.evalNode(&quot;cache&quot;));
  // 解析&amp;lt;parameterMap&amp;gt;节点
  parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
  // 解析&amp;lt;resultMap&amp;gt;节点
  resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
  // 解析&amp;lt;sql&amp;gt;节点
  sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
  // 解析sql语句      
  buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
} catch (Exception e) {
  throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMapElements&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点，这些节点会被解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMaps&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt;
  &amp;lt;constructor&amp;gt;
     &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt;
     &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt;
  &amp;lt;/constructor&amp;gt;
  &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt;
  &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception {
  ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的id属性
  String id = resultMapNode.getStringAttribute(&quot;id&quot;,
    resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型）
  String type = resultMapNode.getStringAttribute(&quot;type&quot;,
    resultMapNode.getStringAttribute(&quot;ofType&quot;,
        resultMapNode.getStringAttribute(&quot;resultType&quot;,
            resultMapNode.getStringAttribute(&quot;javaType&quot;))));
  // 获取extends属性
  String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);
  // 获取autoMapping属性
  Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);
  // 将resultMap的返回值类型转换成Class对象
  Class&amp;lt;?&amp;gt; typeClass = resolveClass(type);
  Discriminator discriminator = null;
  // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;();
  resultMappings.addAll(additionalResultMappings);
  // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren();
  for (XNode resultChild : resultChildren) {
    // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去
    if (&quot;constructor&quot;.equals(resultChild.getName())) {
      processConstructorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去
    else if (&quot;discriminator&quot;.equals(resultChild.getName())) {
      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去
    else {
      // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property
      List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;();
      if (&quot;id&quot;.equals(resultChild.getName())) {
        flags.add(ResultFlag.ID);
      }
      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
    }
  }
  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）
  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
  try {
    return resultMapResolver.resolve();
  } catch (IncompleteElementException  e) {
    configuration.addIncompleteResultMap(resultMapResolver);
    throw e;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;，用于构造&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ResultMap resolve() {
  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlElement&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildStatementFromContext&lt;/code&gt;函数
该函数会将映射文件中的sql语句解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;MappedStatement&lt;/code&gt;对象，并存在&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mappedStatements&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;233-创建sqlsessionfactory对象&quot;&gt;2.3.3 创建SqlSessionFactory对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回过头来再看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;函数，刚才说了半天，介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;解析映射文件的过程，解析完成之后&lt;code class=&quot;highlighter-rouge&quot;&gt;parser.parse()&lt;/code&gt;函数会返回一个包含了映射文件解析结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;作为参数，创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;对象。
&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;是接口&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的一个实现类，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的体系结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-da2dbd8f1f2ac844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;创建完毕！&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">MyBatis源码解析(一)——MyBatis初始化过程解析 1. 准备工作 为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示： 1.1 Product 产品实体类 public class Product { private long id; private String productName; private String productContent; private String price; private int sort; private int falseSales; private long category_id; private byte type; private byte state; // PS：省略setter、getter函数 } 1.2 ProductMapper 产品持久化接口 public interface ProductMapper { /** * 查询所有的产品 * @return */ List&amp;lt;Product&amp;gt; selectProductList(); } 1.3 ProductMapper.xml 产品映射文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;team.njupt.mapper.ProductMapper&quot;&amp;gt; &amp;lt;select id=&quot;selectProductList&quot; resultType=&quot;team.njupt.entity.Product&quot;&amp;gt; select * from product &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 1.4 db.properties 数据库配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8 username=root password=xxxxxx 1.5 mybatis.xml MyBatis的配置文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;properties resource=&quot;db.properties&quot;&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;team/njupt/mapper/ProductMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 1.6 Main 主函数 public class Main { public static void main(String[] args) throws IOException { String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); try { ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class); List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList(); for (Product product : productList) { System.out.printf(product.toString()); } } finally { sqlSession.close(); } } } 2. MyBatis初始化过程 2.1 获取配置文件 当系统初始化时，首先会读取配置文件，并将其解析成InputStream String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); 2.2 创建SqlSessionFactoryBuilder对象 从SqlSessionFactoryBuilder的名字中可以看出，SqlSessionFactoryBuilder是用来创建SqlSessionFactory对象的。 来看一下SqlSessionFactoryBuilder源码： SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。 2.3 SqlSessionFactory创建过程 下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 2.3.1 构造XMLConfigBuilder对象 build函数首先会构造一个XMLConfigBuilder对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下XMLConfigBuilder的体系结构。 XMLxxxBuilder是用来解析XML配置文件的，不同类型XMLxxxBuilder用来解析MyBatis配置文件的不同部位。比如：XMLConfigBuilder用来解析MyBatis的配置文件，XMLMapperBuilder用来解析MyBatis中的映射文件（如上文提到的ProductMapper.xml），XMLStatementBuilder用来解析映射文件中的SQL语句。 这些XMLxxxBuilder都有一个共同的父类——BaseBuilder。这个父类维护了一个全局的Configuration对象，MyBatis的配置文件解析后就以Configuration对象的形式存储。 当创建XMLConfigBuilder对象时，就会初始化Configuration对象，并且在初始化Configuration对象的时候，一些别名会被注册到Configuration的typeAliasRegistry容器中。 private XMLConfigBuilder(XPathParser parser, String environment, Properties props) { super(new Configuration()); ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; } public Configuration() { typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); …… } 2.3.2 解析配置文件 当有了XMLConfigBuilder对象之后，接下来就可以用它来解析配置文件了。 private void parseConfiguration(XNode root) { try { // 解析&amp;lt;properties&amp;gt;节点 propertiesElement(root.evalNode(&quot;properties&quot;)); // 解析&amp;lt;settings&amp;gt;节点 Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); // 解析&amp;lt;typeAliases&amp;gt;节点 typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); // 解析&amp;lt;plugins&amp;gt;节点 pluginElement(root.evalNode(&quot;plugins&quot;)); // 解析&amp;lt;objectFactory&amp;gt;节点 objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); // 解析&amp;lt;reflectorFactory&amp;gt;节点 reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // 解析&amp;lt;environments&amp;gt;节点 environmentsElement(root.evalNode(&quot;environments&quot;)); databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); // 解析&amp;lt;mappers&amp;gt;节点 mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } 从上述代码中可以看到，XMLConfigBuilder会依次解析配置文件中的&amp;lt;properties&amp;gt;、&amp;lt; settings &amp;gt;、&amp;lt; environments&amp;gt;、&amp;lt; typeAliases &amp;gt;、&amp;lt; plugins &amp;gt;、&amp;lt; mappers &amp;gt;等属性。下面介绍下几个重要属性的解析过程。 2.3.2.1 &amp;lt;properties&amp;gt;节点的解析过程 节点的定义如下： &amp;lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt; &amp;lt;/properties&amp;gt; 节点的解析过程： /** * @Param context &amp;lt;properties&amp;gt;节点 */ private void propertiesElement(XNode context) throws Exception { if (context != null) { // 获取&amp;lt;properties&amp;gt;节点的所有子节点 Properties defaults = context.getChildrenAsProperties(); // 获取&amp;lt;properties&amp;gt;节点上的resource属性 String resource = context.getStringAttribute(&quot;resource&quot;); // 获取&amp;lt;properties&amp;gt;节点上的url属性 String url = context.getStringAttribute(&quot;url&quot;); // resource和url不能同时存在 if (resource != null &amp;amp;&amp;amp; url != null) { throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other.&quot;); } if (resource != null) { // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getResourceAsProperties(resource)); } else if (url != null) { // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getUrlAsProperties(url)); } // 获取configuration中原本的属性，并添加至defaults容器中 Properties vars = configuration.getVariables(); if (vars != null) { defaults.putAll(vars); } parser.setVariables(defaults); // 将defaults容器添加至configuration中 configuration.setVariables(defaults); } } * 首先读取`&amp;lt;resources&amp;gt;`节点下的所有`&amp;lt;resource&amp;gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。 * 然后读取`&amp;lt;resources&amp;gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。） * 最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。 2.3.2.2 节点的解析过程 节点的定义如下： &amp;lt;settings&amp;gt; &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;/settings&amp;gt; 节点的解析过程： ``属性的解析过程和 ``属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。 2.3.2.3 属性的解析过程 &amp;lt;typeAliases&amp;gt;属性的定义方式有如下两种： 方式1： &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt; &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 方式2： &amp;lt;typeAliases&amp;gt; &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。 &amp;lt;typeAliases&amp;gt;节点的解析过程如下： private void typeAliasesElement(XNode parent) { if (parent != null) { // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点 for (XNode child : parent.getChildren()) { // 若当前结点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;上的name属性（包名） String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中 configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } // 如果当前结点为&amp;lt; typeAlias &amp;gt; else { // 获取alias和type属性 String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); // 注册进configuration的typeAliasRegistry中 try { Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e); } } } } } 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;package&amp;gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名） 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;typeAlias&amp;gt;节点，那么MyBatis就会给指定的类起指定的别名。 这些别名都会被存入configuration的typeAliasRegistry容器中。 2.3.2.4 节点的解析过程 &amp;lt;mappers&amp;gt;节点的定义方式有如下四种： 方式1： &amp;lt;mappers&amp;gt; &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式2： &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式3： &amp;lt;mappers&amp;gt; &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式4： &amp;lt;mappers&amp;gt; &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;mappers&amp;gt;节点的解析过程如下： private void mapperElement(XNode parent) throws Exception { if (parent != null) { // 遍历&amp;lt;mappers&amp;gt;下所有子节点 for (XNode child : parent.getChildren()) { // 如果当前节点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名） String mapperPackage = child.getStringAttribute(&quot;name&quot;); // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中 configuration.addMappers(mapperPackage); } // 如果当前节点为&amp;lt;mapper&amp;gt; else { // 依次获取resource、url、class属性 String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); // 解析resource属性（Mapper.xml文件的路径） if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(resource); // 将Mapper.xml文件解析成输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } // 解析url属性（Mapper.xml文件的路径） else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } // 解析class属性（Mapper Class的全限定名） else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) { // 将Mapper Class的权限定名转化成Class对象 Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass); // 注册进configuration对象的mapperRegistry容器中 configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } MyBatis会遍历&amp;lt;mappers&amp;gt;下所有的子节点，如果当前遍历到的节点是&amp;lt;package&amp;gt;，则MyBatis会将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中。 如果当前节点为&amp;lt;mapper&amp;gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到configuration的mapperRegistry容器中。 其中，&amp;lt;mapper&amp;gt;节点的解析过程如下： XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); 在解析前，首先需要创建XMLMapperBuilder，创建过程如下： private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) { // 将configuration赋给BaseBuilder super(configuration); // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者） this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } 首先会初始化父类BaseBuilder，并将configuration赋给BaseBuilder； 然后创建MapperBuilderAssistant对象，该对象为XMLMapperBuilder的协助者，用来协助XMLMapperBuilder完成一些解析映射文件的动作。 当有了XMLMapperBuilder后，便可进入解析&amp;lt;mapper&amp;gt;的过程： public void parse() { // 若当前的Mapper.xml尚未被解析，则开始解析 // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了 if (!configuration.isResourceLoaded(resource)) { // 解析&amp;lt;mapper&amp;gt;节点 configurationElement(parser.evalNode(&quot;/mapper&quot;)); // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析 configuration.addLoadedResource(resource); // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中 bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements(); } configurationElement函数 private void configurationElement(XNode context) { try { // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁 String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;); } // 将namespace属性值赋给builderAssistant builderAssistant.setCurrentNamespace(namespace); // 解析&amp;lt;cache-ref&amp;gt;节点 cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); // 解析&amp;lt;cache&amp;gt;节点 cacheElement(context.evalNode(&quot;cache&quot;)); // 解析&amp;lt;parameterMap&amp;gt;节点 parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // 解析&amp;lt;resultMap&amp;gt;节点 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // 解析&amp;lt;sql&amp;gt;节点 sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 解析sql语句 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e); } } resultMapElements函数 该函数用于解析映射文件中所有的&amp;lt;resultMap&amp;gt;节点，这些节点会被解析成ResultMap对象，存储在Configuration对象的resultMaps容器中。 &amp;lt;resultMap&amp;gt;节点定义如下： &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt; &amp;lt;constructor&amp;gt; &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt; &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt; &amp;lt;/constructor&amp;gt; &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt; &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap&amp;gt;节点的解析过程： private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的id属性 String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型） String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // 获取extends属性 String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // 获取autoMapping属性 Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); // 将resultMap的返回值类型转换成Class对象 Class&amp;lt;?&amp;gt; typeClass = resolveClass(type); Discriminator discriminator = null; // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;(); resultMappings.addAll(additionalResultMappings); // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去 if (&quot;constructor&quot;.equals(resultChild.getName())) { processConstructorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去 else if (&quot;discriminator&quot;.equals(resultChild.getName())) { discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去 else { // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下） ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } ResultMapResolver这个类很纯粹，有且仅有一个函数resolve，用于构造ResultMap对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于MapperBuilderAssistant.addResultMap完成的。 public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } sqlElement函数 该函数用于解析映射文件中所有的&amp;lt;sql&amp;gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。 &amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt; buildStatementFromContext函数 该函数会将映射文件中的sql语句解析成MappedStatement对象，并存在configuration的mappedStatements。 2.3.3 创建SqlSessionFactory对象 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 回过头来再看一下SqlSessionFactory的build函数，刚才说了半天，介绍了XMLConfigBuilder解析映射文件的过程，解析完成之后parser.parse()函数会返回一个包含了映射文件解析结果的configuration对象，紧接着，这个对象将作为参数传递给另一个build函数，如下： public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 这个函数将configuration作为参数，创建了DefaultSqlSessionFactory对象。 DefaultSqlSessionFactory是接口SqlSessionFactory的一个实现类，SqlSessionFactory的体系结构如下图所示： 此时，SqlSessionFactory创建完毕！</summary></entry><entry><title type="html">Spring手动提交事务</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html" rel="alternate" type="text/html" title="Spring手动提交事务" /><published>2017-12-23T10:12:47+08:00</published><updated>2017-12-23T10:12:47+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html">&lt;p&gt;开篇之前先说一下问题来源，我是用了&lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;redisson&lt;/a&gt;作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;);
	if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
		RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;);
		if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
			// 吧啦吧啦
			// 这里是业务逻辑代码
			// 修改对象状态等等
		} else {
			//操作超时，请重新操作
		}
		if (BLock.isLocked()) {
			BLock.unlock();
		}
	} else {
		//操作超时，请重新操作
	}
	if (ALock.isLocked()) {
		ALock.unlock();
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。&lt;/p&gt;

&lt;p&gt;两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。&lt;/p&gt;

&lt;p&gt;结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。&lt;/p&gt;

&lt;p&gt;解决方案1：
	把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题
	这种方法也有缺点，部分业务处理需要在controller中进行&lt;/p&gt;

&lt;p&gt;解决方案2：
	service层手动提交事务，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	@Resource 
    private DataSourceTransactionManager transactionManager; 


	// 下面是手动提交
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();  
	// 事物隔离级别，开启新事务，这样会比较安全些。  
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); 
	// 获得事务状态 
	TransactionStatus status = transactionManager.getTransaction(def);  
	try {  
		transactionManager.commit(status);  
	} catch (Exception e) {  
		transactionManager.rollback(status);  
	}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><summary type="html">开篇之前先说一下问题来源，我是用了redisson作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。 RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;); if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;); if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { // 吧啦吧啦 // 这里是业务逻辑代码 // 修改对象状态等等 } else { //操作超时，请重新操作 } if (BLock.isLocked()) { BLock.unlock(); } } else { //操作超时，请重新操作 } if (ALock.isLocked()) { ALock.unlock(); } 这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。 两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。 结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。 解决方案1： 把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题 这种方法也有缺点，部分业务处理需要在controller中进行 解决方案2： service层手动提交事务，代码如下 @Resource private DataSourceTransactionManager transactionManager; // 下面是手动提交 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // 事物隔离级别，开启新事务，这样会比较安全些。 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); // 获得事务状态 TransactionStatus status = transactionManager.getTransaction(def); try { transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } 以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。 由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。</summary></entry><entry><title type="html">Mybatis二级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis二级缓存" /><published>2017-12-19T19:51:29+08:00</published><updated>2017-12-19T19:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/27.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。&lt;/p&gt;

&lt;p&gt;如果用户配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cacheEnabled=true&quot;&lt;/code&gt;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：&lt;code class=&quot;highlighter-rouge&quot;&gt;CachingExecutor&lt;/code&gt;，这时SqlSession使用CachingExecutor对象来完成操作请求。&lt;/p&gt;

&lt;p&gt;CachingExecutor对于查询请求，会先判断该查询请求在Application级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;二级缓存中是否有缓存结果&lt;/code&gt;，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。&lt;/p&gt;

&lt;h1 id=&quot;2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/28.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，&lt;/p&gt;

&lt;p&gt;CachingExecutor和Executor的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/29.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/h1&gt;

&lt;p&gt;Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置 为一个Mapper分配一个Cache缓存对象&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置 为多个Mapper分配相同的Cache对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/30.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID&lt;/p&gt;
&lt;h2 id=&quot;32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;如果你想让多个Mapper公用一个Cache的话，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;&lt;/code&gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/31.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/h1&gt;
&lt;p&gt;二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。&lt;/p&gt;

&lt;p&gt;虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`&lt;select&gt; `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。&lt;/select&gt;&lt;/cache&gt;&lt;/p&gt;

&lt;p&gt;如下所示，Select语句配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;useCache=&quot;true&quot;&lt;/code&gt;，则表明这条Select语句的查询会使用二级缓存。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;useCache=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开启二级缓存的条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true&lt;/li&gt;
  &lt;li&gt;该select语句所在的Mapper，配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cached-ref&amp;gt;&lt;/code&gt;节点，并且有效&lt;/li&gt;
  &lt;li&gt;该select语句的参数 useCache=true&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/h1&gt;
&lt;p&gt;二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库&lt;/p&gt;

&lt;h1 id=&quot;6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;使用MyBatis的二级缓存有三个选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis自身提供的缓存实现&lt;/p&gt;

    &lt;p&gt;MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义的Cache接口实现&lt;/p&gt;

    &lt;p&gt;MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache type=&quot;&quot;&amp;gt;&lt;/code&gt;节点的type属性上即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟第三方内存缓存库的集成&lt;/p&gt;

    &lt;p&gt;MyBatis还支持跟第三方内存缓存库如Memecached的集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/h1&gt;
&lt;p&gt;MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/32.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；&lt;/li&gt;
  &lt;li&gt;FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；&lt;/li&gt;
  &lt;li&gt;Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">1. Mybatis缓存机制整体设计 2. 二级缓存的基本原理 3. 二级缓存的划分 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 4. 开启二级缓存的条件 5. 缓存使用顺序 6. 二级缓存的实现方式 7. Mybatis自身提供的二级缓存实现 1. Mybatis缓存机制整体设计   当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。 如果用户配置了&quot;cacheEnabled=true&quot;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。 CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。 2. 二级缓存的基本原理 CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式， CachingExecutor和Executor的关系图 3. 二级缓存的划分 Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象 使用&amp;lt;cache&amp;gt;节点配置 为一个Mapper分配一个Cache缓存对象 使用&amp;lt;cache-ref&amp;gt;节点配置 为多个Mapper分配相同的Cache对象 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&amp;lt;cache&amp;gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象 每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 如果你想让多个Mapper公用一个Cache的话，你可以使用&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。 4. 开启二级缓存的条件 二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。 虽然在Mapper中配置了,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在` `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。 如下所示，Select语句配置了useCache=&quot;true&quot;，则表明这条Select语句的查询会使用二级缓存。 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&amp;gt; 开启二级缓存的条件 MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了&amp;lt;cache&amp;gt; 或&amp;lt;cached-ref&amp;gt;节点，并且有效 该select语句的参数 useCache=true 5. 缓存使用顺序 二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库 6. 二级缓存的实现方式 使用MyBatis的二级缓存有三个选择 MyBatis自身提供的缓存实现 MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等 用户自定义的Cache接口实现 MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&amp;lt;cache type=&quot;&quot;&amp;gt;节点的type属性上即可 跟第三方内存缓存库的集成 MyBatis还支持跟第三方内存缓存库如Memecached的集成 7. Mybatis自身提供的二级缓存实现 MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略： LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录； FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉； Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</summary></entry><entry><title type="html">装饰者模式简单理解</title><link href="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="装饰者模式简单理解" /><published>2017-12-19T13:51:29+08:00</published><updated>2017-12-19T13:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html">&lt;h1 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#装饰者模式&quot;&gt;装饰者模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#基本描述&quot;&gt;基本描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#代码实例&quot;&gt;代码实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;基本描述&quot;&gt;基本描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给对象动态地添加附加功能。&lt;/li&gt;
  &lt;li&gt;装饰者提供了一个灵活的拓展子类功能的备选方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个程序猿
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员
 */
public class Coder {

 public void coding() {
     System.out.println(&quot;我在写程序。。。&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个程序猿的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员装饰器
 */
public class CoderDecorator extends Coder {

 private Coder coder;

 public CoderDecorator(Coder coder) {
     this.coder = coder;
 }

 @Override
 public void coding() {
     coder.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个专门更换键盘的装饰器
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;写代码以前换键盘
 */
public class CoderDecoratorA extends CoderDecorator {&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;public CoderDecoratorA(Coder coder) {
     super(coder);
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public void coding() {
     this.addNewKeyBoard();
     super.coding();
 }&lt;/p&gt;

    &lt;p&gt;private void addNewKeyBoard() {
     System.out.println(“更换了新的机械键盘，噼里啪啦”);
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
4. 定义一个专门更换鼠标的装饰器
```Java

/**
 * 写代码以前换鼠标
 */
public class CoderDecoratorB extends CoderDecorator {

    public CoderDecoratorB(Coder coder) {
        super(coder);
    }

    @Override
    public void coding() {
        this.addNewMouse();
        super.coding();
    }

    private void addNewMouse() {
        System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个更换电脑的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 写代码以前换电脑
 */
public class CoderDecoratorC extends CoderDecorator {

 public CoderDecoratorC(Coder coder) {
     super(coder);
 }

 @Override
 public void coding() {
     this.changeToMacbookPro();
     super.coding();
 }

 private void changeToMacbookPro() {
     System.out.println(&quot;电脑不好使，换了，美滋滋&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;好了，现在老板可以根据不同程序猿的要求一一满足了
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序猿写代码
 */
public class Client {

 public static void main(String[] args) {
     //创造一个程序猿A，并且开始写代码
     Coder coderA = new Coder();
     //换个键盘在写
     CoderDecorator decoratorA = new CoderDecoratorA(coderA);
     //换个鼠标在写
     decoratorA = new CoderDecoratorB(decoratorA);
     //把电脑也换了
     decoratorA = new CoderDecoratorC(decoratorA);
     decoratorA.coding();

     //创造一个程序猿B，并且开始写代码
     Coder coderB = new Coder();
     //换个键盘在写
     CoderDecorator decoratorB = new CoderDecoratorA(coderB);
     //把电脑也换了
     decoratorB = new CoderDecoratorC(decoratorB);
     decoratorB.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这里满足程序猿A的要求
电脑不好使，换了，美滋滋
换了新的鼠标，哒哒哒，哒哒哒
更换了新的机械键盘，噼里啪啦
我在写程序。。。
//这里满足程序猿B的要求
电脑不好使，换了，美滋滋
更换了新的机械键盘，噼里啪啦
我在写程序。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>lipeng</name></author><category term="Java" /><summary type="html">装饰者模式 装饰者模式 基本描述 代码实例 基本描述 目的 给对象动态地添加附加功能。 装饰者提供了一个灵活的拓展子类功能的备选方案。 代码实例 公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。） 定义一个程序猿 /** * 程序员 */ public class Coder { public void coding() { System.out.println(&quot;我在写程序。。。&quot;); } } 定义一个程序猿的装饰器 /** * 程序员装饰器 */ public class CoderDecorator extends Coder { private Coder coder; public CoderDecorator(Coder coder) { this.coder = coder; } @Override public void coding() { coder.coding(); } } 定义一个专门更换键盘的装饰器 ```Java /** 写代码以前换键盘 */ public class CoderDecoratorA extends CoderDecorator { public CoderDecoratorA(Coder coder) { super(coder); } @Override public void coding() { this.addNewKeyBoard(); super.coding(); } private void addNewKeyBoard() { System.out.println(“更换了新的机械键盘，噼里啪啦”); } } 4. 定义一个专门更换鼠标的装饰器 ```Java /** * 写代码以前换鼠标 */ public class CoderDecoratorB extends CoderDecorator { public CoderDecoratorB(Coder coder) { super(coder); } @Override public void coding() { this.addNewMouse(); super.coding(); } private void addNewMouse() { System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;); } } 定义一个更换电脑的装饰器 /** * 写代码以前换电脑 */ public class CoderDecoratorC extends CoderDecorator { public CoderDecoratorC(Coder coder) { super(coder); } @Override public void coding() { this.changeToMacbookPro(); super.coding(); } private void changeToMacbookPro() { System.out.println(&quot;电脑不好使，换了，美滋滋&quot;); } } 好了，现在老板可以根据不同程序猿的要求一一满足了 /** * 程序猿写代码 */ public class Client { public static void main(String[] args) { //创造一个程序猿A，并且开始写代码 Coder coderA = new Coder(); //换个键盘在写 CoderDecorator decoratorA = new CoderDecoratorA(coderA); //换个鼠标在写 decoratorA = new CoderDecoratorB(decoratorA); //把电脑也换了 decoratorA = new CoderDecoratorC(decoratorA); decoratorA.coding(); //创造一个程序猿B，并且开始写代码 Coder coderB = new Coder(); //换个键盘在写 CoderDecorator decoratorB = new CoderDecoratorA(coderB); //把电脑也换了 decoratorB = new CoderDecoratorC(decoratorB); decoratorB.coding(); } } 执行结果 //这里满足程序猿A的要求 电脑不好使，换了，美滋滋 换了新的鼠标，哒哒哒，哒哒哒 更换了新的机械键盘，噼里啪啦 我在写程序。。。 //这里满足程序猿B的要求 电脑不好使，换了，美滋滋 更换了新的机械键盘，噼里啪啦 我在写程序。。。</summary></entry><entry><title type="html">Javascript过滤前后空格</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html" rel="alternate" type="text/html" title="Javascript过滤前后空格" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html">&lt;h1 id=&quot;javascript过滤前后空格&quot;&gt;Javascript过滤前后空格&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript%E8%BF%87%E6%BB%A4%E5%89%8D%E5%90%8E%E7%A9%BA%E6%A0%BC&quot;&gt;Javascript过滤前后空格&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%9F%A5&quot;&gt;循环检查&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2&quot;&gt;正则表达式替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;JQuery&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;循环检查&quot;&gt;循环检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;//供使用者调用 
function trim(s){ 
  return trimRight(trimLeft(s)); 
} 
//去掉左边的空白 
function trimLeft(s){ 
  if(s == null) { 
    return &quot;&quot;; 
  } 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(0)) != -1) { 
    var j=0, i = str.length; 
    while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ 
      j++; 
    } 
    str = str.substring(j, i); 
  } 
  return str; 
} 

//去掉右边的空白
function trimRight(s){ 
  if(s == null) return &quot;&quot;; 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ 
    var i = str.length - 1; 
    while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ 
      i--; 
    } 
    str = str.substring(0, i+1); 
  } 
  return str; 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式替换&quot;&gt;正则表达式替换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;
String.prototype.Trim = function() //去左右空格;
{ 
    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
} 
String.prototype.LTrim = function() //去左空格;
{ 
    return this.replace(/(^\s*)/g, &quot;&quot;); 
} 
String.prototype.RTrim = function() //去右空格;
{ 
    return this.replace(/(\s*$)/g, &quot;&quot;); 
} 

//去左空格;
function ltrim(s){
    return s.replace(/(^\s*)/g, &quot;&quot;);
}
//去右空格;
function rtrim(s){
    return s.replace(/(\s*$)/g, &quot;&quot;);
}
//去左右空格;
function trim(s){
    return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;JQuery&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;// 使用方法
$.trim(str) 
// Jquery实现方法
function trim(str){  
    return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');  
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><summary type="html">Javascript过滤前后空格 Javascript过滤前后空格 循环检查 正则表达式替换 JQuery 循环检查 推荐 ☆☆☆ //供使用者调用 function trim(s){ return trimRight(trimLeft(s)); } //去掉左边的空白 function trimLeft(s){ if(s == null) { return &quot;&quot;; } var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(0)) != -1) { var j=0, i = str.length; while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ j++; } str = str.substring(j, i); } return str; } //去掉右边的空白 function trimRight(s){ if(s == null) return &quot;&quot;; var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ var i = str.length - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ i--; } str = str.substring(0, i+1); } return str; } 正则表达式替换 推荐 ☆☆☆☆ String.prototype.Trim = function() //去左右空格; { return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } String.prototype.LTrim = function() //去左空格; { return this.replace(/(^\s*)/g, &quot;&quot;); } String.prototype.RTrim = function() //去右空格; { return this.replace(/(\s*$)/g, &quot;&quot;); } //去左空格; function ltrim(s){ return s.replace(/(^\s*)/g, &quot;&quot;); } //去右空格; function rtrim(s){ return s.replace(/(\s*$)/g, &quot;&quot;); } //去左右空格; function trim(s){ return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } JQuery 推荐 ☆☆☆☆☆ // 使用方法 $.trim(str) // Jquery实现方法 function trim(str){ return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,''); }</summary></entry><entry><title type="html">Function.apply and Function.call in JavaScript</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&Function.call.html" rel="alternate" type="text/html" title="Function.apply and Function.call in JavaScript" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call.html">&lt;h1 id=&quot;functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%87%BD%E6%95%B0%E6%98%AF%E5%AF%B9%E8%B1%A1&quot;&gt;函数是对象&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#call&quot;&gt;Call()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apply&quot;&gt;Apply()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E6%95%B0&quot;&gt;参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;函数是对象&quot;&gt;函数是对象&lt;/h2&gt;
&lt;p&gt;JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。&lt;/p&gt;

&lt;p&gt;您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。&lt;/p&gt;

&lt;p&gt;函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。&lt;/p&gt;

&lt;p&gt;例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;function foo()
{
    alert('x');
}
 
alert(foo.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的执行结果是(请注意，这是一个字符串)
&lt;code class=&quot;highlighter-rouge&quot;&gt;function foo()
{
    alert('x');
}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;Call()&lt;/h2&gt;
&lt;p&gt;因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。
“函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。&lt;/p&gt;

&lt;p&gt;让我们从下面的代码开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
 
function f()
{
    alert(this.x);
}
 
f();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们有一个名为f()的全局函数。f()使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;这个关键字来引用x，但是注意我们不通过对象的实例调用函数。
那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。&lt;/p&gt;

&lt;p&gt;call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。
例如，下面是我们如何使用call()方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
 
function f()
{
    alert(this.x);
}
 
f();
f.call(o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f()的第一个调用将显示10的值，因为这引用了全局对象。
但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。&lt;/p&gt;

&lt;p&gt;摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。&lt;/p&gt;

&lt;p&gt;我们还可以通过call()将参数传递给目标函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.call(o, &quot;invoking f via call&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;apply&quot;&gt;Apply()&lt;/h2&gt;
&lt;p&gt;apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.apply(o, [&quot;invoking f through apply&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f1(message1)
{
    alert(message1 + this.x);
}
 
function f2(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func, args)
{
    func.apply(object, args);
}
 
g(o, f1, [&quot;the value of x = &quot;]);
g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。&lt;/p&gt;

&lt;p&gt;在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    alert(message);
}
 
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    // message param is the same as arguments[0]    
    // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的
    for(var i = 1; i &amp;lt; arguments.length; i++)
    {
        message += arguments[i];
    }
     
    alert(message); 
}
 
// this will say &quot;Hello&quot;
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。
在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func)
{           
    // arguments[0] == object
    // arguments[1] == func
    
    var args = []; // empty array
    // copy all other arguments we want to &quot;pass through&quot; 
    for(var i = 2; i &amp;lt; arguments.length; i++)
    {
        args.push(arguments[i]);
    }
 
    func.apply(object, args);
}
 
g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><summary type="html">Function.apply and Function.call in JavaScript Function.apply and Function.call in JavaScript 函数是对象 Call() Apply() 参数 函数是对象 JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。 您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。 函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。 例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码： function foo() { alert('x'); } alert(foo.toString()); 上面的执行结果是(请注意，这是一个字符串) function foo() { alert('x'); } Call() 因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。 “函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。 让我们从下面的代码开始： var x = 10; function f() { alert(this.x); } f(); 在这里，我们有一个名为f()的全局函数。f()使用this这个关键字来引用x，但是注意我们不通过对象的实例调用函数。 那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。 call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。 例如，下面是我们如何使用call()方法: var x = 10; var o = { x: 15 }; function f() { alert(this.x); } f(); f.call(o); f()的第一个调用将显示10的值，因为这引用了全局对象。 但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。 摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。 我们还可以通过call()将参数传递给目标函数: var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.call(o, &quot;invoking f via call&quot;); Apply() apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。 var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.apply(o, [&quot;invoking f through apply&quot;]); apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。 var o = { x: 15 }; function f1(message1) { alert(message1 + this.x); } function f2(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func, args) { func.apply(object, args); } g(o, f1, [&quot;the value of x = &quot;]); g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]); 参数 上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。 在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”: function f(message) { alert(message); } f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。 function f(message) { // message param is the same as arguments[0] // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的 for(var i = 1; i &amp;lt; arguments.length; i++) { message += arguments[i]; } alert(message); } // this will say &quot;Hello&quot; f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。 在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。 var o = { x: 15 }; function f(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func) { // arguments[0] == object // arguments[1] == func var args = []; // empty array // copy all other arguments we want to &quot;pass through&quot; for(var i = 2; i &amp;lt; arguments.length; i++) { args.push(arguments[i]); } func.apply(object, args); } g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;); 当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。 原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx</summary></entry><entry><title type="html">Mybatis一级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis一级缓存" /><published>2017-12-15T15:51:29+08:00</published><updated>2017-12-15T15:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-cache接口&quot;&gt;5. Cache接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-性能问题&quot;&gt;6. 性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/h1&gt;

&lt;p&gt;每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。&lt;/p&gt;

&lt;p&gt;肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/21.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SqlSession级别的数据缓存，称为一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/h1&gt;

&lt;p&gt;一级缓存由SqlSession控制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/22.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSession&lt;/code&gt;将它的工作交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;中拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;，则对于&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;对象而言，它将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;对象维护缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/23.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PerpetualCache的实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * @author Clinton Begin
 */
public class PerpetualCache implements Cache {

  private final String id;

  private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;();

  public PerpetualCache(String id) {
    this.id = id;
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public int getSize() {
    return cache.size();
  }

  @Override
  public void putObject(Object key, Object value) {
    cache.put(key, value);
  }

  @Override
  public Object getObject(Object key) {
    return cache.get(key);
  }

  @Override
  public Object removeObject(Object key) {
    return cache.remove(key);
  }

  @Override
  public void clear() {
    cache.clear();
  }

  @Override
  public ReadWriteLock getReadWriteLock() {
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    if (this == o) {
      return true;
    }
    if (!(o instanceof Cache)) {
      return false;
    }

    Cache otherCache = (Cache) o;
    return getId().equals(otherCache.getId());
  }

  @Override
  public int hashCode() {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    return getId().hashCode();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/24.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果命中，则直接将缓存结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没命中：&lt;/p&gt;

    &lt;p&gt;4.1  去数据库中查询数据，得到查询结果；&lt;/p&gt;

    &lt;p&gt;4.2  将key和查询到的结果分别作为key,value对存储到Cache中；&lt;/p&gt;

    &lt;p&gt;4.3. 将查询结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/25.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-cache接口&quot;&gt;5. Cache接口&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/26.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。&lt;/p&gt;

&lt;p&gt;MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。&lt;/p&gt;

&lt;p&gt;Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。&lt;/p&gt;

&lt;p&gt;现在最核心的问题出现了：怎样来确定一次查询的特征值？&lt;/p&gt;

&lt;p&gt;换句话说就是：怎样判断某两次查询是完全相同的查询？&lt;/p&gt;

&lt;p&gt;也可以这样说：如何确定Cache中的key值？&lt;/p&gt;

&lt;p&gt;MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;传入的 statementId&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传递给java.sql.Statement要设置的参数值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CacheKey由以下条件决定：
&lt;strong&gt;statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CacheKey的创建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    CacheKey cacheKey = new CacheKey();
    cacheKey.update(ms.getId());//StatementId
    cacheKey.update(rowBounds.getOffset());//rowBounds.offset
    cacheKey.update(rowBounds.getLimit());//rowBounds.limit
    cacheKey.update(boundSql.getSql());//Sql
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    // mimic DefaultParameterHandler logic
    for (ParameterMapping parameterMapping : parameterMappings) {
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        String propertyName = parameterMapping.getProperty();
        if (boundSql.hasAdditionalParameter(propertyName)) {
          value = boundSql.getAdditionalParameter(propertyName);
        } else if (parameterObject == null) {
          value = null;
        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        cacheKey.update(value);
      }
    }
    if (configuration.getEnvironment() != null) {
      // issue #176
      cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-性能问题&quot;&gt;6. 性能问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;一级缓存没有维护容量和大小限制&lt;/li&gt;
  &lt;li&gt;一级缓存没有更新缓存和缓存过期的概念&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">1. 一级缓存的作用 2. 一级缓存的依赖关系 3. 一级缓存的生命周期 4. 一级缓存的实现 5. Cache接口 6. 性能问题 1. 一级缓存的作用 每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。 肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。 SqlSession级别的数据缓存，称为一级缓存 2. 一级缓存的依赖关系 一级缓存由SqlSession控制。 SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。 Executor接口的实现类BaseExecutor中拥有一个Cache接口的实现类PerpetualCache，则对于BaseExecutor对象而言，它将使用PerpetualCache对象维护缓存。 PerpetualCache的实现代码 /** * @author Clinton Begin */ public class PerpetualCache implements Cache { private final String id; private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;(); public PerpetualCache(String id) { this.id = id; } @Override public String getId() { return id; } @Override public int getSize() { return cache.size(); } @Override public void putObject(Object key, Object value) { cache.put(key, value); } @Override public Object getObject(Object key) { return cache.get(key); } @Override public Object removeObject(Object key) { return cache.remove(key); } @Override public void clear() { cache.clear(); } @Override public ReadWriteLock getReadWriteLock() { return null; } @Override public boolean equals(Object o) { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } if (this == o) { return true; } if (!(o instanceof Cache)) { return false; } Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); } @Override public int hashCode() { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } return getId().hashCode(); } } 3. 一级缓存的生命周期 MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 4. 一级缓存的实现 对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 4.1 去数据库中查询数据，得到查询结果； 4.2 将key和查询到的结果分别作为key,value对存储到Cache中； 4.3. 将查询结果返回； 结束。 5. Cache接口 MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。 MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ 换句话说就是：怎样判断某两次查询是完全相同的查询？ 也可以这样说：如何确定Cache中的key值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 传入的 statementId 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）； 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 传递给java.sql.Statement要设置的参数值 CacheKey由以下条件决定： statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值 CacheKey的创建 @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { if (closed) { throw new ExecutorException(&quot;Executor was closed.&quot;); } CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId());//StatementId cacheKey.update(rowBounds.getOffset());//rowBounds.offset cacheKey.update(rowBounds.getLimit());//rowBounds.limit cacheKey.update(boundSql.getSql());//Sql List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数 TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic for (ParameterMapping parameterMapping : parameterMappings) { if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } cacheKey.update(value); } } if (configuration.getEnvironment() != null) { // issue #176 cacheKey.update(configuration.getEnvironment().getId()); } return cacheKey; } 构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法. public void update(Object object) { int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); } 6. 性能问题 一级缓存没有维护容量和大小限制 一级缓存没有更新缓存和缓存过期的概念</summary></entry><entry><title type="html">DispatcherServlet探究</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html" rel="alternate" type="text/html" title="DispatcherServlet探究" /><published>2017-12-14T23:51:29+08:00</published><updated>2017-12-14T23:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/spring/01.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中&lt;/p&gt;

&lt;p&gt;配置如下&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring-mvc.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 启动优先级 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;async-supported&amp;gt;&lt;/span&gt;true&lt;span class=&quot;nt&quot;&gt;&amp;lt;/async-supported&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意，DispatcherServlet可以配置多个，有自己的上下文容器。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PropertyValues初始化 ServletConfigPropertyValues是一个内部类&lt;/li&gt;
  &lt;li&gt;封装了bean的行为，提供了设置和获取属性值&lt;/li&gt;
  &lt;li&gt;加载资源文件&lt;/li&gt;
  &lt;li&gt;注册属性编辑&lt;/li&gt;
  &lt;li&gt;初始化beanWrapper&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;项目启动&lt;/p&gt;

&lt;p&gt;DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public final void init() throws ServletException {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;);
        }

        try {
            // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类
            PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);
            // 2、封装了bean的行为，提供了设置和获取属性值
            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
            // 3、加载资源文件
            ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());
            // 4、注册属性编辑
            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));
            // 5、初始化beanWrapper
            this.initBeanWrapper(bw);
            bw.setPropertyValues(pvs, true);
        } catch (BeansException var4) {
            if (this.logger.isErrorEnabled()) {
                this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4);
            }

            throw var4;
        }
        //让子类做任何他们想要的初始化。
        this.initServletBean();
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;);
        }

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PropertyValues初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    private static class ServletConfigPropertyValues extends MutablePropertyValues {
        public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException {
            Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null;
            //获取init-param中的数值对
            Enumeration paramNames = config.getInitParameterNames();

            while(paramNames.hasMoreElements()) {
                String property = (String)paramNames.nextElement();
                Object value = config.getInitParameter(property);
                this.addPropertyValue(new PropertyValue(property, value));
                if (missingProps != null) {
                    missingProps.remove(property);
                }
            }

            if (!CollectionUtils.isEmpty(missingProps)) {
                throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下图所示，获取init-param中的配置参数，写入PropertyValues
&lt;img src=&quot;/ProgramNote/assets/Image/spring/02.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BeanWrapper实现对bean行为的封装&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhiweianran/article/details/7919129&quot;&gt;待学习&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ResourceLoader加载资源文件比较简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ServletContextResourceLoader extends DefaultResourceLoader {

	private final ServletContext servletContext;


	/**
	 * Create a new ServletContextResourceLoader.
	 * @param servletContext the ServletContext to load resources with
	 */
	public ServletContextResourceLoader(ServletContext servletContext) {
		this.servletContext = servletContext;
	}

	/**
	 * This implementation supports file paths beneath the root of the web application.
	 * @see ServletContextResource
	 */
	@Override
	protected Resource getResourceByPath(String path) {
		return new ServletContextResource(this.servletContext, path);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;initServletBean的介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	/**
	 * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。
	 * &amp;lt;p&amp;gt;这个方法的默认实现是空的
	 * @throws ServletException if subclass initialization fails
	 */
	protected void initServletBean() throws ServletException {
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在&lt;strong&gt;FrameworkServlet&lt;/strong&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
	/**
	 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
	 * have been set. Creates this servlet's WebApplicationContext.
	 */
	@Override
	protected final void initServletBean() throws ServletException {
		getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;);
		if (this.logger.isInfoEnabled()) {
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
            //这里是主要的动作，创建应用程序上下文
			this.webApplicationContext = initWebApplicationContext();
			initFrameworkServlet();
		}
		catch (ServletException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}
		catch (RuntimeException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}

		if (this.logger.isInfoEnabled()) {
			long elapsedTime = System.currentTimeMillis() - startTime;
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; +
					elapsedTime + &quot; ms&quot;);
		}
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;

	/**
	 * 初始化并发布此servlet的Web应用程序上下文。
	 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation
	 * of the context. Can be overridden in subclasses.
	 * @return the WebApplicationContext instance
	 * @see #FrameworkServlet(WebApplicationContext)
	 * @see #setContextClass
	 * @see #setContextConfigLocation
	 */
	protected WebApplicationContext initWebApplicationContext() {
		WebApplicationContext rootContext =
				WebApplicationContextUtils.getWebApplicationContext(getServletContext());
		WebApplicationContext wac = null;

		if (this.webApplicationContext != null) {
            //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的  
			wac = this.webApplicationContext;
			if (wac instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
				if (!cwac.isActive()) {
					//上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务
					if (cwac.getParent() == null) {
						//在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素
						cwac.setParent(rootContext);
					}
					configureAndRefreshWebApplicationContext(cwac);
				}
			}
		}
		if (wac == null) {
			//在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了
			wac = findWebApplicationContext();
		}
		if (wac == null) {
			//没有的话就定义一个
			wac = createWebApplicationContext(rootContext);
		}

		if (!this.refreshEventReceived) {
			// 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息  
			onRefresh(wac);
		}

		if (this.publishContext) {
			// 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中  
			String attrName = getServletContextAttributeName();
			getServletContext().setAttribute(attrName, wac);
			if (this.logger.isDebugEnabled()) {
				this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() +
						&quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
			}
		}

		return wac;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文地址：
http://blog.csdn.net/congcong68/article/details/40451233&lt;/p&gt;

&lt;p&gt;需要学的
http://blog.csdn.net/congcong68/article/details/40650143&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><summary type="html">DispatcherServlet是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。 当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中 配置如下 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 启动优先级 --&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;async-supported&amp;gt;true&amp;lt;/async-supported&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 请注意，DispatcherServlet可以配置多个，有自己的上下文容器。 PropertyValues初始化 ServletConfigPropertyValues是一个内部类 封装了bean的行为，提供了设置和获取属性值 加载资源文件 注册属性编辑 初始化beanWrapper 项目启动 DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法 public final void init() throws ServletException { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;); } try { // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类 PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties); // 2、封装了bean的行为，提供了设置和获取属性值 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); // 3、加载资源文件 ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext()); // 4、注册属性编辑 bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment())); // 5、初始化beanWrapper this.initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException var4) { if (this.logger.isErrorEnabled()) { this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4); } throw var4; } //让子类做任何他们想要的初始化。 this.initServletBean(); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;); } } PropertyValues初始化 private static class ServletConfigPropertyValues extends MutablePropertyValues { public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException { Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null; //获取init-param中的数值对 Enumeration paramNames = config.getInitParameterNames(); while(paramNames.hasMoreElements()) { String property = (String)paramNames.nextElement(); Object value = config.getInitParameter(property); this.addPropertyValue(new PropertyValue(property, value)); if (missingProps != null) { missingProps.remove(property); } } if (!CollectionUtils.isEmpty(missingProps)) { throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;)); } } } 如下图所示，获取init-param中的配置参数，写入PropertyValues BeanWrapper实现对bean行为的封装 待学习 ResourceLoader加载资源文件比较简单 public class ServletContextResourceLoader extends DefaultResourceLoader { private final ServletContext servletContext; /** * Create a new ServletContextResourceLoader. * @param servletContext the ServletContext to load resources with */ public ServletContextResourceLoader(ServletContext servletContext) { this.servletContext = servletContext; } /** * This implementation supports file paths beneath the root of the web application. * @see ServletContextResource */ @Override protected Resource getResourceByPath(String path) { return new ServletContextResource(this.servletContext, path); } } initServletBean的介绍 /** * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。 * &amp;lt;p&amp;gt;这个方法的默认实现是空的 * @throws ServletException if subclass initialization fails */ protected void initServletBean() throws ServletException { } 上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在FrameworkServlet中 /** * Overridden method of {@link HttpServletBean}, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */ @Override protected final void initServletBean() throws ServletException { getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;); if (this.logger.isInfoEnabled()) { this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;); } long startTime = System.currentTimeMillis(); try { //这里是主要的动作，创建应用程序上下文 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } catch (RuntimeException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; + elapsedTime + &quot; ms&quot;); } } /** * 初始化并发布此servlet的Web应用程序上下文。 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation * of the context. Can be overridden in subclasses. * @return the WebApplicationContext instance * @see #FrameworkServlet(WebApplicationContext) * @see #setContextClass * @see #setContextConfigLocation */ protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的 wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { //上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务 if (cwac.getParent() == null) { //在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素 cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { //在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了 wac = findWebApplicationContext(); } if (wac == null) { //没有的话就定义一个 wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息 onRefresh(wac); } if (this.publishContext) { // 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() + &quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;); } } return wac; } 本文地址： http://blog.csdn.net/congcong68/article/details/40451233 需要学的 http://blog.csdn.net/congcong68/article/details/40650143</summary></entry><entry><title type="html">component-scan总结</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="component-scan总结" /><published>2017-12-12T21:51:29+08:00</published><updated>2017-12-12T21:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93.html">&lt;p&gt;今天偶然看到了原有的一个项目中有这样的配置信息&lt;/p&gt;

&lt;p&gt;配置文件&lt;strong&gt;spring-config.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 扫描注解Bean --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:exclude-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置文件&lt;strong&gt;spring-mvc.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 开启controller注解支持 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb.platform.controller&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;use-default-filters=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在&lt;strong&gt;spring-config.xml&lt;/strong&gt;中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。&lt;/p&gt;

&lt;p&gt;第二个问题是&lt;code class=&quot;highlighter-rouge&quot;&gt;use-default-filters=&quot;false&quot;&lt;/code&gt;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。&lt;/p&gt;

&lt;h1 id=&quot;component-scan的分析&quot;&gt;component-scan的分析&lt;/h1&gt;

&lt;h2 id=&quot;注册解析器&quot;&gt;注册解析器&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;component-scan&lt;/code&gt;交由&lt;code class=&quot;highlighter-rouge&quot;&gt;org.springframework.context.config.ContextNamespaceHandler&lt;/code&gt;处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ContextNamespaceHandler extends NamespaceHandlerSupport {
    public ContextNamespaceHandler() {
    }

    public void init() {
        this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());
        //这里注册处理的解析器
        this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;componentscanbeandefinitionparser组装classpathbeandefinitionscanner&quot;&gt;ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        //获取basePackage
        String basePackage = element.getAttribute(&quot;base-package&quot;);
        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
        //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式
        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;);
        //组装ClassPathBeanDefinitionScanner
        ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element);
        //扫描===========
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages);
        //注册bean
        this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //组装ClassPathBeanDefinitionScanner
    protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {
        //默认情况下  use-default-filters属性为true
        boolean useDefaultFilters = true;
        if (element.hasAttribute(&quot;use-default-filters&quot;)) {
            useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;));
        }
        //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner
        ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters);
        scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());
        scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());
        if (element.hasAttribute(&quot;resource-pattern&quot;)) {
            scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;));
        }

        try {
            this.parseBeanNameGenerator(element, scanner);
        } catch (Exception var7) {
            parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause());
        }

        try {
            this.parseScope(element, scanner);
        } catch (Exception var6) {
            parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause());
        }

        this.parseTypeFilters(element, scanner, parserContext);
        return scanner;
    }

    protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {
        return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //ClassPathBeanDefinitionScanner构造器
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) {
        this.beanDefinitionDefaults = new BeanDefinitionDefaults();
        this.beanNameGenerator = new AnnotationBeanNameGenerator();
        this.scopeMetadataResolver = new AnnotationScopeMetadataResolver();
        this.includeAnnotationConfig = true;
        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
        this.registry = registry;
        if (useDefaultFilters) {
            //这里注册过滤器，就是那些bean被扫描注册
            this.registerDefaultFilters();
        }

        this.setEnvironment(environment);
        this.setResourceLoader(resourceLoader);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //注册过滤器
    // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。
    protected void registerDefaultFilters() {
        this.includeFilters.add(new AnnotationTypeFilter(Component.class));
        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false));
            this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var4) {
            ;
        }

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false));
            this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var3) {
            ;
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次回到&lt;code class=&quot;highlighter-rouge&quot;&gt;//扫描===========&lt;/code&gt;这个地方，继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet();
        String[] var3 = basePackages;
        int var4 = basePackages.length;

        for(int var5 = 0; var5 &amp;lt; var4; ++var5) {
            String basePackage = var3[var5];
            //这里判定是否符合条件
            Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage);
            Iterator var8 = candidates.iterator();

            while(var8.hasNext()) {
                BeanDefinition candidate = (BeanDefinition)var8.next();
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                if (candidate instanceof AbstractBeanDefinition) {
                    this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
                }

                if (candidate instanceof AnnotatedBeanDefinition) {
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
                }

                if (this.checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    this.registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }

        return beanDefinitions;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定符合条件的地方继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
        LinkedHashSet candidates = new LinkedHashSet();

        try {
            String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
            boolean traceEnabled = this.logger.isTraceEnabled();
            boolean debugEnabled = this.logger.isDebugEnabled();
            Resource[] var7 = resources;
            int var8 = resources.length;

            for(int var9 = 0; var9 &amp;lt; var8; ++var9) {
                Resource resource = var7[var9];
                if (traceEnabled) {
                    this.logger.trace(&quot;Scanning &quot; + resource);
                }

                if (resource.isReadable()) {
                    try {
                        MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                        //这里判定是否符合排除或者包含的component条件
                        if (this.isCandidateComponent(metadataReader)) {
                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                            sbd.setResource(resource);
                            sbd.setSource(resource);
                            if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) {
                                if (debugEnabled) {
                                    this.logger.debug(&quot;Identified candidate component class: &quot; + resource);
                                }

                                candidates.add(sbd);
                            } else if (debugEnabled) {
                                this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                            }
                        } else if (traceEnabled) {
                            this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                        }
                    } catch (Throwable var13) {
                        throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13);
                    }
                } else if (traceEnabled) {
                    this.logger.trace(&quot;Ignored because not readable: &quot; + resource);
                }
            }

            return candidates;
        } catch (IOException var14) {
            throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定是否符合component的地方继续&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
        Iterator var2 = this.excludeFilters.iterator();

        TypeFilter tf;
        do {
            //先判断 exclude-filter,黑名单过滤
            if (!var2.hasNext()) {
                var2 = this.includeFilters.iterator();

                do {
                    //然后判断 include-filter,白名单过滤
                    // 其他情况排除
                    if (!var2.hasNext()) {
                        return false;
                    }

                    tf = (TypeFilter)var2.next();
                } while(!tf.match(metadataReader, this.metadataReaderFactory));

                return this.isConditionMatch(metadataReader);
            }

            tf = (TypeFilter)var2.next();
        } while(!tf.match(metadataReader, this.metadataReaderFactory));

        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter&lt;/li&gt;
  &lt;li&gt;use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描&lt;/li&gt;
  &lt;li&gt;controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Spring" /><summary type="html">今天偶然看到了原有的一个项目中有这样的配置信息 配置文件spring-config.xml &amp;lt;!-- 扫描注解Bean --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&amp;gt; &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 配置文件spring-mvc.xml &amp;lt;!-- 开启controller注解支持 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb.platform.controller&quot; use-default-filters=&quot;false&quot;&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在spring-config.xml中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。 第二个问题是use-default-filters=&quot;false&quot;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。 component-scan的分析 注册解析器 component-scan交由org.springframework.context.config.ContextNamespaceHandler处理 public class ContextNamespaceHandler extends NamespaceHandlerSupport { public ContextNamespaceHandler() { } public void init() { this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); //这里注册处理的解析器 this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } } ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner public BeanDefinition parse(Element element, ParserContext parserContext) { //获取basePackage String basePackage = element.getAttribute(&quot;base-package&quot;); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;); //组装ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element); //扫描=========== Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages); //注册bean this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } //组装ClassPathBeanDefinitionScanner protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { //默认情况下 use-default-filters属性为true boolean useDefaultFilters = true; if (element.hasAttribute(&quot;use-default-filters&quot;)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;)); } //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(&quot;resource-pattern&quot;)) { scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;)); } try { this.parseBeanNameGenerator(element, scanner); } catch (Exception var7) { parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause()); } try { this.parseScope(element, scanner); } catch (Exception var6) { parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause()); } this.parseTypeFilters(element, scanner, parserContext); return scanner; } protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) { return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader()); } //ClassPathBeanDefinitionScanner构造器 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) { this.beanDefinitionDefaults = new BeanDefinitionDefaults(); this.beanNameGenerator = new AnnotationBeanNameGenerator(); this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); this.includeAnnotationConfig = true; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) { //这里注册过滤器，就是那些bean被扫描注册 this.registerDefaultFilters(); } this.setEnvironment(environment); this.setResourceLoader(resourceLoader); } //注册过滤器 // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。 protected void registerDefaultFilters() { this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false)); this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;); } catch (ClassNotFoundException var4) { ; } try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false)); this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;); } catch (ClassNotFoundException var3) { ; } } 我们再次回到//扫描===========这个地方，继续往下走 protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &amp;lt; var4; ++var5) { String basePackage = var3[var5]; //这里判定是否符合条件 Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if (this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 从判定符合条件的地方继续往下走 public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) { LinkedHashSet candidates = new LinkedHashSet(); try { String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = this.logger.isTraceEnabled(); boolean debugEnabled = this.logger.isDebugEnabled(); Resource[] var7 = resources; int var8 = resources.length; for(int var9 = 0; var9 &amp;lt; var8; ++var9) { Resource resource = var7[var9]; if (traceEnabled) { this.logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //这里判定是否符合排除或者包含的component条件 if (this.isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if (debugEnabled) { this.logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else if (debugEnabled) { this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not readable: &quot; + resource); } } return candidates; } catch (IOException var14) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14); } } 从判定是否符合component的地方继续 protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { Iterator var2 = this.excludeFilters.iterator(); TypeFilter tf; do { //先判断 exclude-filter,黑名单过滤 if (!var2.hasNext()) { var2 = this.includeFilters.iterator(); do { //然后判断 include-filter,白名单过滤 // 其他情况排除 if (!var2.hasNext()) { return false; } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return this.isConditionMatch(metadataReader); } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return false; } 结论 include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描 controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）</summary></entry></feed>