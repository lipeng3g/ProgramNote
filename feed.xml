<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/ProgramNote/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ProgramNote/" rel="alternate" type="text/html" hreflang="zh" /><updated>2017-12-25T20:27:45+08:00</updated><id>http://localhost:4000/ProgramNote/</id><title type="html">lipeng’s blog</title><subtitle>lipeng's Blog
</subtitle><author><name>lipeng</name><email>lipeng3g@gmail.com</email></author><entry><title type="html">Mybatis初始化(2)</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html" rel="alternate" type="text/html" title="Mybatis初始化(2)" /><published>2017-12-25T20:27:29+08:00</published><updated>2017-12-25T20:27:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2)</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/25/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(2).html">&lt;h1 id=&quot;mybatis源码解析一mybatis初始化过程解析&quot;&gt;MyBatis源码解析(一)——MyBatis初始化过程解析&lt;/h1&gt;

&lt;h1 id=&quot;1-准备工作&quot;&gt;1. 准备工作&lt;/h1&gt;

&lt;p&gt;为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-94ca3998bee0abb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/294&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-product-产品实体类&quot;&gt;1.1 Product 产品实体类&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Product {
    private long id;
    private String productName;
    private String productContent;
    private String price;
    private int sort;
    private int falseSales;
    private long category_id;
    private byte type;
    private byte state;
    // PS：省略setter、getter函数
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;12-productmapper-产品持久化接口&quot;&gt;1.2 ProductMapper 产品持久化接口&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface ProductMapper {
    /**
     * 查询所有的产品
     * @return
     */
    List&amp;lt;Product&amp;gt; selectProductList();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-productmapperxml-产品映射文件&quot;&gt;1.3 ProductMapper.xml 产品映射文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;namespace=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectProductList&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team.njupt.entity.Product&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        select * from product
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;14-dbproperties-数据库配置文件&quot;&gt;1.4 db.properties 数据库配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver=com.mysql.jdbc.Driver
url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8
username=root
password=xxxxxx

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-mybatisxml-mybatis的配置文件&quot;&gt;1.5 mybatis.xml MyBatis的配置文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${driver}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${username}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${password}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;team/njupt/mapper/ProductMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;16-main-主函数&quot;&gt;1.6 Main 主函数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) throws IOException {

        String resource = &quot;mybatis.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);
            List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList();
            for (Product product : productList) {
                System.out.printf(product.toString());
            }
        } finally {
            sqlSession.close();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-mybatis初始化过程&quot;&gt;2. MyBatis初始化过程&lt;/h1&gt;

&lt;h2 id=&quot;21-获取配置文件&quot;&gt;2.1 获取配置文件&lt;/h2&gt;

&lt;p&gt;当系统初始化时，首先会读取配置文件，并将其解析成InputStream&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String resource = &quot;mybatis.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;22-创建sqlsessionfactorybuilder对象&quot;&gt;2.2 创建SqlSessionFactoryBuilder对象&lt;/h2&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;的名字中可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactoryBuilder&lt;/code&gt;是用来创建&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;对象的。
来看一下SqlSessionFactoryBuilder源码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-b0f3e995ac56f20a.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;h2 id=&quot;23-sqlsessionfactory创建过程&quot;&gt;2.3 SqlSessionFactory创建过程&lt;/h2&gt;

&lt;p&gt;下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;231-构造xmlconfigbuilder对象&quot;&gt;2.3.1 构造XMLConfigBuilder对象&lt;/h4&gt;

&lt;p&gt;build函数首先会构造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;的体系结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-3998f972a6a4e251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;是用来解析XML配置文件的，不同类型&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;用来解析MyBatis配置文件的不同部位。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;用来解析MyBatis的配置文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;用来解析MyBatis中的映射文件（如上文提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProductMapper.xml&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLStatementBuilder&lt;/code&gt;用来解析映射文件中的SQL语句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这些&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLxxxBuilder&lt;/code&gt;都有一个共同的父类——&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;。这个父类维护了一个全局的&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，MyBatis的配置文件解析后就以&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的形式存储。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象时，就会初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象，并且在初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的时候，一些别名会被注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
super(new Configuration());
ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);
this.configuration.setVariables(props);
this.parsed = false;
this.environment = environment;
this.parser = parser;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Configuration() {
typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);

typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);
typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);
typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);
……
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;232-解析配置文件&quot;&gt;2.3.2 解析配置文件&lt;/h3&gt;

&lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;对象之后，接下来就可以用它来解析配置文件了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void parseConfiguration(XNode root) {
  try {
    // 解析&amp;lt;properties&amp;gt;节点
    propertiesElement(root.evalNode(&quot;properties&quot;));
    // 解析&amp;lt;settings&amp;gt;节点
    Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
    loadCustomVfs(settings);
    // 解析&amp;lt;typeAliases&amp;gt;节点
    typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
    // 解析&amp;lt;plugins&amp;gt;节点
    pluginElement(root.evalNode(&quot;plugins&quot;));
    // 解析&amp;lt;objectFactory&amp;gt;节点
    objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
    objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
    // 解析&amp;lt;reflectorFactory&amp;gt;节点
    reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
    settingsElement(settings);
    // 解析&amp;lt;environments&amp;gt;节点
    environmentsElement(root.evalNode(&quot;environments&quot;));
    databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
    typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
    // 解析&amp;lt;mappers&amp;gt;节点
    mapperElement(root.evalNode(&quot;mappers&quot;));
  } catch (Exception e) {
    throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上述代码中可以看到，&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;会依次解析配置文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; settings &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; environments&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; typeAliases &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; plugins &amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; mappers &amp;gt;&lt;/code&gt;等属性。下面介绍下几个重要属性的解析过程。&lt;/p&gt;

&lt;h4 id=&quot;2321-节点的解析过程&quot;&gt;2.3.2.1 &lt;properties&gt;节点的解析过程&lt;/properties&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的定义如下：

```
&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot; /&gt;
  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot; /&gt;
&lt;/properties&gt;

```

&lt;/properties&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;properties&gt;节点的解析过程：

```
/**
  * @Param context &lt;properties&gt;节点
  */
private void propertiesElement(XNode context) throws Exception {
  if (context != null) {
    // 获取&lt;properties&gt;节点的所有子节点
    Properties defaults = context.getChildrenAsProperties();
    // 获取&lt;properties&gt;节点上的resource属性
    String resource = context.getStringAttribute(&quot;resource&quot;);
    // 获取&lt;properties&gt;节点上的url属性
    String url = context.getStringAttribute(&quot;url&quot;);
    // resource和url不能同时存在
    if (resource != null &amp;amp;&amp;amp; url != null) {
      throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);
    }
    if (resource != null) {
      // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中        
      defaults.putAll(Resources.getResourceAsProperties(resource));
    } else if (url != null) {
      // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中
      defaults.putAll(Resources.getUrlAsProperties(url));
    }
    // 获取configuration中原本的属性，并添加至defaults容器中
    Properties vars = configuration.getVariables();
    if (vars != null) {
      defaults.putAll(vars);
    }
    parser.setVariables(defaults);
    // 将defaults容器添加至configuration中
    configuration.setVariables(defaults);
  }
}

```

*   首先读取`&lt;resources&gt;`节点下的所有`&lt;resource&gt;`节点，并将每个节点的`name`和`value`属性存入`Properties`中。
*   然后读取`&lt;resources&gt;`节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。）
*   最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。

&lt;/resources&gt;&lt;/resource&gt;&lt;/resources&gt;&lt;/properties&gt;&lt;/properties&gt;&lt;/properties&gt;&lt;/properties&gt;&lt;/properties&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2322-节点的解析过程&quot;&gt;2.3.2.2 &lt;settings&gt;节点的解析过程&lt;/settings&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的定义如下：

```
&lt;settings&gt;
  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;
  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot; /&gt;
&lt;/settings&gt;

```

&lt;/settings&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;settings&gt;节点的解析过程：
`&lt;settings&gt;`属性的解析过程和 `&lt;properties&gt;`属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。

&lt;/properties&gt;&lt;/settings&gt;&lt;/settings&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2323-属性的解析过程&quot;&gt;2.3.2.3 &lt;typeAliases&gt;属性的解析过程&lt;/typeAliases&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;属性的定义方式有如下两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方式1：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt;
  &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方式2：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void typeAliasesElement(XNode parent) {
  if (parent != null) {
    // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点
    for (XNode child : parent.getChildren()) {
      // 若当前结点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;上的name属性（包名）
        String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
        // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中          
        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
      } 
      // 如果当前结点为&amp;lt; typeAlias &amp;gt;
      else {
        // 获取alias和type属性
        String alias = child.getStringAttribute(&quot;alias&quot;);
        String type = child.getStringAttribute(&quot;type&quot;);
        // 注册进configuration的typeAliasRegistry中
        try {
          Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type);
          if (alias == null) {
            typeAliasRegistry.registerAlias(clazz);
          } else {
            typeAliasRegistry.registerAlias(alias, clazz);
          }
        } catch (ClassNotFoundException e) {
          throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名）&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt;节点下定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;typeAlias&amp;gt;&lt;/code&gt;节点，那么MyBatis就会给指定的类起指定的别名。&lt;/li&gt;
  &lt;li&gt;这些别名都会被存入&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;typeAliasRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2324-节点的解析过程&quot;&gt;2.3.2.4 &lt;mappers&gt;节点的解析过程&lt;/mappers&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的定义方式有如下四种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方式1：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式2：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式3：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;方式4：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mappers&amp;gt;
  &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    // 遍历&amp;lt;mappers&amp;gt;下所有子节点
    for (XNode child : parent.getChildren()) {
      // 如果当前节点为&amp;lt;package&amp;gt;
      if (&quot;package&quot;.equals(child.getName())) {
        // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名）
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中
        configuration.addMappers(mapperPackage);
      } 
      // 如果当前节点为&amp;lt;mapper&amp;gt;
      else {
        // 依次获取resource、url、class属性
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);
        // 解析resource属性（Mapper.xml文件的路径）
        if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          // 将Mapper.xml文件解析成输入流
          InputStream inputStream = Resources.getResourceAsStream(resource);
          // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析url属性（Mapper.xml文件的路径）
        else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } 
        // 解析class属性（Mapper Class的全限定名）
        else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
          // 将Mapper Class的权限定名转化成Class对象
          Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
          // 注册进configuration对象的mapperRegistry容器中
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;MyBatis会遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/code&gt;下所有的子节点，如果当前遍历到的节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;，则MyBatis会将该包下的所有Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
  &lt;li&gt;如果当前节点为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mapperRegistry&lt;/code&gt;容器中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;节点的解析过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
mapperParser.parse();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在解析前，首先需要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;，创建过程如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) {
  // 将configuration赋给BaseBuilder
  super(configuration);
  // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者）
  this.builderAssistant = new  MapperBuilderAssistant(configuration, resource);
  this.parser = parser;
  this.sqlFragments = sqlFragments;
  this.resource = resource;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;首先会初始化父类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseBuilder&lt;/code&gt;，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;赋给BaseBuilder；&lt;/li&gt;
      &lt;li&gt;然后创建&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant&lt;/code&gt;对象，该对象为&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;的协助者，用来协助&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;完成一些解析映射文件的动作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLMapperBuilder&lt;/code&gt;后，便可进入解析&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;mapper&amp;gt;&lt;/code&gt;的过程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void parse() {
  // 若当前的Mapper.xml尚未被解析，则开始解析
  // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了
  if (!configuration.isResourceLoaded(resource)) {
    // 解析&amp;lt;mapper&amp;gt;节点
    configurationElement(parser.evalNode(&quot;/mapper&quot;));
    // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析
    configuration.addLoadedResource(resource);
    // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中
    bindMapperForNamespace();
  }

  parsePendingResultMaps();
  parsePendingCacheRefs();
  parsePendingStatements();
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;configurationElement&lt;/code&gt;函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void configurationElement(XNode context) {
try {
  // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁
  String namespace = context.getStringAttribute(&quot;namespace&quot;);
  if (namespace == null || namespace.equals(&quot;&quot;)) {
    throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;);
  }
  // 将namespace属性值赋给builderAssistant
  builderAssistant.setCurrentNamespace(namespace);
  // 解析&amp;lt;cache-ref&amp;gt;节点
  cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
  // 解析&amp;lt;cache&amp;gt;节点
  cacheElement(context.evalNode(&quot;cache&quot;));
  // 解析&amp;lt;parameterMap&amp;gt;节点
  parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
  // 解析&amp;lt;resultMap&amp;gt;节点
  resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
  // 解析&amp;lt;sql&amp;gt;节点
  sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
  // 解析sql语句      
  buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
} catch (Exception e) {
  throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMapElements&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点，这些节点会被解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;resultMaps&lt;/code&gt;容器中。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点定义如下：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt;
  &amp;lt;constructor&amp;gt;
     &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt;
     &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt;
  &amp;lt;/constructor&amp;gt;
  &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt;
  &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt;节点的解析过程：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception {
  ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的id属性
  String id = resultMapNode.getStringAttribute(&quot;id&quot;,
    resultMapNode.getValueBasedIdentifier());
  // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型）
  String type = resultMapNode.getStringAttribute(&quot;type&quot;,
    resultMapNode.getStringAttribute(&quot;ofType&quot;,
        resultMapNode.getStringAttribute(&quot;resultType&quot;,
            resultMapNode.getStringAttribute(&quot;javaType&quot;))));
  // 获取extends属性
  String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);
  // 获取autoMapping属性
  Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);
  // 将resultMap的返回值类型转换成Class对象
  Class&amp;lt;?&amp;gt; typeClass = resolveClass(type);
  Discriminator discriminator = null;
  // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;();
  resultMappings.addAll(additionalResultMappings);
  // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点
  List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren();
  for (XNode resultChild : resultChildren) {
    // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去
    if (&quot;constructor&quot;.equals(resultChild.getName())) {
      processConstructorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去
    else if (&quot;discriminator&quot;.equals(resultChild.getName())) {
      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
    }
    // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去
    else {
      // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property
      List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;();
      if (&quot;id&quot;.equals(resultChild.getName())) {
        flags.add(ResultFlag.ID);
      }
      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
    }
  }
  // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下）
  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
  try {
    return resultMapResolver.resolve();
  } catch (IncompleteElementException  e) {
    configuration.addIncompleteResultMap(resultMapResolver);
    throw e;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMapResolver&lt;/code&gt;这个类很纯粹，有且仅有一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;，用于构造&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultMap&lt;/code&gt;对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于&lt;code class=&quot;highlighter-rouge&quot;&gt;MapperBuilderAssistant.addResultMap&lt;/code&gt;完成的。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ResultMap resolve() {
  return assistant.addResultMap(this.id, this.type, this.extend,  this.discriminator, this.resultMappings, this.autoMapping);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlElement&lt;/code&gt;函数
该函数用于解析映射文件中所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sql&amp;gt;&lt;/code&gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buildStatementFromContext&lt;/code&gt;函数
该函数会将映射文件中的sql语句解析成&lt;code class=&quot;highlighter-rouge&quot;&gt;MappedStatement&lt;/code&gt;对象，并存在&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mappedStatements&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;233-创建sqlsessionfactory对象&quot;&gt;2.3.3 创建SqlSessionFactory对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回过头来再看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;函数，刚才说了半天，介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLConfigBuilder&lt;/code&gt;解析映射文件的过程，解析完成之后&lt;code class=&quot;highlighter-rouge&quot;&gt;parser.parse()&lt;/code&gt;函数会返回一个包含了映射文件解析结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;对象，紧接着，这个对象将作为参数传递给另一个build函数，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数将&lt;code class=&quot;highlighter-rouge&quot;&gt;configuration&lt;/code&gt;作为参数，创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;对象。
&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSqlSessionFactory&lt;/code&gt;是接口&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的一个实现类，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;的体系结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2994604-da2dbd8f1f2ac844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSessionFactory&lt;/code&gt;创建完毕！&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><summary type="html">MyBatis源码解析(一)——MyBatis初始化过程解析 1. 准备工作 为了看清楚MyBatis的整个初始化过程，先创建一个简单的Java项目，目录结构如下图所示： 1.1 Product 产品实体类 public class Product { private long id; private String productName; private String productContent; private String price; private int sort; private int falseSales; private long category_id; private byte type; private byte state; // PS：省略setter、getter函数 } 1.2 ProductMapper 产品持久化接口 public interface ProductMapper { /** * 查询所有的产品 * @return */ List&amp;lt;Product&amp;gt; selectProductList(); } 1.3 ProductMapper.xml 产品映射文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;team.njupt.mapper.ProductMapper&quot;&amp;gt; &amp;lt;select id=&quot;selectProductList&quot; resultType=&quot;team.njupt.entity.Product&quot;&amp;gt; select * from product &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; 1.4 db.properties 数据库配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://127.0.0.1:3306/waimai?useUnicode=true&amp;amp;characterEncoding=utf8 username=root password=xxxxxx 1.5 mybatis.xml MyBatis的配置文件 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;properties resource=&quot;db.properties&quot;&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&amp;gt;--&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;team/njupt/mapper/ProductMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 1.6 Main 主函数 public class Main { public static void main(String[] args) throws IOException { String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); try { ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class); List&amp;lt;Product&amp;gt; productList = productMapper.selectProductList(); for (Product product : productList) { System.out.printf(product.toString()); } } finally { sqlSession.close(); } } } 2. MyBatis初始化过程 2.1 获取配置文件 当系统初始化时，首先会读取配置文件，并将其解析成InputStream String resource = &quot;mybatis.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); 2.2 创建SqlSessionFactoryBuilder对象 从SqlSessionFactoryBuilder的名字中可以看出，SqlSessionFactoryBuilder是用来创建SqlSessionFactory对象的。 来看一下SqlSessionFactoryBuilder源码： SqlSessionFactoryBuilder中只有一些重载的build函数，这些build函数的入参都是MyBatis配置文件的输入流，返回值都是SqlSessionFactory；由此可见，SqlSessionFactoryBuilder的作用很纯粹，就是用来通过配置文件创建SqlSessionFactory对象的。 2.3 SqlSessionFactory创建过程 下面具体来看一下，build函数是如何创建SqlSessionFactory对象的。 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 2.3.1 构造XMLConfigBuilder对象 build函数首先会构造一个XMLConfigBuilder对象，从名字上大致可以猜到，该对象是用来解析XML配置文件的。下面来看一下XMLConfigBuilder的体系结构。 XMLxxxBuilder是用来解析XML配置文件的，不同类型XMLxxxBuilder用来解析MyBatis配置文件的不同部位。比如：XMLConfigBuilder用来解析MyBatis的配置文件，XMLMapperBuilder用来解析MyBatis中的映射文件（如上文提到的ProductMapper.xml），XMLStatementBuilder用来解析映射文件中的SQL语句。 这些XMLxxxBuilder都有一个共同的父类——BaseBuilder。这个父类维护了一个全局的Configuration对象，MyBatis的配置文件解析后就以Configuration对象的形式存储。 当创建XMLConfigBuilder对象时，就会初始化Configuration对象，并且在初始化Configuration对象的时候，一些别名会被注册到Configuration的typeAliasRegistry容器中。 private XMLConfigBuilder(XPathParser parser, String environment, Properties props) { super(new Configuration()); ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;); this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; } public Configuration() { typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); …… } 2.3.2 解析配置文件 当有了XMLConfigBuilder对象之后，接下来就可以用它来解析配置文件了。 private void parseConfiguration(XNode root) { try { // 解析&amp;lt;properties&amp;gt;节点 propertiesElement(root.evalNode(&quot;properties&quot;)); // 解析&amp;lt;settings&amp;gt;节点 Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); // 解析&amp;lt;typeAliases&amp;gt;节点 typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); // 解析&amp;lt;plugins&amp;gt;节点 pluginElement(root.evalNode(&quot;plugins&quot;)); // 解析&amp;lt;objectFactory&amp;gt;节点 objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); // 解析&amp;lt;reflectorFactory&amp;gt;节点 reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // 解析&amp;lt;environments&amp;gt;节点 environmentsElement(root.evalNode(&quot;environments&quot;)); databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); // 解析&amp;lt;mappers&amp;gt;节点 mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } 从上述代码中可以看到，XMLConfigBuilder会依次解析配置文件中的&amp;lt;properties&amp;gt;、&amp;lt; settings &amp;gt;、&amp;lt; environments&amp;gt;、&amp;lt; typeAliases &amp;gt;、&amp;lt; plugins &amp;gt;、&amp;lt; mappers &amp;gt;等属性。下面介绍下几个重要属性的解析过程。 2.3.2.1 节点的解析过程 节点的定义如下： ``` ``` 节点的解析过程： ``` /** * @Param context 节点 */ private void propertiesElement(XNode context) throws Exception { if (context != null) { // 获取节点的所有子节点 Properties defaults = context.getChildrenAsProperties(); // 获取节点上的resource属性 String resource = context.getStringAttribute(&quot;resource&quot;); // 获取节点上的url属性 String url = context.getStringAttribute(&quot;url&quot;); // resource和url不能同时存在 if (resource != null &amp;amp;&amp;amp; url != null) { throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference. Please specify one or the other.&quot;); } if (resource != null) { // 获取resource属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getResourceAsProperties(resource)); } else if (url != null) { // 获取url属性值对应的properties文件中的键值对，并添加至defaults容器中 defaults.putAll(Resources.getUrlAsProperties(url)); } // 获取configuration中原本的属性，并添加至defaults容器中 Properties vars = configuration.getVariables(); if (vars != null) { defaults.putAll(vars); } parser.setVariables(defaults); // 将defaults容器添加至configuration中 configuration.setVariables(defaults); } } ``` * 首先读取``节点下的所有``节点，并将每个节点的`name`和`value`属性存入`Properties`中。 * 然后读取``节点上的`resource`、`url`属性，并获取指定配置文件中的`name`和`value`，也存入`Properties`中。（PS：由此可知，如果resource节点上定义的属性和properties文件中的属性重名，那么properties文件中的属性值会覆盖resource节点上定义的属性值。） * 最终，携带所有属性的`Properties`对象会被存储在`Configuration`对象中。 2.3.2.2 节点的解析过程 节点的定义如下： ``` ``` 节点的解析过程： ``属性的解析过程和 ``属性的解析过程极为类似，这里不再赘述。最终，所有的setting属性都被存储在`Configuration`对象中。 2.3.2.3 属性的解析过程 &amp;lt;typeAliases&amp;gt;属性的定义方式有如下两种： 方式1： &amp;lt;typeAliases&amp;gt; &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt; &amp;lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 方式2： &amp;lt;typeAliases&amp;gt; &amp;lt;package name=&quot;domain.blog&quot;/&amp;gt; &amp;lt;/typeAliases&amp;gt; 采用这种方式时，MyBatis会为指定包下的所有类起一个别名，该别名为首字母小写的类名。 &amp;lt;typeAliases&amp;gt;节点的解析过程如下： private void typeAliasesElement(XNode parent) { if (parent != null) { // 遍历&amp;lt;typeAliases&amp;gt;下的所有子节点 for (XNode child : parent.getChildren()) { // 若当前结点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;上的name属性（包名） String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); // 为该包下的所有类起个别名，并注册进configuration的typeAliasRegistry中 configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } // 如果当前结点为&amp;lt; typeAlias &amp;gt; else { // 获取alias和type属性 String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); // 注册进configuration的typeAliasRegistry中 try { Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e); } } } } } 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;package&amp;gt;节点，那么MyBatis会给该包下的所有类起一个别名（以类名首字母小写作为别名） 如果&amp;lt;typeAliases&amp;gt;节点下定义了&amp;lt;typeAlias&amp;gt;节点，那么MyBatis就会给指定的类起指定的别名。 这些别名都会被存入configuration的typeAliasRegistry容器中。 2.3.2.4 节点的解析过程 &amp;lt;mappers&amp;gt;节点的定义方式有如下四种： 方式1： &amp;lt;mappers&amp;gt; &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式2： &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式3： &amp;lt;mappers&amp;gt; &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; 方式4： &amp;lt;mappers&amp;gt; &amp;lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;mappers&amp;gt;节点的解析过程如下： private void mapperElement(XNode parent) throws Exception { if (parent != null) { // 遍历&amp;lt;mappers&amp;gt;下所有子节点 for (XNode child : parent.getChildren()) { // 如果当前节点为&amp;lt;package&amp;gt; if (&quot;package&quot;.equals(child.getName())) { // 获取&amp;lt;package&amp;gt;的name属性（该属性值为mapper class所在的包名） String mapperPackage = child.getStringAttribute(&quot;name&quot;); // 将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中 configuration.addMappers(mapperPackage); } // 如果当前节点为&amp;lt;mapper&amp;gt; else { // 依次获取resource、url、class属性 String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); // 解析resource属性（Mapper.xml文件的路径） if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(resource); // 将Mapper.xml文件解析成输入流 InputStream inputStream = Resources.getResourceAsStream(resource); // 使用XMLMapperBuilder解析Mapper.xml，并将Mapper Class注册进configuration对象的mapperRegistry容器中 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } // 解析url属性（Mapper.xml文件的路径） else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) { ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } // 解析class属性（Mapper Class的全限定名） else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) { // 将Mapper Class的权限定名转化成Class对象 Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass); // 注册进configuration对象的mapperRegistry容器中 configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } MyBatis会遍历&amp;lt;mappers&amp;gt;下所有的子节点，如果当前遍历到的节点是&amp;lt;package&amp;gt;，则MyBatis会将该包下的所有Mapper Class注册到configuration的mapperRegistry容器中。 如果当前节点为&amp;lt;mapper&amp;gt;，则会依次获取resource、url、class属性，解析映射文件，并将映射文件对应的Mapper Class注册到configuration的mapperRegistry容器中。 其中，&amp;lt;mapper&amp;gt;节点的解析过程如下： XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); 在解析前，首先需要创建XMLMapperBuilder，创建过程如下： private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&amp;lt;String, XNode&amp;gt; sqlFragments) { // 将configuration赋给BaseBuilder super(configuration); // 创建MapperBuilderAssistant对象（该对象为MapperBuilder的协助者） this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } 首先会初始化父类BaseBuilder，并将configuration赋给BaseBuilder； 然后创建MapperBuilderAssistant对象，该对象为XMLMapperBuilder的协助者，用来协助XMLMapperBuilder完成一些解析映射文件的动作。 当有了XMLMapperBuilder后，便可进入解析&amp;lt;mapper&amp;gt;的过程： public void parse() { // 若当前的Mapper.xml尚未被解析，则开始解析 // PS：若&amp;lt;mappers&amp;gt;节点下有相同的&amp;lt;mapper&amp;gt;节点，那么就无需再次解析了 if (!configuration.isResourceLoaded(resource)) { // 解析&amp;lt;mapper&amp;gt;节点 configurationElement(parser.evalNode(&quot;/mapper&quot;)); // 将该Mapper.xml添加至configuration的LoadedResource容器中，下回无需再解析 configuration.addLoadedResource(resource); // 将该Mapper.xml对应的Mapper Class注册进configuration的mapperRegistry容器中 bindMapperForNamespace(); } parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements(); } configurationElement函数 private void configurationElement(XNode context) { try { // 获取&amp;lt;mapper&amp;gt;节点上的namespace属性，该属性必须存在，表示当前映射文件对应的Mapper Class是谁 String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;); } // 将namespace属性值赋给builderAssistant builderAssistant.setCurrentNamespace(namespace); // 解析&amp;lt;cache-ref&amp;gt;节点 cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); // 解析&amp;lt;cache&amp;gt;节点 cacheElement(context.evalNode(&quot;cache&quot;)); // 解析&amp;lt;parameterMap&amp;gt;节点 parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // 解析&amp;lt;resultMap&amp;gt;节点 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // 解析&amp;lt;sql&amp;gt;节点 sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // 解析sql语句 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e); } } resultMapElements函数 该函数用于解析映射文件中所有的&amp;lt;resultMap&amp;gt;节点，这些节点会被解析成ResultMap对象，存储在Configuration对象的resultMaps容器中。 &amp;lt;resultMap&amp;gt;节点定义如下： &amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&amp;gt; &amp;lt;constructor&amp;gt; &amp;lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&amp;gt; &amp;lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&amp;gt; &amp;lt;/constructor&amp;gt; &amp;lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&amp;gt; &amp;lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap&amp;gt;节点的解析过程： private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的id属性 String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // 获取&amp;lt;ResultMap&amp;gt;上的type属性（即resultMap的返回值类型） String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // 获取extends属性 String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // 获取autoMapping属性 Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); // 将resultMap的返回值类型转换成Class对象 Class&amp;lt;?&amp;gt; typeClass = resolveClass(type); Discriminator discriminator = null; // resultMappings用于存储&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;(); resultMappings.addAll(additionalResultMappings); // 获取并遍历&amp;lt;resultMap&amp;gt;下所有的子节点 List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { // 若当前节点为&amp;lt;constructor&amp;gt;，则将它的子节点们添加到resultMappings中去 if (&quot;constructor&quot;.equals(resultChild.getName())) { processConstructorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;discriminator&amp;gt;，则进行条件判断，并将命中的子节点添加到resultMappings中去 else if (&quot;discriminator&quot;.equals(resultChild.getName())) { discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } // 若当前节点为&amp;lt;result&amp;gt;、&amp;lt;association&amp;gt;、&amp;lt;collection&amp;gt;，则将其添加到resultMappings中去 else { // PS:flags仅用于区分当前节点是否是&amp;lt;id&amp;gt;或&amp;lt;idArg&amp;gt;，因为这两个节点的属性名为name，而其他节点的属性名为property List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // ResultMapResolver的作用是生成ResultMap对象，并将其加入到Configuration对象的resultMaps容器中（具体过程见下） ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } ResultMapResolver这个类很纯粹，有且仅有一个函数resolve，用于构造ResultMap对象，并将其存入Configuration对象的resultMaps容器中；而这个过程是借助于MapperBuilderAssistant.addResultMap完成的。 public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } sqlElement函数 该函数用于解析映射文件中所有的&amp;lt;sql&amp;gt;节点，并将这些节点存储在当前映射文件所对应的XMLMapperBuilder对象的sqlFragments容器中，供解析sql语句时使用。 &amp;lt;sql id=&quot;userColumns&quot;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt; buildStatementFromContext函数 该函数会将映射文件中的sql语句解析成MappedStatement对象，并存在configuration的mappedStatements。 2.3.3 创建SqlSessionFactory对象 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 回过头来再看一下SqlSessionFactory的build函数，刚才说了半天，介绍了XMLConfigBuilder解析映射文件的过程，解析完成之后parser.parse()函数会返回一个包含了映射文件解析结果的configuration对象，紧接着，这个对象将作为参数传递给另一个build函数，如下： public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 这个函数将configuration作为参数，创建了DefaultSqlSessionFactory对象。 DefaultSqlSessionFactory是接口SqlSessionFactory的一个实现类，SqlSessionFactory的体系结构如下图所示： 此时，SqlSessionFactory创建完毕！</summary></entry><entry><title type="html">Spring手动提交事务</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html" rel="alternate" type="text/html" title="Spring手动提交事务" /><published>2017-12-23T10:12:47+08:00</published><updated>2017-12-23T10:12:47+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/23/Spring%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.html">&lt;p&gt;开篇之前先说一下问题来源，我是用了&lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;redisson&lt;/a&gt;作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;);
	if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
		RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;);
		if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) {
			// 吧啦吧啦
			// 这里是业务逻辑代码
			// 修改对象状态等等
		} else {
			//操作超时，请重新操作
		}
		if (BLock.isLocked()) {
			BLock.unlock();
		}
	} else {
		//操作超时，请重新操作
	}
	if (ALock.isLocked()) {
		ALock.unlock();
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。&lt;/p&gt;

&lt;p&gt;两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。&lt;/p&gt;

&lt;p&gt;结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。&lt;/p&gt;

&lt;p&gt;解决方案1：
	把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题
	这种方法也有缺点，部分业务处理需要在controller中进行&lt;/p&gt;

&lt;p&gt;解决方案2：
	service层手动提交事务，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	@Resource 
    private DataSourceTransactionManager transactionManager; 


	// 下面是手动提交
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();  
	// 事物隔离级别，开启新事务，这样会比较安全些。  
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); 
	// 获得事务状态 
	TransactionStatus status = transactionManager.getTransaction(def);  
	try {  
		transactionManager.commit(status);  
	} catch (Exception e) {  
		transactionManager.rollback(status);  
	}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。&lt;/strong&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><category term="配置" /><summary type="html">开篇之前先说一下问题来源，我是用了redisson作为项目的分布式锁，程序中使用分布式锁来锁定 对象A， 然后锁定对象A 下的 对象B，然后再对对象B 做业务操作。 RLock ALock = redissonClient.getLock(&quot;AAAAA&quot;); if (ALock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { RLock BLock = redissonClient.getLock(&quot;BBBBB&quot;); if (BLock.tryLock(10000, 10000, TimeUnit.MILLISECONDS)) { // 吧啦吧啦 // 这里是业务逻辑代码 // 修改对象状态等等 } else { //操作超时，请重新操作 } if (BLock.isLocked()) { BLock.unlock(); } } else { //操作超时，请重新操作 } if (ALock.isLocked()) { ALock.unlock(); } 这段代码的位置在 SpringMVC 的service 层， 同一个对象A 下的 同一个 对象 B 只能操作一次，但是上面的代码在连续两次请求以后会操作两次，很奇怪，为什么日志里面显示确实锁定了对象A和对象B,但是依然能够进行两次操作呢，在多次打印业务内容以后，发现了，原来是事务未提交导致。 两次请求确实都锁定了对象A和对象B，然后业务处理完成以后，下次锁定就开始了，但是请注意，这是service层代码，配置了全局事务，那么当前一次事务还未提交，后一次锁定查询又开始了，查到的对象状态未更新，也就再一次进行了业务操作。 结论： 锁定操作没有错，但是由于事务未提交，导致锁定操作无效。 解决方案1： 把上面的代码锁定操作放入 Controller 层，这样第二次开始操作之前，事务已经提交完毕，不会造成上面的问题 这种方法也有缺点，部分业务处理需要在controller中进行 解决方案2： service层手动提交事务，代码如下 @Resource private DataSourceTransactionManager transactionManager; // 下面是手动提交 DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // 事物隔离级别，开启新事务，这样会比较安全些。 def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); // 获得事务状态 TransactionStatus status = transactionManager.getTransaction(def); try { transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } 以上两种解决方案都可以，但是第二种请注意，如果抛出异常，可能导致无法回滚。 由于一直想深入研究一下Spring的事务的实现原理，但是还没有机会，所以暂时写了这篇文章做个因子，等学习完了以后再回来修改本文章的不妥之处。</summary></entry><entry><title type="html">Mybatis二级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis二级缓存" /><published>2017-12-19T19:51:29+08:00</published><updated>2017-12-19T19:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/19/Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1&quot;&gt;1. Mybatis缓存机制整体设计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&quot;&gt;2. 二级缓存的基本原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%92%E5%88%86&quot;&gt;3. 二级缓存的划分&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-%E4%B8%BA%E6%AF%8F%E4%B8%80%E4%B8%AAmapper%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AAcache%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BD%BF%E7%94%A8cache%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%EF%BC%89&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-%E5%A4%9A%E4%B8%AAmapper%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AAcache%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BD%BF%E7%94%A8cache-ref%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%EF%BC%89&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%9D%A1%E4%BB%B6&quot;&gt;4. 开启二级缓存的条件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F&quot;&gt;5. 缓存使用顺序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&quot;&gt;6. 二级缓存的实现方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7-mybatis%E8%87%AA%E8%BA%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis缓存机制整体设计&quot;&gt;1. Mybatis缓存机制整体设计&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/27.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。&lt;/p&gt;

&lt;p&gt;如果用户配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;cacheEnabled=true&quot;&lt;/code&gt;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：&lt;code class=&quot;highlighter-rouge&quot;&gt;CachingExecutor&lt;/code&gt;，这时SqlSession使用CachingExecutor对象来完成操作请求。&lt;/p&gt;

&lt;p&gt;CachingExecutor对于查询请求，会先判断该查询请求在Application级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;二级缓存中是否有缓存结果&lt;/code&gt;，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。&lt;/p&gt;

&lt;h1 id=&quot;2-二级缓存的基本原理&quot;&gt;2. 二级缓存的基本原理&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/28.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，&lt;/p&gt;

&lt;p&gt;CachingExecutor和Executor的关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/29.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-二级缓存的划分&quot;&gt;3. 二级缓存的划分&lt;/h1&gt;

&lt;p&gt;Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置 为一个Mapper分配一个Cache缓存对象&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置 为多个Mapper分配相同的Cache对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;31-为每一个mapper分配一个cache缓存对象使用cache节点配置&quot;&gt;3.1. 为每一个Mapper分配一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/30.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID&lt;/p&gt;
&lt;h2 id=&quot;32-多个mapper共用一个cache缓存对象使用cache-ref节点配置&quot;&gt;3.2. 多个Mapper共用一个Cache缓存对象（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref&amp;gt;&lt;/code&gt;节点配置）&lt;/h2&gt;
&lt;p&gt;如果你想让多个Mapper公用一个Cache的话，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;&lt;/code&gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/31.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-开启二级缓存的条件&quot;&gt;4. 开启二级缓存的条件&lt;/h1&gt;
&lt;p&gt;二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。&lt;/p&gt;

&lt;p&gt;虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在`&lt;select&gt; `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。&lt;/select&gt;&lt;/cache&gt;&lt;/p&gt;

&lt;p&gt;如下所示，Select语句配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;useCache=&quot;true&quot;&lt;/code&gt;，则表明这条Select语句的查询会使用二级缓存。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;useCache=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;开启二级缓存的条件&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true&lt;/li&gt;
  &lt;li&gt;该select语句所在的Mapper，配置了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cached-ref&amp;gt;&lt;/code&gt;节点，并且有效&lt;/li&gt;
  &lt;li&gt;该select语句的参数 useCache=true&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;5-缓存使用顺序&quot;&gt;5. 缓存使用顺序&lt;/h1&gt;
&lt;p&gt;二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库&lt;/p&gt;

&lt;h1 id=&quot;6-二级缓存的实现方式&quot;&gt;6. 二级缓存的实现方式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;使用MyBatis的二级缓存有三个选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis自身提供的缓存实现&lt;/p&gt;

    &lt;p&gt;MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义的Cache接口实现&lt;/p&gt;

    &lt;p&gt;MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cache type=&quot;&quot;&amp;gt;&lt;/code&gt;节点的type属性上即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟第三方内存缓存库的集成&lt;/p&gt;

    &lt;p&gt;MyBatis还支持跟第三方内存缓存库如Memecached的集成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-mybatis自身提供的二级缓存实现&quot;&gt;7. Mybatis自身提供的二级缓存实现&lt;/h1&gt;
&lt;p&gt;MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/32.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；&lt;/li&gt;
  &lt;li&gt;FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；&lt;/li&gt;
  &lt;li&gt;Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><category term="缓存" /><summary type="html">1. Mybatis缓存机制整体设计 2. 二级缓存的基本原理 3. 二级缓存的划分 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 4. 开启二级缓存的条件 5. 缓存使用顺序 6. 二级缓存的实现方式 7. Mybatis自身提供的二级缓存实现 1. Mybatis缓存机制整体设计   当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个Executor对象做文章。 如果用户配置了&quot;cacheEnabled=true&quot;，那么MyBatis在为SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。 CachingExecutor对于查询请求，会先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后在返回给用户。 2. 二级缓存的基本原理 CachingExecutor是Executor的装饰者，以增强Executor的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式， CachingExecutor和Executor的关系图 3. 二级缓存的划分 Mybatis二级缓存是Mapper级别的，每个Mapper都可以拥有一个Cache对象 使用&amp;lt;cache&amp;gt;节点配置 为一个Mapper分配一个Cache缓存对象 使用&amp;lt;cache-ref&amp;gt;节点配置 为多个Mapper分配相同的Cache对象 3.1. 为每一个Mapper分配一个Cache缓存对象（使用&amp;lt;cache&amp;gt;节点配置） MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了&amp;lt;cache&amp;gt; 节点，则MyBatis会为这个Mapper创建一个Cache缓存对象 每一个Cache对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID 3.2. 多个Mapper共用一个Cache缓存对象（使用&amp;lt;cache-ref&amp;gt;节点配置） 如果你想让多个Mapper公用一个Cache的话，你可以使用&amp;lt;cache-ref namespace=&quot;&quot;&amp;gt;节点，来指定你的这个Mapper使用到了哪一个Mapper的Cache缓存。 4. 开启二级缓存的条件 二级缓存的支持力度很细，可以指定某一条查询语句是否使用二级缓存。 虽然在Mapper中配置了,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在` `节点中配置`useCache=&quot;true&quot;`，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。 如下所示，Select语句配置了useCache=&quot;true&quot;，则表明这条Select语句的查询会使用二级缓存。 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&amp;gt; 开启二级缓存的条件 MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了&amp;lt;cache&amp;gt; 或&amp;lt;cached-ref&amp;gt;节点，并且有效 该select语句的参数 useCache=true 5. 缓存使用顺序 二级缓存 ——&amp;gt; 一级缓存 ——&amp;gt; 数据库 6. 二级缓存的实现方式 使用MyBatis的二级缓存有三个选择 MyBatis自身提供的缓存实现 MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的Cache缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等 用户自定义的Cache接口实现 MyBatis还允许用户自定义Cache接口实现，用户是需要实现org.apache.ibatis.cache.Cache接口，然后将Cache实现类配置在&amp;lt;cache type=&quot;&quot;&amp;gt;节点的type属性上即可 跟第三方内存缓存库的集成 MyBatis还支持跟第三方内存缓存库如Memecached的集成 7. Mybatis自身提供的二级缓存实现 MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略： LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录； FIFO：（First in first out）,先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉； Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；</summary></entry><entry><title type="html">装饰者模式简单理解</title><link href="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="装饰者模式简单理解" /><published>2017-12-19T13:51:29+08:00</published><updated>2017-12-19T13:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/ProgramNote/java/2017/12/19/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.html">&lt;h1 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#装饰者模式&quot;&gt;装饰者模式&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#基本描述&quot;&gt;基本描述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#代码实例&quot;&gt;代码实例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;基本描述&quot;&gt;基本描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给对象动态地添加附加功能。&lt;/li&gt;
  &lt;li&gt;装饰者提供了一个灵活的拓展子类功能的备选方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个程序猿
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员
 */
public class Coder {

 public void coding() {
     System.out.println(&quot;我在写程序。。。&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个程序猿的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序员装饰器
 */
public class CoderDecorator extends Coder {

 private Coder coder;

 public CoderDecorator(Coder coder) {
     this.coder = coder;
 }

 @Override
 public void coding() {
     coder.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;定义一个专门更换键盘的装饰器
```Java
/**
    &lt;ul&gt;
      &lt;li&gt;写代码以前换键盘
 */
public class CoderDecoratorA extends CoderDecorator {&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;public CoderDecoratorA(Coder coder) {
     super(coder);
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public void coding() {
     this.addNewKeyBoard();
     super.coding();
 }&lt;/p&gt;

    &lt;p&gt;private void addNewKeyBoard() {
     System.out.println(“更换了新的机械键盘，噼里啪啦”);
 }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
4. 定义一个专门更换鼠标的装饰器
```Java

/**
 * 写代码以前换鼠标
 */
public class CoderDecoratorB extends CoderDecorator {

    public CoderDecoratorB(Coder coder) {
        super(coder);
    }

    @Override
    public void coding() {
        this.addNewMouse();
        super.coding();
    }

    private void addNewMouse() {
        System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;定义一个更换电脑的装饰器
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 写代码以前换电脑
 */
public class CoderDecoratorC extends CoderDecorator {

 public CoderDecoratorC(Coder coder) {
     super(coder);
 }

 @Override
 public void coding() {
     this.changeToMacbookPro();
     super.coding();
 }

 private void changeToMacbookPro() {
     System.out.println(&quot;电脑不好使，换了，美滋滋&quot;);
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;好了，现在老板可以根据不同程序猿的要求一一满足了
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
 * 程序猿写代码
 */
public class Client {

 public static void main(String[] args) {
     //创造一个程序猿A，并且开始写代码
     Coder coderA = new Coder();
     //换个键盘在写
     CoderDecorator decoratorA = new CoderDecoratorA(coderA);
     //换个鼠标在写
     decoratorA = new CoderDecoratorB(decoratorA);
     //把电脑也换了
     decoratorA = new CoderDecoratorC(decoratorA);
     decoratorA.coding();

     //创造一个程序猿B，并且开始写代码
     Coder coderB = new Coder();
     //换个键盘在写
     CoderDecorator decoratorB = new CoderDecoratorA(coderB);
     //把电脑也换了
     decoratorB = new CoderDecoratorC(decoratorB);
     decoratorB.coding();
 }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//这里满足程序猿A的要求
电脑不好使，换了，美滋滋
换了新的鼠标，哒哒哒，哒哒哒
更换了新的机械键盘，噼里啪啦
我在写程序。。。
//这里满足程序猿B的要求
电脑不好使，换了，美滋滋
更换了新的机械键盘，噼里啪啦
我在写程序。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>lipeng</name></author><category term="Java" /><category term="设计模式" /><summary type="html">装饰者模式 装饰者模式 基本描述 代码实例 基本描述 目的 给对象动态地添加附加功能。 装饰者提供了一个灵活的拓展子类功能的备选方案。 代码实例 公司当前有不同的程序猿，每个程序猿都会写程序，但是不同程序猿有不同的要求，有的安安静静写代码，有的说我要换个机械键盘在写，有的说我要换个笔记本，这个笔记本不好用，面对这些要求，公司管理者要尽量满足才能保证程序猿们写出高质量的代码（当然，现实中领导不会管你的，写不出来就换人。。。。） 定义一个程序猿 /** * 程序员 */ public class Coder { public void coding() { System.out.println(&quot;我在写程序。。。&quot;); } } 定义一个程序猿的装饰器 /** * 程序员装饰器 */ public class CoderDecorator extends Coder { private Coder coder; public CoderDecorator(Coder coder) { this.coder = coder; } @Override public void coding() { coder.coding(); } } 定义一个专门更换键盘的装饰器 ```Java /** 写代码以前换键盘 */ public class CoderDecoratorA extends CoderDecorator { public CoderDecoratorA(Coder coder) { super(coder); } @Override public void coding() { this.addNewKeyBoard(); super.coding(); } private void addNewKeyBoard() { System.out.println(“更换了新的机械键盘，噼里啪啦”); } } 4. 定义一个专门更换鼠标的装饰器 ```Java /** * 写代码以前换鼠标 */ public class CoderDecoratorB extends CoderDecorator { public CoderDecoratorB(Coder coder) { super(coder); } @Override public void coding() { this.addNewMouse(); super.coding(); } private void addNewMouse() { System.out.println(&quot;换了新的鼠标，哒哒哒，哒哒哒&quot;); } } 定义一个更换电脑的装饰器 /** * 写代码以前换电脑 */ public class CoderDecoratorC extends CoderDecorator { public CoderDecoratorC(Coder coder) { super(coder); } @Override public void coding() { this.changeToMacbookPro(); super.coding(); } private void changeToMacbookPro() { System.out.println(&quot;电脑不好使，换了，美滋滋&quot;); } } 好了，现在老板可以根据不同程序猿的要求一一满足了 /** * 程序猿写代码 */ public class Client { public static void main(String[] args) { //创造一个程序猿A，并且开始写代码 Coder coderA = new Coder(); //换个键盘在写 CoderDecorator decoratorA = new CoderDecoratorA(coderA); //换个鼠标在写 decoratorA = new CoderDecoratorB(decoratorA); //把电脑也换了 decoratorA = new CoderDecoratorC(decoratorA); decoratorA.coding(); //创造一个程序猿B，并且开始写代码 Coder coderB = new Coder(); //换个键盘在写 CoderDecorator decoratorB = new CoderDecoratorA(coderB); //把电脑也换了 decoratorB = new CoderDecoratorC(decoratorB); decoratorB.coding(); } } 执行结果 //这里满足程序猿A的要求 电脑不好使，换了，美滋滋 换了新的鼠标，哒哒哒，哒哒哒 更换了新的机械键盘，噼里啪啦 我在写程序。。。 //这里满足程序猿B的要求 电脑不好使，换了，美滋滋 更换了新的机械键盘，噼里啪啦 我在写程序。。。</summary></entry><entry><title type="html">Javascript过滤前后空格</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html" rel="alternate" type="text/html" title="Javascript过滤前后空格" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Javascript%E8%BF%87%E6%BB%A4%E7%A9%BA%E6%A0%BC.html">&lt;h1 id=&quot;javascript过滤前后空格&quot;&gt;Javascript过滤前后空格&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript过滤前后空格&quot;&gt;Javascript过滤前后空格&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#循环检查&quot;&gt;循环检查&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#正则表达式替换&quot;&gt;正则表达式替换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jquery&quot;&gt;JQuery&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;循环检查&quot;&gt;循环检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;//供使用者调用 
function trim(s){ 
  return trimRight(trimLeft(s)); 
} 
//去掉左边的空白 
function trimLeft(s){ 
  if(s == null) { 
    return &quot;&quot;; 
  } 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(0)) != -1) { 
    var j=0, i = str.length; 
    while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ 
      j++; 
    } 
    str = str.substring(j, i); 
  } 
  return str; 
} 

//去掉右边的空白
function trimRight(s){ 
  if(s == null) return &quot;&quot;; 
  var whitespace = new String(&quot; \t\n\r&quot;); 
  var str = new String(s); 
  if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ 
    var i = str.length - 1; 
    while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ 
      i--; 
    } 
    str = str.substring(0, i+1); 
  } 
  return str; 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式替换&quot;&gt;正则表达式替换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;
String.prototype.Trim = function() //去左右空格;
{ 
    return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
} 
String.prototype.LTrim = function() //去左空格;
{ 
    return this.replace(/(^\s*)/g, &quot;&quot;); 
} 
String.prototype.RTrim = function() //去右空格;
{ 
    return this.replace(/(\s*$)/g, &quot;&quot;); 
} 

//去左空格;
function ltrim(s){
    return s.replace(/(^\s*)/g, &quot;&quot;);
}
//去右空格;
function rtrim(s){
    return s.replace(/(\s*$)/g, &quot;&quot;);
}
//去左右空格;
function trim(s){
    return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jquery&quot;&gt;JQuery&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;推荐 ☆☆☆☆☆&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;// 使用方法
$.trim(str) 
// Jquery实现方法
function trim(str){  
    return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,'');  
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><category term="正则" /><summary type="html">Javascript过滤前后空格 Javascript过滤前后空格 循环检查 正则表达式替换 JQuery 循环检查 推荐 ☆☆☆ //供使用者调用 function trim(s){ return trimRight(trimLeft(s)); } //去掉左边的空白 function trimLeft(s){ if(s == null) { return &quot;&quot;; } var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(0)) != -1) { var j=0, i = str.length; while (j &amp;lt; i &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(j)) != -1){ j++; } str = str.substring(j, i); } return str; } //去掉右边的空白 function trimRight(s){ if(s == null) return &quot;&quot;; var whitespace = new String(&quot; \t\n\r&quot;); var str = new String(s); if (whitespace.indexOf(str.charAt(str.length-1)) != -1){ var i = str.length - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; whitespace.indexOf(str.charAt(i)) != -1){ i--; } str = str.substring(0, i+1); } return str; } 正则表达式替换 推荐 ☆☆☆☆ String.prototype.Trim = function() //去左右空格; { return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } String.prototype.LTrim = function() //去左空格; { return this.replace(/(^\s*)/g, &quot;&quot;); } String.prototype.RTrim = function() //去右空格; { return this.replace(/(\s*$)/g, &quot;&quot;); } //去左空格; function ltrim(s){ return s.replace(/(^\s*)/g, &quot;&quot;); } //去右空格; function rtrim(s){ return s.replace(/(\s*$)/g, &quot;&quot;); } //去左右空格; function trim(s){ return s.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); } JQuery 推荐 ☆☆☆☆☆ // 使用方法 $.trim(str) // Jquery实现方法 function trim(str){ return str.replace(/^(\s|\u00A0)+/,'').replace(/(\s|\u00A0)+$/,''); }</summary></entry><entry><title type="html">Function.apply and Function.call in JavaScript</title><link href="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&Function.call.html" rel="alternate" type="text/html" title="Function.apply and Function.call in JavaScript" /><published>2017-12-19T05:51:29+08:00</published><updated>2017-12-19T05:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call</id><content type="html" xml:base="http://localhost:4000/ProgramNote/javascript/2017/12/19/Function.apply&amp;Function.call.html">&lt;h1 id=&quot;functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/h1&gt;
&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#functionapply-and-functioncall-in-javascript&quot;&gt;Function.apply and Function.call in JavaScript&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#函数是对象&quot;&gt;函数是对象&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#call&quot;&gt;Call()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apply&quot;&gt;Apply()&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#参数&quot;&gt;参数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h2 id=&quot;函数是对象&quot;&gt;函数是对象&lt;/h2&gt;
&lt;p&gt;JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。&lt;/p&gt;

&lt;p&gt;您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。&lt;/p&gt;

&lt;p&gt;函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。&lt;/p&gt;

&lt;p&gt;例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;function foo()
{
    alert('x');
}
 
alert(foo.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的执行结果是(请注意，这是一个字符串)
&lt;code class=&quot;highlighter-rouge&quot;&gt;function foo()
{
    alert('x');
}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;Call()&lt;/h2&gt;
&lt;p&gt;因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。
“函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。&lt;/p&gt;

&lt;p&gt;让我们从下面的代码开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
 
function f()
{
    alert(this.x);
}
 
f();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们有一个名为f()的全局函数。f()使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;这个关键字来引用x，但是注意我们不通过对象的实例调用函数。
那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。&lt;/p&gt;

&lt;p&gt;call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。
例如，下面是我们如何使用call()方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
 
function f()
{
    alert(this.x);
}
 
f();
f.call(o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f()的第一个调用将显示10的值，因为这引用了全局对象。
但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。&lt;/p&gt;

&lt;p&gt;摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。&lt;/p&gt;

&lt;p&gt;我们还可以通过call()将参数传递给目标函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.call(o, &quot;invoking f via call&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;apply&quot;&gt;Apply()&lt;/h2&gt;
&lt;p&gt;apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;var x = 10;
var o = { x: 15 };
function f(message)
{
    alert(message);
    alert(this.x);
}
 
f(&quot;invoking f&quot;);
f.apply(o, [&quot;invoking f through apply&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f1(message1)
{
    alert(message1 + this.x);
}
 
function f2(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func, args)
{
    func.apply(object, args);
}
 
g(o, f1, [&quot;the value of x = &quot;]);
g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。&lt;/p&gt;

&lt;p&gt;在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    alert(message);
}
 
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;function f(message)
{
    // message param is the same as arguments[0]    
    // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的
    for(var i = 1; i &amp;lt; arguments.length; i++)
    {
        message += arguments[i];
    }
     
    alert(message); 
}
 
// this will say &quot;Hello&quot;
f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。
在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;var o = { x: 15 };
 
function f(message1, message2)
{
    alert(message1 + (this.x * this.x) + message2);
}
 
function g(object, func)
{           
    // arguments[0] == object
    // arguments[1] == func
    
    var args = []; // empty array
    // copy all other arguments we want to &quot;pass through&quot; 
    for(var i = 2; i &amp;lt; arguments.length; i++)
    {
        args.push(arguments[i]);
    }
 
    func.apply(object, args);
}
 
g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&quot;&gt;原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx&lt;/a&gt;&lt;/p&gt;</content><author><name>lipeng</name></author><category term="JavaScript" /><category term="Function" /><summary type="html">Function.apply and Function.call in JavaScript Function.apply and Function.call in JavaScript 函数是对象 Call() Apply() 参数 函数是对象 JavaScript中的每个函数都有许多附加的方法，包括toString()、call()和apply()。如果您觉得函数怎么可能有自己的方法，这听起来很奇怪，但是请记住，JavaScript中的每个函数都是一个对象。 您可能还想知道函数和方法之间的区别。我相信描述符的函数和方法只是一个JavaScript约定。 函数是独立的(例如，有一个alert()函数)，而方法在对象的字典中是函数，我们通过对象引用调用它们。 例如，每个JavaScript对象都有一个toString()方法，我们可以在函数对象上使用toString()方法来查看它的源代码： function foo() { alert('x'); } alert(foo.toString()); 上面的执行结果是(请注意，这是一个字符串) function foo() { alert('x'); } Call() 因为函数是对象，它们可以有自己的属性和方法，我们可以像对待数据一样对待它们。 “函数当做数据”是很重要的，但是现在我们将重点讨论函数的两个方法:apply()和它的对应函数:call()。 让我们从下面的代码开始： var x = 10; function f() { alert(this.x); } f(); 在这里，我们有一个名为f()的全局函数。f()使用this这个关键字来引用x，但是注意我们不通过对象的实例调用函数。 那么这个引用是什么对象呢? 这将引用全局对象。全局对象是我们定义变量x的地方，上面的代码是工作的，在对话框中显示值10。 call()和apply()都是我们可以用来在方法调用期间分配这个指针的方法。 例如，下面是我们如何使用call()方法: var x = 10; var o = { x: 15 }; function f() { alert(this.x); } f(); f.call(o); f()的第一个调用将显示10的值，因为这引用了全局对象。 但是，第二个调用(通过 call() 方法）)将显示值15。call()方法调用该函数，并将其第一个参数作为函数的主体内的这个指针。换句话说，我们已经告诉运行时，在函数f()内部执行时，要引用的对象是什么。 摆弄这个指针可能听起来很滑稽，甚至是有悖常理的，对c++、Java和c#程序员来说都是如此。 我们还可以通过call()将参数传递给目标函数: var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.call(o, &quot;invoking f via call&quot;); Apply() apply()方法与call()相同，但是apply()需要一个数组作为第二个参数。该数组表示目标方法的参数。 var x = 10; var o = { x: 15 }; function f(message) { alert(message); alert(this.x); } f(&quot;invoking f&quot;); f.apply(o, [&quot;invoking f through apply&quot;]); apply()方法是有用的，因为我们可以不关心目标方法的签名。可以使用apply()将所有额外参数通过数组传递给目标方法。 var o = { x: 15 }; function f1(message1) { alert(message1 + this.x); } function f2(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func, args) { func.apply(object, args); } g(o, f1, [&quot;the value of x = &quot;]); g(o, f2, [&quot;the value of x squared = &quot;, &quot;. Wow!&quot;]); 参数 上面的方法是有效的，但是很笨拙，用户必须把参数输入到一个数组中。幸运的是，有一种方法可以简化语法，但是我们必须引入一个更重要的主题:参数标识符。 在JavaScript中，每个函数本质上都有一个可变长度参数列表。即使函数只使用一个参数，也可以将5个参数传递给函数。下面的操作没有错误，并显示“H”: function f(message) { alert(message); } f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 如果我们确实想从f()中访问其他参数，我们可以使用参数关键字。参数引用一个参数对象，它有一个长度属性，感觉就像一个数组。 function f(message) { // message param is the same as arguments[0] // 注意，下面是从 1 开始拼接的，因为message和 下标为 0 的数据是相同的 for(var i = 1; i &amp;lt; arguments.length; i++) { message += arguments[i]; } alert(message); } // this will say &quot;Hello&quot; f(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;); 你知道，从技术上讲，arguments 不是一个数组，即使它的特征非常像一个数组。arguments 有一个长度属性，但没有 split、 push 或 pop 方法。 在我们之前的g（）函数中，我们可以做的是将参数[1]后面的传入参数复制到我们传递的数组对象中。 var o = { x: 15 }; function f(message1, message2) { alert(message1 + (this.x * this.x) + message2); } function g(object, func) { // arguments[0] == object // arguments[1] == func var args = []; // empty array // copy all other arguments we want to &quot;pass through&quot; for(var i = 2; i &amp;lt; arguments.length; i++) { args.push(arguments[i]); } func.apply(object, args); } g(o, f, &quot;The value of x squared = &quot;, &quot;. Wow!&quot;); 当我们调用g()时，我们可以将附加的参数作为参数传递，而不是将参数填充到数组中。 原文地址：https://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx</summary></entry><entry><title type="html">Mybatis一级缓存</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html" rel="alternate" type="text/html" title="Mybatis一级缓存" /><published>2017-12-15T15:51:29+08:00</published><updated>2017-12-15T15:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/15/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8&quot;&gt;1. 一级缓存的作用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&quot;&gt;2. 一级缓存的依赖关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&quot;&gt;3. 一级缓存的生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0&quot;&gt;4. 一级缓存的实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5-cache%E6%8E%A5%E5%8F%A3&quot;&gt;5. Cache接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98&quot;&gt;6. 性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-一级缓存的作用&quot;&gt;1. 一级缓存的作用&lt;/h1&gt;

&lt;p&gt;每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。&lt;/p&gt;

&lt;p&gt;肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/21.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SqlSession级别的数据缓存，称为一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-一级缓存的依赖关系&quot;&gt;2. 一级缓存的依赖关系&lt;/h1&gt;

&lt;p&gt;一级缓存由SqlSession控制。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/22.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SqlSession&lt;/code&gt;将它的工作交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;中拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache&lt;/code&gt;接口的实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;，则对于&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseExecutor&lt;/code&gt;对象而言，它将使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PerpetualCache&lt;/code&gt;对象维护缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/23.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PerpetualCache的实现代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
/**
 * @author Clinton Begin
 */
public class PerpetualCache implements Cache {

  private final String id;

  private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;();

  public PerpetualCache(String id) {
    this.id = id;
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public int getSize() {
    return cache.size();
  }

  @Override
  public void putObject(Object key, Object value) {
    cache.put(key, value);
  }

  @Override
  public Object getObject(Object key) {
    return cache.get(key);
  }

  @Override
  public Object removeObject(Object key) {
    return cache.remove(key);
  }

  @Override
  public void clear() {
    cache.clear();
  }

  @Override
  public ReadWriteLock getReadWriteLock() {
    return null;
  }

  @Override
  public boolean equals(Object o) {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    if (this == o) {
      return true;
    }
    if (!(o instanceof Cache)) {
      return false;
    }

    Cache otherCache = (Cache) o;
    return getId().equals(otherCache.getId());
  }

  @Override
  public int hashCode() {
    if (getId() == null) {
      throw new CacheException(&quot;Cache instances require an ID.&quot;);
    }
    return getId().hashCode();
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3-一级缓存的生命周期&quot;&gt;3. 一级缓存的生命周期&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/24.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-一级缓存的实现&quot;&gt;4. 一级缓存的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果命中，则直接将缓存结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没命中：&lt;/p&gt;

    &lt;p&gt;4.1  去数据库中查询数据，得到查询结果；&lt;/p&gt;

    &lt;p&gt;4.2  将key和查询到的结果分别作为key,value对存储到Cache中；&lt;/p&gt;

    &lt;p&gt;4.3. 将查询结果返回；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/25.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;5-cache接口&quot;&gt;5. Cache接口&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/26.png&quot; alt=&quot;Mybatis&quot; title=&quot;Mybatis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。&lt;/p&gt;

&lt;p&gt;MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。&lt;/p&gt;

&lt;p&gt;Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。&lt;/p&gt;

&lt;p&gt;现在最核心的问题出现了：怎样来确定一次查询的特征值？&lt;/p&gt;

&lt;p&gt;换句话说就是：怎样判断某两次查询是完全相同的查询？&lt;/p&gt;

&lt;p&gt;也可以这样说：如何确定Cache中的key值？&lt;/p&gt;

&lt;p&gt;MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;传入的 statementId&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传递给java.sql.Statement要设置的参数值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CacheKey由以下条件决定：
&lt;strong&gt;statementId  + rowBounds  + 传递给JDBC的SQL  + 传递给JDBC的参数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CacheKey的创建&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    CacheKey cacheKey = new CacheKey();
    cacheKey.update(ms.getId());//StatementId
    cacheKey.update(rowBounds.getOffset());//rowBounds.offset
    cacheKey.update(rowBounds.getLimit());//rowBounds.limit
    cacheKey.update(boundSql.getSql());//Sql
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    // mimic DefaultParameterHandler logic
    for (ParameterMapping parameterMapping : parameterMappings) {
      if (parameterMapping.getMode() != ParameterMode.OUT) {
        Object value;
        String propertyName = parameterMapping.getProperty();
        if (boundSql.hasAdditionalParameter(propertyName)) {
          value = boundSql.getAdditionalParameter(propertyName);
        } else if (parameterObject == null) {
          value = null;
        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
          value = parameterObject;
        } else {
          MetaObject metaObject = configuration.newMetaObject(parameterObject);
          value = metaObject.getValue(propertyName);
        }
        cacheKey.update(value);
      }
    }
    if (configuration.getEnvironment() != null) {
      // issue #176
      cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  public void update(Object object) {
    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); 

    count++;
    checksum += baseHashCode;
    baseHashCode *= count;

    hashcode = multiplier * hashcode + baseHashCode;

    updateList.add(object);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-性能问题&quot;&gt;6. 性能问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;一级缓存没有维护容量和大小限制&lt;/li&gt;
  &lt;li&gt;一级缓存没有更新缓存和缓存过期的概念&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><category term="缓存" /><summary type="html">1. 一级缓存的作用 2. 一级缓存的依赖关系 3. 一级缓存的生命周期 4. 一级缓存的实现 5. Cache接口 6. 性能问题 1. 一级缓存的作用 每开启一次Mybatis数据库会话，Mybatis会创建一个SqlSession对象。 肯多时候，可能多次执行的查询语句是一样的，为了减少资源浪费，Mybatis在sqlse对象建立一个缓存，查询结果先缓存，在下次查询时先从缓存中取。 SqlSession级别的数据缓存，称为一级缓存 2. 一级缓存的依赖关系 一级缓存由SqlSession控制。 SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。 Executor接口的实现类BaseExecutor中拥有一个Cache接口的实现类PerpetualCache，则对于BaseExecutor对象而言，它将使用PerpetualCache对象维护缓存。 PerpetualCache的实现代码 /** * @author Clinton Begin */ public class PerpetualCache implements Cache { private final String id; private Map&amp;lt;Object, Object&amp;gt; cache = new HashMap&amp;lt;Object, Object&amp;gt;(); public PerpetualCache(String id) { this.id = id; } @Override public String getId() { return id; } @Override public int getSize() { return cache.size(); } @Override public void putObject(Object key, Object value) { cache.put(key, value); } @Override public Object getObject(Object key) { return cache.get(key); } @Override public Object removeObject(Object key) { return cache.remove(key); } @Override public void clear() { cache.clear(); } @Override public ReadWriteLock getReadWriteLock() { return null; } @Override public boolean equals(Object o) { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } if (this == o) { return true; } if (!(o instanceof Cache)) { return false; } Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); } @Override public int hashCode() { if (getId() == null) { throw new CacheException(&quot;Cache instances require an ID.&quot;); } return getId().hashCode(); } } 3. 一级缓存的生命周期 MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 4. 一级缓存的实现 对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 4.1 去数据库中查询数据，得到查询结果； 4.2 将key和查询到的结果分别作为key,value对存储到Cache中； 4.3. 将查询结果返回； 结束。 5. Cache接口 MyBatis定义了一个org.apache.ibatis.cache.Cache接口作为其Cache提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的Cache缓存，都应该实现这一接口。MyBatis定义了一个PerpetualCache实现类实现了Cache接口，实际上，在SqlSession对象里的Executor 对象内维护的Cache类型实例对象，就是PerpetualCache子类创建的。 MyBatis内部还有很多Cache接口的实现，一级缓存只会涉及到这一个PerpetualCache子类。 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ 换句话说就是：怎样判断某两次查询是完全相同的查询？ 也可以这样说：如何确定Cache中的key值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 传入的 statementId 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）； 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 传递给java.sql.Statement要设置的参数值 CacheKey由以下条件决定： statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值 CacheKey的创建 @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) { if (closed) { throw new ExecutorException(&quot;Executor was closed.&quot;); } CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId());//StatementId cacheKey.update(rowBounds.getOffset());//rowBounds.offset cacheKey.update(rowBounds.getLimit());//rowBounds.limit cacheKey.update(boundSql.getSql());//Sql List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();//参数 TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic for (ParameterMapping parameterMapping : parameterMappings) { if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } cacheKey.update(value); } } if (configuration.getEnvironment() != null) { // issue #176 cacheKey.update(configuration.getEnvironment().getId()); } return cacheKey; } 构建CacheKey的过程实际上就是构造其hashCode的过程。下面的代码就是CacheKey的核心hashcode生成算法. public void update(Object object) { int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); } 6. 性能问题 一级缓存没有维护容量和大小限制 一级缓存没有更新缓存和缓存过期的概念</summary></entry><entry><title type="html">DispatcherServlet探究</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html" rel="alternate" type="text/html" title="DispatcherServlet探究" /><published>2017-12-14T23:51:29+08:00</published><updated>2017-12-14T23:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/14/DispatcherServlet%E6%8E%A2%E7%A9%B6.html">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/spring/01.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中&lt;/p&gt;

&lt;p&gt;配置如下&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:spring-mvc.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 启动优先级 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;async-supported&amp;gt;&lt;/span&gt;true&lt;span class=&quot;nt&quot;&gt;&amp;lt;/async-supported&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;spring&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意，DispatcherServlet可以配置多个，有自己的上下文容器。&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PropertyValues初始化 ServletConfigPropertyValues是一个内部类&lt;/li&gt;
  &lt;li&gt;封装了bean的行为，提供了设置和获取属性值&lt;/li&gt;
  &lt;li&gt;加载资源文件&lt;/li&gt;
  &lt;li&gt;注册属性编辑&lt;/li&gt;
  &lt;li&gt;初始化beanWrapper&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;项目启动&lt;/p&gt;

&lt;p&gt;DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public final void init() throws ServletException {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;);
        }

        try {
            // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类
            PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);
            // 2、封装了bean的行为，提供了设置和获取属性值
            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
            // 3、加载资源文件
            ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext());
            // 4、注册属性编辑
            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));
            // 5、初始化beanWrapper
            this.initBeanWrapper(bw);
            bw.setPropertyValues(pvs, true);
        } catch (BeansException var4) {
            if (this.logger.isErrorEnabled()) {
                this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4);
            }

            throw var4;
        }
        //让子类做任何他们想要的初始化。
        this.initServletBean();
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;);
        }

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PropertyValues初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    private static class ServletConfigPropertyValues extends MutablePropertyValues {
        public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException {
            Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null;
            //获取init-param中的数值对
            Enumeration paramNames = config.getInitParameterNames();

            while(paramNames.hasMoreElements()) {
                String property = (String)paramNames.nextElement();
                Object value = config.getInitParameter(property);
                this.addPropertyValue(new PropertyValue(property, value));
                if (missingProps != null) {
                    missingProps.remove(property);
                }
            }

            if (!CollectionUtils.isEmpty(missingProps)) {
                throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下图所示，获取init-param中的配置参数，写入PropertyValues
&lt;img src=&quot;/ProgramNote/assets/Image/spring/02.png&quot; alt=&quot;分析图&quot; title=&quot;分析图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BeanWrapper实现对bean行为的封装&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhiweianran/article/details/7919129&quot;&gt;待学习&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ResourceLoader加载资源文件比较简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ServletContextResourceLoader extends DefaultResourceLoader {

	private final ServletContext servletContext;


	/**
	 * Create a new ServletContextResourceLoader.
	 * @param servletContext the ServletContext to load resources with
	 */
	public ServletContextResourceLoader(ServletContext servletContext) {
		this.servletContext = servletContext;
	}

	/**
	 * This implementation supports file paths beneath the root of the web application.
	 * @see ServletContextResource
	 */
	@Override
	protected Resource getResourceByPath(String path) {
		return new ServletContextResource(this.servletContext, path);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;initServletBean的介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	/**
	 * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。
	 * &amp;lt;p&amp;gt;这个方法的默认实现是空的
	 * @throws ServletException if subclass initialization fails
	 */
	protected void initServletBean() throws ServletException {
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在&lt;strong&gt;FrameworkServlet&lt;/strong&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
	/**
	 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
	 * have been set. Creates this servlet's WebApplicationContext.
	 */
	@Override
	protected final void initServletBean() throws ServletException {
		getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;);
		if (this.logger.isInfoEnabled()) {
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;);
		}
		long startTime = System.currentTimeMillis();

		try {
            //这里是主要的动作，创建应用程序上下文
			this.webApplicationContext = initWebApplicationContext();
			initFrameworkServlet();
		}
		catch (ServletException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}
		catch (RuntimeException ex) {
			this.logger.error(&quot;Context initialization failed&quot;, ex);
			throw ex;
		}

		if (this.logger.isInfoEnabled()) {
			long elapsedTime = System.currentTimeMillis() - startTime;
			this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; +
					elapsedTime + &quot; ms&quot;);
		}
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;

	/**
	 * 初始化并发布此servlet的Web应用程序上下文。
	 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation
	 * of the context. Can be overridden in subclasses.
	 * @return the WebApplicationContext instance
	 * @see #FrameworkServlet(WebApplicationContext)
	 * @see #setContextClass
	 * @see #setContextConfigLocation
	 */
	protected WebApplicationContext initWebApplicationContext() {
		WebApplicationContext rootContext =
				WebApplicationContextUtils.getWebApplicationContext(getServletContext());
		WebApplicationContext wac = null;

		if (this.webApplicationContext != null) {
            //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的  
			wac = this.webApplicationContext;
			if (wac instanceof ConfigurableWebApplicationContext) {
				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
				if (!cwac.isActive()) {
					//上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务
					if (cwac.getParent() == null) {
						//在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素
						cwac.setParent(rootContext);
					}
					configureAndRefreshWebApplicationContext(cwac);
				}
			}
		}
		if (wac == null) {
			//在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了
			wac = findWebApplicationContext();
		}
		if (wac == null) {
			//没有的话就定义一个
			wac = createWebApplicationContext(rootContext);
		}

		if (!this.refreshEventReceived) {
			// 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息  
			onRefresh(wac);
		}

		if (this.publishContext) {
			// 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中  
			String attrName = getServletContextAttributeName();
			getServletContext().setAttribute(attrName, wac);
			if (this.logger.isDebugEnabled()) {
				this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() +
						&quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
			}
		}

		return wac;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文地址：
http://blog.csdn.net/congcong68/article/details/40451233&lt;/p&gt;

&lt;p&gt;需要学的
http://blog.csdn.net/congcong68/article/details/40650143&lt;/p&gt;</content><author><name>lipeng</name></author><category term="Spring" /><category term="配置" /><summary type="html">DispatcherServlet是SpringMVC的前置控制器，配置在web.xml中，所有请求由它统一分发。 当web项目启动的时候，执行初始化操作，初始化配置存在于Web.xml中 配置如下 &amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;!-- 启动优先级 --&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;async-supported&amp;gt;true&amp;lt;/async-supported&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; 请注意，DispatcherServlet可以配置多个，有自己的上下文容器。 PropertyValues初始化 ServletConfigPropertyValues是一个内部类 封装了bean的行为，提供了设置和获取属性值 加载资源文件 注册属性编辑 初始化beanWrapper 项目启动 DispatcherServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet 类，而HttpServletBean类有一个入口点就是重写了init方法 public final void init() throws ServletException { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Initializing servlet '&quot; + this.getServletName() + &quot;'&quot;); } try { // 1、PropertyValues初始化 ServletConfigPropertyValues是一个内部类 PropertyValues pvs = new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties); // 2、封装了bean的行为，提供了设置和获取属性值 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); // 3、加载资源文件 ResourceLoader resourceLoader = new ServletContextResourceLoader(this.getServletContext()); // 4、注册属性编辑 bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment())); // 5、初始化beanWrapper this.initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException var4) { if (this.logger.isErrorEnabled()) { this.logger.error(&quot;Failed to set bean properties on servlet '&quot; + this.getServletName() + &quot;'&quot;, var4); } throw var4; } //让子类做任何他们想要的初始化。 this.initServletBean(); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Servlet '&quot; + this.getServletName() + &quot;' configured successfully&quot;); } } PropertyValues初始化 private static class ServletConfigPropertyValues extends MutablePropertyValues { public ServletConfigPropertyValues(ServletConfig config, Set&amp;lt;String&amp;gt; requiredProperties) throws ServletException { Set&amp;lt;String&amp;gt; missingProps = requiredProperties != null &amp;amp;&amp;amp; !requiredProperties.isEmpty() ? new HashSet(requiredProperties) : null; //获取init-param中的数值对 Enumeration paramNames = config.getInitParameterNames(); while(paramNames.hasMoreElements()) { String property = (String)paramNames.nextElement(); Object value = config.getInitParameter(property); this.addPropertyValue(new PropertyValue(property, value)); if (missingProps != null) { missingProps.remove(property); } } if (!CollectionUtils.isEmpty(missingProps)) { throw new ServletException(&quot;Initialization from ServletConfig for servlet '&quot; + config.getServletName() + &quot;' failed; the following required properties were missing: &quot; + StringUtils.collectionToDelimitedString(missingProps, &quot;, &quot;)); } } } 如下图所示，获取init-param中的配置参数，写入PropertyValues BeanWrapper实现对bean行为的封装 待学习 ResourceLoader加载资源文件比较简单 public class ServletContextResourceLoader extends DefaultResourceLoader { private final ServletContext servletContext; /** * Create a new ServletContextResourceLoader. * @param servletContext the ServletContext to load resources with */ public ServletContextResourceLoader(ServletContext servletContext) { this.servletContext = servletContext; } /** * This implementation supports file paths beneath the root of the web application. * @see ServletContextResource */ @Override protected Resource getResourceByPath(String path) { return new ServletContextResource(this.servletContext, path); } } initServletBean的介绍 /** * 子类可以重写这个以执行自定义初始化。此servlet的所有bean属性将在调用此方法之前设置。 * &amp;lt;p&amp;gt;这个方法的默认实现是空的 * @throws ServletException if subclass initialization fails */ protected void initServletBean() throws ServletException { } 上面说的很清楚，这里只是提供一个方法让bean自己初始化，具体的实现在FrameworkServlet中 /** * Overridden method of {@link HttpServletBean}, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */ @Override protected final void initServletBean() throws ServletException { getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;); if (this.logger.isInfoEnabled()) { this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;); } long startTime = System.currentTimeMillis(); try { //这里是主要的动作，创建应用程序上下文 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } catch (RuntimeException ex) { this.logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; + elapsedTime + &quot; ms&quot;); } } /** * 初始化并发布此servlet的Web应用程序上下文。 * &amp;lt;p&amp;gt;Delegates to {@link #createWebApplicationContext} for actual creation * of the context. Can be overridden in subclasses. * @return the WebApplicationContext instance * @see #FrameworkServlet(WebApplicationContext) * @see #setContextClass * @see #setContextConfigLocation */ protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { //根节点上下文，是通过ContextLoaderListener加载的，服务器启动时，最先加载的 wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { //上下文还没有被刷新——&amp;gt;提供诸如设置父上下文、设置应用程序上下文id等服务 if (cwac.getParent() == null) { //在没有显式parent的情况下注入上下文实例,设置根应用程序上下文(如果有的话, 不过也可能是null)作为父元素 cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { //在构建时没有注入上下文实例——&amp;gt;查看是否在servlet上下文中注册了 wac = findWebApplicationContext(); } if (wac == null) { //没有的话就定义一个 wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // 在上下文关闭的情况下调用refesh可启动应用上下文，在已经启动的状态下，调用refresh则清除缓存并重新装载配置信息 onRefresh(wac); } if (this.publishContext) { // 对不同的请求对应的DispatherServlet有不同的WebApplicationContext、并且都存放在ServletContext中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() + &quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;); } } return wac; } 本文地址： http://blog.csdn.net/congcong68/article/details/40451233 需要学的 http://blog.csdn.net/congcong68/article/details/40650143</summary></entry><entry><title type="html">component-scan总结</title><link href="http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="component-scan总结" /><published>2017-12-12T21:51:29+08:00</published><updated>2017-12-12T21:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/ProgramNote/spring/2017/12/12/component-scan%E6%80%BB%E7%BB%93.html">&lt;p&gt;今天偶然看到了原有的一个项目中有这样的配置信息&lt;/p&gt;

&lt;p&gt;配置文件&lt;strong&gt;spring-config.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 扫描注解Bean --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:exclude-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置文件&lt;strong&gt;spring-mvc.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 开启controller注解支持 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.aaa.bbb.platform.controller&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;use-default-filters=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.stereotype.Controller&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:include-filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;annotation&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/context:component-scan&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在&lt;strong&gt;spring-config.xml&lt;/strong&gt;中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。&lt;/p&gt;

&lt;p&gt;第二个问题是&lt;code class=&quot;highlighter-rouge&quot;&gt;use-default-filters=&quot;false&quot;&lt;/code&gt;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。&lt;/p&gt;

&lt;h1 id=&quot;component-scan的分析&quot;&gt;component-scan的分析&lt;/h1&gt;

&lt;h2 id=&quot;注册解析器&quot;&gt;注册解析器&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;component-scan&lt;/code&gt;交由&lt;code class=&quot;highlighter-rouge&quot;&gt;org.springframework.context.config.ContextNamespaceHandler&lt;/code&gt;处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class ContextNamespaceHandler extends NamespaceHandlerSupport {
    public ContextNamespaceHandler() {
    }

    public void init() {
        this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());
        //这里注册处理的解析器
        this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());
        this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;componentscanbeandefinitionparser组装classpathbeandefinitionscanner&quot;&gt;ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        //获取basePackage
        String basePackage = element.getAttribute(&quot;base-package&quot;);
        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
        //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式
        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;);
        //组装ClassPathBeanDefinitionScanner
        ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element);
        //扫描===========
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages);
        //注册bean
        this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //组装ClassPathBeanDefinitionScanner
    protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {
        //默认情况下  use-default-filters属性为true
        boolean useDefaultFilters = true;
        if (element.hasAttribute(&quot;use-default-filters&quot;)) {
            useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;));
        }
        //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner
        ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters);
        scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());
        scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());
        if (element.hasAttribute(&quot;resource-pattern&quot;)) {
            scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;));
        }

        try {
            this.parseBeanNameGenerator(element, scanner);
        } catch (Exception var7) {
            parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause());
        }

        try {
            this.parseScope(element, scanner);
        } catch (Exception var6) {
            parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause());
        }

        this.parseTypeFilters(element, scanner, parserContext);
        return scanner;
    }

    protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) {
        return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //ClassPathBeanDefinitionScanner构造器
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) {
        this.beanDefinitionDefaults = new BeanDefinitionDefaults();
        this.beanNameGenerator = new AnnotationBeanNameGenerator();
        this.scopeMetadataResolver = new AnnotationScopeMetadataResolver();
        this.includeAnnotationConfig = true;
        Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
        this.registry = registry;
        if (useDefaultFilters) {
            //这里注册过滤器，就是那些bean被扫描注册
            this.registerDefaultFilters();
        }

        this.setEnvironment(environment);
        this.setResourceLoader(resourceLoader);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    //注册过滤器
    // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。
    protected void registerDefaultFilters() {
        this.includeFilters.add(new AnnotationTypeFilter(Component.class));
        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false));
            this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var4) {
            ;
        }

        try {
            this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false));
            this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;);
        } catch (ClassNotFoundException var3) {
            ;
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再次回到&lt;code class=&quot;highlighter-rouge&quot;&gt;//扫描===========&lt;/code&gt;这个地方，继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) {
        Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
        Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet();
        String[] var3 = basePackages;
        int var4 = basePackages.length;

        for(int var5 = 0; var5 &amp;lt; var4; ++var5) {
            String basePackage = var3[var5];
            //这里判定是否符合条件
            Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage);
            Iterator var8 = candidates.iterator();

            while(var8.hasNext()) {
                BeanDefinition candidate = (BeanDefinition)var8.next();
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                candidate.setScope(scopeMetadata.getScopeName());
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                if (candidate instanceof AbstractBeanDefinition) {
                    this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);
                }

                if (candidate instanceof AnnotatedBeanDefinition) {
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);
                }

                if (this.checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    this.registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }

        return beanDefinitions;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定符合条件的地方继续往下走&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) {
        LinkedHashSet candidates = new LinkedHashSet();

        try {
            String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
            boolean traceEnabled = this.logger.isTraceEnabled();
            boolean debugEnabled = this.logger.isDebugEnabled();
            Resource[] var7 = resources;
            int var8 = resources.length;

            for(int var9 = 0; var9 &amp;lt; var8; ++var9) {
                Resource resource = var7[var9];
                if (traceEnabled) {
                    this.logger.trace(&quot;Scanning &quot; + resource);
                }

                if (resource.isReadable()) {
                    try {
                        MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                        //这里判定是否符合排除或者包含的component条件
                        if (this.isCandidateComponent(metadataReader)) {
                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                            sbd.setResource(resource);
                            sbd.setSource(resource);
                            if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) {
                                if (debugEnabled) {
                                    this.logger.debug(&quot;Identified candidate component class: &quot; + resource);
                                }

                                candidates.add(sbd);
                            } else if (debugEnabled) {
                                this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource);
                            }
                        } else if (traceEnabled) {
                            this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource);
                        }
                    } catch (Throwable var13) {
                        throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13);
                    }
                } else if (traceEnabled) {
                    this.logger.trace(&quot;Ignored because not readable: &quot; + resource);
                }
            }

            return candidates;
        } catch (IOException var14) {
            throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从判定是否符合component的地方继续&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
        Iterator var2 = this.excludeFilters.iterator();

        TypeFilter tf;
        do {
            //先判断 exclude-filter,黑名单过滤
            if (!var2.hasNext()) {
                var2 = this.includeFilters.iterator();

                do {
                    //然后判断 include-filter,白名单过滤
                    // 其他情况排除
                    if (!var2.hasNext()) {
                        return false;
                    }

                    tf = (TypeFilter)var2.next();
                } while(!tf.match(metadataReader, this.metadataReaderFactory));

                return this.isConditionMatch(metadataReader);
            }

            tf = (TypeFilter)var2.next();
        } while(!tf.match(metadataReader, this.metadataReaderFactory));

        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter&lt;/li&gt;
  &lt;li&gt;use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描&lt;/li&gt;
  &lt;li&gt;controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）&lt;/li&gt;
&lt;/ul&gt;</content><author><name>lipeng</name></author><category term="Spring" /><category term="配置" /><summary type="html">今天偶然看到了原有的一个项目中有这样的配置信息 配置文件spring-config.xml &amp;lt;!-- 扫描注解Bean --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb,com.aaa.bbb.platform.model.sys&quot;&amp;gt; &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 配置文件spring-mvc.xml &amp;lt;!-- 开启controller注解支持 --&amp;gt; &amp;lt;context:component-scan base-package=&quot;com.aaa.bbb.platform.controller&quot; use-default-filters=&quot;false&quot;&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; 我的第一个问题是为什么不能直接把这两个配置信息合并在一起呢？然后我试了一下，都放在spring-config.xml中，很不幸，这样是不行的，无法访问到Controller，原因我猜想是Springmvc有自己的初始化过程，放在Spring中初始化导致无法获取到控制层信息，准备过段时间研究一下Springmvc的实现原理。 第二个问题是use-default-filters=&quot;false&quot;是做什么的？为什么一个加了，一个没有加，于是我找到了下面的答案。 component-scan的分析 注册解析器 component-scan交由org.springframework.context.config.ContextNamespaceHandler处理 public class ContextNamespaceHandler extends NamespaceHandlerSupport { public ContextNamespaceHandler() { } public void init() { this.registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser()); //这里注册处理的解析器 this.registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser()); } } ComponentScanBeanDefinitionParser组装ClassPathBeanDefinitionScanner public BeanDefinition parse(Element element, ParserContext parserContext) { //获取basePackage String basePackage = element.getAttribute(&quot;base-package&quot;); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); //注意，这里表示配置多个package的时候可以使用, ; 换行三种形式 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, &quot;,; \t\n&quot;); //组装ClassPathBeanDefinitionScanner ClassPathBeanDefinitionScanner scanner = this.configureScanner(parserContext, element); //扫描=========== Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages); //注册bean this.registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; } //组装ClassPathBeanDefinitionScanner protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) { //默认情况下 use-default-filters属性为true boolean useDefaultFilters = true; if (element.hasAttribute(&quot;use-default-filters&quot;)) { useDefaultFilters = Boolean.valueOf(element.getAttribute(&quot;use-default-filters&quot;)); } //创建ClassPathBeanDefinitionScanner，调用下面一个方法createScanner ClassPathBeanDefinitionScanner scanner = this.createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(&quot;resource-pattern&quot;)) { scanner.setResourcePattern(element.getAttribute(&quot;resource-pattern&quot;)); } try { this.parseBeanNameGenerator(element, scanner); } catch (Exception var7) { parserContext.getReaderContext().error(var7.getMessage(), parserContext.extractSource(element), var7.getCause()); } try { this.parseScope(element, scanner); } catch (Exception var6) { parserContext.getReaderContext().error(var6.getMessage(), parserContext.extractSource(element), var6.getCause()); } this.parseTypeFilters(element, scanner, parserContext); return scanner; } protected ClassPathBeanDefinitionScanner createScanner(XmlReaderContext readerContext, boolean useDefaultFilters) { return new ClassPathBeanDefinitionScanner(readerContext.getRegistry(), useDefaultFilters, readerContext.getEnvironment(), readerContext.getResourceLoader()); } //ClassPathBeanDefinitionScanner构造器 public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, ResourceLoader resourceLoader) { this.beanDefinitionDefaults = new BeanDefinitionDefaults(); this.beanNameGenerator = new AnnotationBeanNameGenerator(); this.scopeMetadataResolver = new AnnotationScopeMetadataResolver(); this.includeAnnotationConfig = true; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) { //这里注册过滤器，就是那些bean被扫描注册 this.registerDefaultFilters(); } this.setEnvironment(environment); this.setResourceLoader(resourceLoader); } //注册过滤器 // 可以看到默认ClassPathBeanDefinitionScanner会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描。 protected void registerDefaultFilters() { this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.annotation.ManagedBean&quot;, cl), false)); this.logger.debug(&quot;JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning&quot;); } catch (ClassNotFoundException var4) { ; } try { this.includeFilters.add(new AnnotationTypeFilter(ClassUtils.forName(&quot;javax.inject.Named&quot;, cl), false)); this.logger.debug(&quot;JSR-330 'javax.inject.Named' annotation found and supported for component scanning&quot;); } catch (ClassNotFoundException var3) { ; } } 我们再次回到//扫描===========这个地方，继续往下走 protected Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) { Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &amp;lt; var4; ++var5) { String basePackage = var3[var5]; //这里判定是否符合条件 Set&amp;lt;BeanDefinition&amp;gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) { BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) { this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); } if (candidate instanceof AnnotatedBeanDefinition) { AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); } if (this.checkCandidate(beanName, candidate)) { BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); this.registerBeanDefinition(definitionHolder, this.registry); } } } return beanDefinitions; } 从判定符合条件的地方继续往下走 public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) { LinkedHashSet candidates = new LinkedHashSet(); try { String packageSearchPath = &quot;classpath*:&quot; + this.resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = this.logger.isTraceEnabled(); boolean debugEnabled = this.logger.isDebugEnabled(); Resource[] var7 = resources; int var8 = resources.length; for(int var9 = 0; var9 &amp;lt; var8; ++var9) { Resource resource = var7[var9]; if (traceEnabled) { this.logger.trace(&quot;Scanning &quot; + resource); } if (resource.isReadable()) { try { MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //这里判定是否符合排除或者包含的component条件 if (this.isCandidateComponent(metadataReader)) { ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (this.isCandidateComponent((AnnotatedBeanDefinition)sbd)) { if (debugEnabled) { this.logger.debug(&quot;Identified candidate component class: &quot; + resource); } candidates.add(sbd); } else if (debugEnabled) { this.logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not matching any filter: &quot; + resource); } } catch (Throwable var13) { throw new BeanDefinitionStoreException(&quot;Failed to read candidate component class: &quot; + resource, var13); } } else if (traceEnabled) { this.logger.trace(&quot;Ignored because not readable: &quot; + resource); } } return candidates; } catch (IOException var14) { throw new BeanDefinitionStoreException(&quot;I/O failure during classpath scanning&quot;, var14); } } 从判定是否符合component的地方继续 protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException { Iterator var2 = this.excludeFilters.iterator(); TypeFilter tf; do { //先判断 exclude-filter,黑名单过滤 if (!var2.hasNext()) { var2 = this.includeFilters.iterator(); do { //然后判断 include-filter,白名单过滤 // 其他情况排除 if (!var2.hasNext()) { return false; } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return this.isConditionMatch(metadataReader); } tf = (TypeFilter)var2.next(); } while(!tf.match(metadataReader, this.metadataReaderFactory)); return false; } 结论 include-filter和exclude-filter同时配置时，exclude-filter优先级高于include-filter use-default-filters默认为true，默认情况下会自动扫描@Component、@ManagedBean、@Named，由于service，repository是component的继承，所以也会被扫描 controller需要配置在Springmvc中，同时spring中不能重复配置，否则会导致异常情况（如事务失效）</summary></entry><entry><title type="html">Mybatis框架设计</title><link href="http://localhost:4000/ProgramNote/mybatis/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1.html" rel="alternate" type="text/html" title="Mybatis框架设计" /><published>2017-12-11T13:51:29+08:00</published><updated>2017-12-11T13:51:29+08:00</updated><id>http://localhost:4000/ProgramNote/mybatis/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1</id><content type="html" xml:base="http://localhost:4000/ProgramNote/mybatis/2017/12/11/Mybatis%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1.html">&lt;!-- TOC --&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1-mybatis%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1&quot;&gt;1. Mybatis框架设计&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-%E6%8E%A5%E5%8F%A3%E5%B1%82--%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F&quot;&gt;1.1. 接口层–和数据库交互的方式&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#111-%E4%BD%BF%E7%94%A8mybatis%E6%8F%90%E4%BE%9B%E7%9A%84api&quot;&gt;1.1.1. 使用Mybatis提供的API&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#112-%E4%BD%BF%E7%94%A8mapper%E6%8E%A5%E5%8F%A3&quot;&gt;1.1.2. 使用Mapper接口&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#12-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B1%82&quot;&gt;1.2. 数据处理层&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#121-%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%92%8C%E5%8A%A8%E6%80%81sql%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90&quot;&gt;1.2.1. 参数映射和动态SQL语句生成&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;[1.2.2. SQL语句的执行以及封装查询结果集成List&lt;E&gt;](#122-sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E6%88%90liste)&lt;/E&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#13-%E6%A1%86%E6%9E%B6%E6%94%AF%E6%92%91%E5%B1%82&quot;&gt;1.3. 框架支撑层&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#131-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6&quot;&gt;1.3.1. 事务管理机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#132-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6&quot;&gt;1.3.2. 连接池管理机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#133-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6&quot;&gt;1.3.3. 缓存机制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#134-sql%E8%AF%AD%E5%8F%A5%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F&quot;&gt;1.3.4. SQL语句配置方式&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#135-%E5%BC%95%E5%AF%BC%E5%B1%82&quot;&gt;1.3.5. 引导层&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-mybatis%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6%E4%B8%80%E8%B5%B7%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB&quot;&gt;2. Mybatis主要构件一起相互关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90&quot;&gt;3. 实例分析&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#31-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87&quot;&gt;3.1. 数据准备&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#311-%E6%95%B0%E6%8D%AE%E5%BA%93&quot;&gt;3.1.1. 数据库&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#312-mybatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-mybatisconfigxml&quot;&gt;3.1.2. Mybatis配置文件 mybatisConfig.xml&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#313-%E5%88%9B%E5%BB%BAemployee%E5%AE%9E%E4%BD%93bean-%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AEmapper%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#314-%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81&quot;&gt;3.1.4. 演示代码&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#32-sqlsession%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B%E5%88%86%E6%9E%90&quot;&gt;3.2. SqlSession工作工程分析&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#321-%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E4%BC%9A%E8%AF%9D--%E5%88%9B%E5%BB%BAsqlsession%E5%AF%B9%E8%B1%A1&quot;&gt;3.2.1. 开启一个数据库访问会话–创建SqlSession对象&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#322-%E4%B8%BAsqlsession%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%9A%84sql%E8%AF%AD%E5%8F%A5statementid%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C&quot;&gt;3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#323-mybatis%E6%89%A7%E8%A1%8C%E5%99%A8executor%E6%A0%B9%E6%8D%AEsqlsession%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E6%89%A7%E8%A1%8Cquery%E6%96%B9%E6%B3%95&quot;&gt;3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#324-statementhandler%E5%AF%B9%E8%B1%A1%E8%B4%9F%E8%B4%A3%E8%AE%BE%E7%BD%AEstatement%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E3%80%81%E5%A4%84%E7%90%86jdbc%E8%BF%94%E5%9B%9E%E7%9A%84resultset%EF%BC%8C%E5%B0%86resultset%E5%8A%A0%E5%B7%A5%E4%B8%BAlist-%E9%9B%86%E5%90%88%E8%BF%94%E5%9B%9E&quot;&gt;3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#325-statementhandler-%E7%9A%84parameterizestatement-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0&quot;&gt;3.2.5. StatementHandler 的parameterize(statement) 方法的实现&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;[3.2.6. StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现](#326-statementhandler-%E7%9A%84liste-querystatement-statement-resulthandler-resulthandler%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0)&lt;/E&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;
&lt;h1 id=&quot;1-mybatis框架设计&quot;&gt;1. Mybatis框架设计&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/16.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-接口层和数据库交互的方式&quot;&gt;1.1. 接口层–和数据库交互的方式&lt;/h2&gt;
&lt;p&gt;Mybatis和数据库交互有两种方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用Mybatis提供的API&lt;/li&gt;
  &lt;li&gt;使用Mapper接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;111-使用mybatis提供的api&quot;&gt;1.1.1. 使用Mybatis提供的API&lt;/h3&gt;

&lt;p&gt;这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；&lt;/p&gt;

&lt;p&gt;MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/17.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。&lt;/p&gt;

&lt;h3 id=&quot;112-使用mapper接口&quot;&gt;1.1.2. 使用Mapper接口&lt;/h3&gt;

&lt;p&gt;MyBatis 将配置文件中的每一个&lt;mapper&gt; 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟&lt;mapper&gt; 节点中的&amp;lt;select|update|delete|insert&amp;gt; 节点项对应，即&amp;lt;select|update|delete|insert&amp;gt; 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。&lt;/mapper&gt;&lt;/mapper&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/18.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作.&lt;/p&gt;

&lt;p&gt;MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。&lt;/p&gt;

&lt;h2 id=&quot;12-数据处理层&quot;&gt;1.2. 数据处理层&lt;/h2&gt;
&lt;p&gt;数据处理层是Mybatis的核心，主要完成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过传入参数构建动态SQL语句&lt;/li&gt;
  &lt;li&gt;SQL语句的执行&lt;/li&gt;
  &lt;li&gt;封装查询结果集成List&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;121-参数映射和动态sql语句生成&quot;&gt;1.2.1. 参数映射和动态SQL语句生成&lt;/h3&gt;
&lt;p&gt;Mybatis通过传入参数值使用OGNL动态构造SQL语句。&lt;/p&gt;

&lt;p&gt;参数映射是指java数据类型和jdbc数据类型之间的转换，这里包含两个过程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查询阶段，要将java类型的数据转换成jdbc类型的数据，通过preparedStatement.setXXX() 来设值；&lt;/li&gt;
  &lt;li&gt;另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;122-sql语句的执行以及封装查询结果集成list&quot;&gt;1.2.2. SQL语句的执行以及封装查询结果集成List&lt;E&gt;&lt;/E&gt;&lt;/h3&gt;
&lt;p&gt;动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List&lt;E&gt; 列表。&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。&lt;/p&gt;

&lt;h2 id=&quot;13-框架支撑层&quot;&gt;1.3. 框架支撑层&lt;/h2&gt;
&lt;h3 id=&quot;131-事务管理机制&quot;&gt;1.3.1. 事务管理机制&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/05-Mybatis/04-Mybatis事务管理.md&quot;&gt;Mybatis事务&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;132-连接池管理机制&quot;&gt;1.3.2. 连接池管理机制&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/05-Mybatis/03-Mybatis数据源和连接池&quot;&gt;Mybatis数据源和连接池&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;133-缓存机制&quot;&gt;1.3.3. 缓存机制&lt;/h3&gt;
&lt;p&gt;为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。&lt;/p&gt;

&lt;h3 id=&quot;134-sql语句配置方式&quot;&gt;1.3.4. SQL语句配置方式&lt;/h3&gt;

&lt;p&gt;传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。&lt;/p&gt;

&lt;h3 id=&quot;135-引导层&quot;&gt;1.3.5. 引导层&lt;/h3&gt;
&lt;p&gt;引导层是配置和启动MyBatis 配置信息的方式。&lt;/p&gt;

&lt;p&gt;MyBatis 提供两种方式来引导MyBatis&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基于XML配置文件的方式&lt;/li&gt;
  &lt;li&gt;基于Java API 的方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luanlouis/article/details/35570809&quot;&gt;Java Persistence with MyBatis 3(中文版) 第二章 引导MyBatis&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-mybatis主要构件一起相互关系&quot;&gt;2. Mybatis主要构件一起相互关系&lt;/h1&gt;

&lt;p&gt;Mybatis主要的核心部件（非全部）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SqlSession
    &lt;ul&gt;
      &lt;li&gt;作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Executor
    &lt;ul&gt;
      &lt;li&gt;MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;StatementHandler
    &lt;ul&gt;
      &lt;li&gt;封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ParameterHandler
    &lt;ul&gt;
      &lt;li&gt;负责对用户传递的参数转换成JDBC Statement 所需要的参数，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ResultSetHandler
    &lt;ul&gt;
      &lt;li&gt;负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TypeHandler
    &lt;ul&gt;
      &lt;li&gt;负责java数据类型和jdbc数据类型之间的映射和转换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MappedStatement
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;MappedStatement维护了一条&amp;lt;select&lt;/td&gt;
              &lt;td&gt;update&lt;/td&gt;
              &lt;td&gt;delete&lt;/td&gt;
              &lt;td&gt;insert&amp;gt;节点的封装，&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SqlSource
    &lt;ul&gt;
      &lt;li&gt;负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BoundSql
    &lt;ul&gt;
      &lt;li&gt;表示动态生成的SQL语句以及相应的参数信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Configuration
    &lt;ul&gt;
      &lt;li&gt;MyBatis所有的配置信息都维持在Configuration对象之中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/19.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-实例分析&quot;&gt;3. 实例分析&lt;/h1&gt;
&lt;h2 id=&quot;31-数据准备&quot;&gt;3.1. 数据准备&lt;/h2&gt;

&lt;h3 id=&quot;311-数据库&quot;&gt;3.1.1. 数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;   
   --创建一个员工基本信息表
    create  table &quot;EMPLOYEES&quot;(
        &quot;EMPLOYEE_ID&quot; NUMBER(6) not null,
       &quot;FIRST_NAME&quot; VARCHAR2(20),
       &quot;LAST_NAME&quot; VARCHAR2(25) not null,
       &quot;EMAIL&quot; VARCHAR2(25) not null unique,
       &quot;SALARY&quot; NUMBER(8,2),
        constraint &quot;EMP_EMP_ID_PK&quot; primary key (&quot;EMPLOYEE_ID&quot;)
    );
    comment on table EMPLOYEES is '员工信息表';
    comment on column EMPLOYEES.EMPLOYEE_ID is '员工id';
    comment on column EMPLOYEES.FIRST_NAME is 'first name';
    comment on column EMPLOYEES.LAST_NAME is 'last name';
    comment on column EMPLOYEES.EMAIL is 'email address';
    comment on column EMPLOYEES.SALARY is 'salary';
    
    --添加数据
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (100, 'Steven', 'King', 'SKING', 24000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (101, 'Neena', 'Kochhar', 'NKOCHHAR', 17000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (102, 'Lex', 'De Haan', 'LDEHAAN', 17000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (103, 'Alexander', 'Hunold', 'AHUNOLD', 9000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (104, 'Bruce', 'Ernst', 'BERNST', 6000.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (105, 'David', 'Austin', 'DAUSTIN', 4800.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (106, 'Valli', 'Pataballa', 'VPATABAL', 4800.00);
	
	insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY)
	values (107, 'Diana', 'Lorentz', 'DLORENTZ', 4200.00);    

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;312-mybatis配置文件-mybatisconfigxml&quot;&gt;3.1.2. Mybatis配置文件 mybatisConfig.xml&lt;/h3&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;environments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;environment&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;JDBC&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	 &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;driver&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;oracle.jdbc.driver.OracleDriver&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;louis&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123456&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;&amp;lt;mapper&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;resource=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com/louis/mybatis/domain/EmployeesMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;313-创建employee实体bean-以及配置mapper配置文件&quot;&gt;3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.louis.mybatis.model;

import java.math.BigDecimal;

public class Employee {
    private Integer employeeId;

    private String firstName;

    private String lastName;

    private String email;

    private BigDecimal salary;

    public Integer getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(Integer employeeId) {
        this.employeeId = employeeId;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;com.louis.mybatis.dao.EmployeesMapper&quot; &amp;gt;

  &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.louis.mybatis.model.Employee&quot; &amp;gt;
    &amp;lt;id column=&quot;EMPLOYEE_ID&quot; property=&quot;employeeId&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt;
    &amp;lt;result column=&quot;FIRST_NAME&quot; property=&quot;firstName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;LAST_NAME&quot; property=&quot;lastName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;EMAIL&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;SALARY&quot; property=&quot;salary&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;
  
  &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &amp;gt;
    select 
    	EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY
    	from LOUIS.EMPLOYEES
    	where EMPLOYEE_ID = #{employeeId,jdbcType=DECIMAL}
  &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MAVEN依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt;  
    &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;3.2.7&amp;lt;/version&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
      
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt;  
        &amp;lt;version&amp;gt;10.2.0.4.0&amp;lt;/version&amp;gt;  
    &amp;lt;/dependency&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;314-演示代码&quot;&gt;3.1.4. 演示代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;package com.louis.mybatis.test;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import com.louis.mybatis.model.Employee;

/**
 * SqlSession 简单查询演示类
 * @author louluan
 */
public class SelectDemo {

	public static void main(String[] args) throws Exception {
		/*
		 * 1.加载mybatis的配置文件，初始化mybatis，创建出SqlSessionFactory，是创建SqlSession的工厂
		 * 这里只是为了演示的需要，SqlSessionFactory临时创建出来，在实际的使用中，SqlSessionFactory只需要创建一次，当作单例来使用
		 */
		InputStream inputStream = Resources.getResourceAsStream(&quot;mybatisConfig.xml&quot;);
		SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
		SqlSessionFactory factory = builder.build(inputStream);
		
		//2. 从SqlSession工厂 SqlSessionFactory中创建一个SqlSession，进行数据库操作
		SqlSession sqlSession = factory.openSession();
	
		//3.使用SqlSession查询
		Map&amp;lt;String,Object&amp;gt; params = new HashMap&amp;lt;String,Object&amp;gt;();
		
		params.put(&quot;min_salary&quot;,10000);
		//a.查询工资低于10000的员工
		List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);
		//b.未传最低工资，查所有员工
		List&amp;lt;Employee&amp;gt; result1 = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;);
		System.out.println(&quot;薪资低于10000的员工数：&quot;+result.size());
		//~output :   查询到的数据总数：5  
		System.out.println(&quot;所有员工数: &quot;+result1.size());
		//~output :  所有员工数: 8
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;32-sqlsession工作工程分析&quot;&gt;3.2. SqlSession工作工程分析&lt;/h2&gt;
&lt;h3 id=&quot;321-开启一个数据库访问会话创建sqlsession对象&quot;&gt;3.2.1. 开启一个数据库访问会话–创建SqlSession对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;SqlSession sqlSession = factory.openSession();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mybatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/ProgramNote/assets/Image/mybatis/20.png&quot; alt=&quot;Mybatis设计图&quot; title=&quot;设计图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;322-为sqlsession传递一个配置的sql语句statementid和参数然后返回结果&quot;&gt;3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&lt;/strong&gt;是配置在xml中的statementId， params是传递的查询参数。&lt;/p&gt;

&lt;p&gt;selectList的默认实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //1、根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement   
      MappedStatement ms = configuration.getMappedStatement(statement);
      //2、将查询任务委托给Mybatis的执行器Execute
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，使用org.apache.ibatis.session.Configuration实例来维护。使用者可以使用sqlSession.getConfiguration()方法来获取。MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的。上述例子中的&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;select&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;selectByMinSalary&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;resultMap=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BaseResultMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;parameterType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java.util.Map&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    select 
    	EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY
    	from LOUIS.EMPLOYEES
    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;if&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;test=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;min_salary != null&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    		where SALARY &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt; #{min_salary,jdbcType=DECIMAL}
    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/if&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;会加载到内存中生成一个对应的MappedStatement对象，然后以 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; = MappedStatement对象的形式维护到Configuration的一个Map中。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作。&lt;/p&gt;

&lt;h3 id=&quot;323-mybatis执行器executor根据sqlsession传递的参数执行query方法&quot;&gt;3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
* BaseExecutor 类部分代码
*
*/
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
	// 1.根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示  
    BoundSql boundSql = ms.getBoundSql(parameter);
    // 2.为当前的查询创建一个缓存Key
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }

  @SuppressWarnings(&quot;unchecked&quot;)
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;);
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
    	// 3.缓存中没有值，直接从数据库中读取数据  
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      deferredLoads.clear(); // issue #601
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        clearLocalCache(); // issue #482
      }
    }
    return list;
  }
 private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
    	
      //4. 执行查询，返回List 结果，然后	将查询的结果放入缓存之中
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*
*SimpleExecutor类的doQuery()方法实现
*
*/
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      //5. 根据既有的参数，创建StatementHandler对象来执行查询操作
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //6. 创建java.Sql.Statement对象，传递给StatementHandler对象
      stmt = prepareStatement(handler, ms.getStatementLog());
      //7. 调用StatementHandler.query()方法，返回List结果集
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor.query()&lt;/code&gt;方法几经转折，最后会创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;对象，然后将必要的参数传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;StatementHandler&lt;/code&gt;来完成对数据库的查询，最终返回List结果集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用；&lt;/li&gt;
  &lt;li&gt;为查询创建缓存，以提高性能&lt;/li&gt;
  &lt;li&gt;创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;324-statementhandler对象负责设置statement对象中的查询参数处理jdbc返回的resultset将resultset加工为list-集合返回&quot;&gt;3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回&lt;/h3&gt;
&lt;p&gt;看一下：prepareStatement() 方法的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*
*SimpleExecutor类的doQuery()方法实现
*
*/
    public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { 
        Statement stmt = null; 
        try { 
            Configuration configuration = ms.getConfiguration(); 
            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); 
            // 1.准备Statement对象，并设置Statement对象的参数 
            stmt = prepareStatement(handler, ms.getStatementLog()); 
            // 2. StatementHandler执行query()方法，返回List结果 
            return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); 
        } 
        finally 
        { 
            closeStatement(stmt); 
        } 
    }

  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    Connection connection = getConnection(statementLog);
    stmt = handler.prepare(connection);
    //对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数
    handler.parameterize(stmt);
    return stmt;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。
StatementHandler通过parameterize(statement)方法对Statement进行设值；&lt;/li&gt;
  &lt;li&gt;StatementHandler通过List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List；&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;325-statementhandler-的parameterizestatement-方法的实现&quot;&gt;3.2.5. StatementHandler 的parameterize(statement) 方法的实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**
*   StatementHandler 类的parameterize(statement) 方法实现 
*/
public void parameterize(Statement statement) throws SQLException {
	//使用ParameterHandler对象来完成对Statement的设值  
    parameterHandler.setParameters((PreparedStatement) statement);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
   * 
   *ParameterHandler类的setParameters(PreparedStatement ps) 实现
   * 对某一个Statement进行设置参数
   */
  public void setParameters(PreparedStatement ps) throws SQLException {
    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();
    if (parameterMappings != null) {
      for (int i = 0; i &amp;lt; parameterMappings.size(); i++) {
        ParameterMapping parameterMapping = parameterMappings.get(i);
        if (parameterMapping.getMode() != ParameterMode.OUT) {
          Object value;
          String propertyName = parameterMapping.getProperty();
          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params
            value = boundSql.getAdditionalParameter(propertyName);
          } else if (parameterObject == null) {
            value = null;
          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
            value = parameterObject;
          } else {
            MetaObject metaObject = configuration.newMetaObject(parameterObject);
            value = metaObject.getValue(propertyName);
          }
          
          // 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数
          TypeHandler typeHandler = parameterMapping.getTypeHandler();
          JdbcType jdbcType = parameterMapping.getJdbcType();
          if (value == null &amp;amp;&amp;amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull();
          // 设置参数
          typeHandler.setParameter(ps, i + 1, value, jdbcType);
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;StatementHandler 的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法&lt;/li&gt;
  &lt;li&gt;ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;326-statementhandler-的list-querystatement-statement-resulthandler-resulthandler方法的实现&quot;&gt;3.2.6. StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现&lt;/E&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  /**
   * PreParedStatement类的query方法实现
   */
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
	// 1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理  
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    //2. 使用ResultHandler来处理ResultSet
    return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;/**  
*ResultSetHandler类的handleResultSets()方法实现
*
*/
public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
    final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;();

    int resultSetCount = 0;
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    
    while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      
      //将resultSet
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResulSets();
    if (resultSets != null) {
      while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StatementHandler 的List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List&lt;E&gt; 结果集&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  //
  // DefaultResultSetHandler 类的handleResultSets(Statement stmt)实现 
  //HANDLE RESULT SETS
  //

  public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
    final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;();

    int resultSetCount = 0;
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    
    while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      
      //将resultSet
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResulSets();
    if (resultSets != null) {
      while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>lipeng</name></author><category term="Mybatis" /><category term="构架" /><summary type="html">1. Mybatis框架设计 1.1. 接口层–和数据库交互的方式 1.1.1. 使用Mybatis提供的API 1.1.2. 使用Mapper接口 1.2. 数据处理层 1.2.1. 参数映射和动态SQL语句生成 [1.2.2. SQL语句的执行以及封装查询结果集成List](#122-sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%A5%E5%8F%8A%E5%B0%81%E8%A3%85%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86%E6%88%90liste) 1.3. 框架支撑层 1.3.1. 事务管理机制 1.3.2. 连接池管理机制 1.3.3. 缓存机制 1.3.4. SQL语句配置方式 1.3.5. 引导层 2. Mybatis主要构件一起相互关系 3. 实例分析 3.1. 数据准备 3.1.1. 数据库 3.1.2. Mybatis配置文件 mybatisConfig.xml 3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件 3.1.4. 演示代码 3.2. SqlSession工作工程分析 3.2.1. 开启一个数据库访问会话–创建SqlSession对象 3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果 3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法 3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回 3.2.5. StatementHandler 的parameterize(statement) 方法的实现 [3.2.6. StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现](#326-statementhandler-%E7%9A%84liste-querystatement-statement-resulthandler-resulthandler%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0) 1. Mybatis框架设计 1.1. 接口层–和数据库交互的方式 Mybatis和数据库交互有两种方式 使用Mybatis提供的API 使用Mapper接口 1.1.1. 使用Mybatis提供的API 这是传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互； MyBatis 提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作。 创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。 1.1.2. 使用Mapper接口 MyBatis 将配置文件中的每一个 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟 节点中的&amp;lt;select|update|delete|insert&amp;gt; 节点项对应，即&amp;lt;select|update|delete|insert&amp;gt; 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。 根据MyBatis 的配置规范配置好后，通过SqlSession.getMapper(XXXMapper.class) 方法，MyBatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个Mapper 实例，我们使用Mapper 接口的某一个方法时，MyBatis 会根据这个方法的方法名和参数类型，确定Statement Id，底层还是通过SqlSession.select(“statementId”,parameterObject);或者SqlSession.update(“statementId”,parameterObject); 等等来实现对数据库的操作. MyBatis 引用Mapper 接口这种调用方式，纯粹是为了满足面向接口编程的需要。（其实还有一个原因是在于，面向接口的编程，使得用户在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”）。 1.2. 数据处理层 数据处理层是Mybatis的核心，主要完成 通过传入参数构建动态SQL语句 SQL语句的执行 封装查询结果集成List 1.2.1. 参数映射和动态SQL语句生成 Mybatis通过传入参数值使用OGNL动态构造SQL语句。 参数映射是指java数据类型和jdbc数据类型之间的转换，这里包含两个过程 查询阶段，要将java类型的数据转换成jdbc类型的数据，通过preparedStatement.setXXX() 来设值； 另一个就是对resultset查询结果集的jdbcType 数据转换成java 数据类型。 1.2.2. SQL语句的执行以及封装查询结果集成List 动态SQL语句生成之后，MyBatis 将执行SQL语句，并将可能返回的结果集转换成List 列表。 MyBatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。 1.3. 框架支撑层 1.3.1. 事务管理机制 Mybatis事务 1.3.2. 连接池管理机制 Mybatis数据源和连接池 1.3.3. 缓存机制 为了提高数据利用率和减小服务器和数据库的压力，MyBatis 会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到SqlSession 中，在允许的时间间隔内，对于完全相同的查询，MyBatis 会直接将缓存结果返回给用户，而不用再到数据库中查找。 1.3.4. SQL语句配置方式 传统的MyBatis 配置SQL 语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，MyBatis 引入了Mapper接口的概念，面向接口的引入，对使用注解来配置SQL 语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置XML文件了，但是，目前的MyBatis 只是对注解配置SQL 语句提供了有限的支持，某些高级功能还是要依赖XML配置文件配置SQL 语句。 1.3.5. 引导层 引导层是配置和启动MyBatis 配置信息的方式。 MyBatis 提供两种方式来引导MyBatis 基于XML配置文件的方式 基于Java API 的方式 Java Persistence with MyBatis 3(中文版) 第二章 引导MyBatis 2. Mybatis主要构件一起相互关系 Mybatis主要的核心部件（非全部） SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能 Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所需要的参数， ResultSetHandler 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合； TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换 MappedStatement MappedStatement维护了一条&amp;lt;select update delete insert&amp;gt;节点的封装， SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回 BoundSql 表示动态生成的SQL语句以及相应的参数信息 Configuration MyBatis所有的配置信息都维持在Configuration对象之中。 3. 实例分析 3.1. 数据准备 3.1.1. 数据库 --创建一个员工基本信息表 create table &quot;EMPLOYEES&quot;( &quot;EMPLOYEE_ID&quot; NUMBER(6) not null, &quot;FIRST_NAME&quot; VARCHAR2(20), &quot;LAST_NAME&quot; VARCHAR2(25) not null, &quot;EMAIL&quot; VARCHAR2(25) not null unique, &quot;SALARY&quot; NUMBER(8,2), constraint &quot;EMP_EMP_ID_PK&quot; primary key (&quot;EMPLOYEE_ID&quot;) ); comment on table EMPLOYEES is '员工信息表'; comment on column EMPLOYEES.EMPLOYEE_ID is '员工id'; comment on column EMPLOYEES.FIRST_NAME is 'first name'; comment on column EMPLOYEES.LAST_NAME is 'last name'; comment on column EMPLOYEES.EMAIL is 'email address'; comment on column EMPLOYEES.SALARY is 'salary'; --添加数据 insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (100, 'Steven', 'King', 'SKING', 24000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (101, 'Neena', 'Kochhar', 'NKOCHHAR', 17000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (102, 'Lex', 'De Haan', 'LDEHAAN', 17000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (103, 'Alexander', 'Hunold', 'AHUNOLD', 9000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (104, 'Bruce', 'Ernst', 'BERNST', 6000.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (105, 'David', 'Austin', 'DAUSTIN', 4800.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (106, 'Valli', 'Pataballa', 'VPATABAL', 4800.00); insert into EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY) values (107, 'Diana', 'Lorentz', 'DLORENTZ', 4200.00); 3.1.2. Mybatis配置文件 mybatisConfig.xml &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&quot;development&quot;&amp;gt; &amp;lt;environment id=&quot;development&quot;&amp;gt; &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt; &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt; &amp;lt;property name=&quot;driver&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot; /&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:xe&quot; /&amp;gt; &amp;lt;property name=&quot;username&quot; value=&quot;louis&quot; /&amp;gt; &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot; /&amp;gt; &amp;lt;/dataSource&amp;gt; &amp;lt;/environment&amp;gt; &amp;lt;/environments&amp;gt; &amp;lt;mappers&amp;gt; &amp;lt;mapper resource=&quot;com/louis/mybatis/domain/EmployeesMapper.xml&quot;/&amp;gt; &amp;lt;/mappers&amp;gt; &amp;lt;/configuration&amp;gt; 3.1.3. 创建Employee实体Bean 以及配置Mapper配置文件 package com.louis.mybatis.model; import java.math.BigDecimal; public class Employee { private Integer employeeId; private String firstName; private String lastName; private String email; private BigDecimal salary; public Integer getEmployeeId() { return employeeId; } public void setEmployeeId(Integer employeeId) { this.employeeId = employeeId; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public BigDecimal getSalary() { return salary; } public void setSalary(BigDecimal salary) { this.salary = salary; } } &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt; &amp;lt;mapper namespace=&quot;com.louis.mybatis.dao.EmployeesMapper&quot; &amp;gt; &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.louis.mybatis.model.Employee&quot; &amp;gt; &amp;lt;id column=&quot;EMPLOYEE_ID&quot; property=&quot;employeeId&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt; &amp;lt;result column=&quot;FIRST_NAME&quot; property=&quot;firstName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;LAST_NAME&quot; property=&quot;lastName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;EMAIL&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt; &amp;lt;result column=&quot;SALARY&quot; property=&quot;salary&quot; jdbcType=&quot;DECIMAL&quot; /&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &amp;gt; select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY from LOUIS.EMPLOYEES where EMPLOYEE_ID = #{employeeId,jdbcType=DECIMAL} &amp;lt;/select&amp;gt; &amp;lt;/mapper&amp;gt; MAVEN依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;10.2.0.4.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3.1.4. 演示代码 package com.louis.mybatis.test; import java.io.InputStream; import java.util.HashMap; import java.util.List; import java.util.Map; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.louis.mybatis.model.Employee; /** * SqlSession 简单查询演示类 * @author louluan */ public class SelectDemo { public static void main(String[] args) throws Exception { /* * 1.加载mybatis的配置文件，初始化mybatis，创建出SqlSessionFactory，是创建SqlSession的工厂 * 这里只是为了演示的需要，SqlSessionFactory临时创建出来，在实际的使用中，SqlSessionFactory只需要创建一次，当作单例来使用 */ InputStream inputStream = Resources.getResourceAsStream(&quot;mybatisConfig.xml&quot;); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); //2. 从SqlSession工厂 SqlSessionFactory中创建一个SqlSession，进行数据库操作 SqlSession sqlSession = factory.openSession(); //3.使用SqlSession查询 Map&amp;lt;String,Object&amp;gt; params = new HashMap&amp;lt;String,Object&amp;gt;(); params.put(&quot;min_salary&quot;,10000); //a.查询工资低于10000的员工 List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params); //b.未传最低工资，查所有员工 List&amp;lt;Employee&amp;gt; result1 = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;); System.out.println(&quot;薪资低于10000的员工数：&quot;+result.size()); //~output : 查询到的数据总数：5 System.out.println(&quot;所有员工数: &quot;+result1.size()); //~output : 所有员工数: 8 } } 3.2. SqlSession工作工程分析 3.2.1. 开启一个数据库访问会话–创建SqlSession对象 SqlSession sqlSession = factory.openSession(); Mybatis封装了对数据库的访问，把对数据库的会话和事务控制放到了SqlSession对象中。 3.2.2. 为SqlSession传递一个配置的SQL语句StatementId和参数，然后返回结果 List&amp;lt;Employee&amp;gt; result = sqlSession.selectList(&quot;com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary&quot;,params); com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary是配置在xml中的statementId， params是传递的查询参数。 selectList的默认实现 @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) { return this.selectList(statement, parameter, RowBounds.DEFAULT); } @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) { try { //1、根据Statement Id，在mybatis 配置对象Configuration中查找和配置文件相对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); //2、将查询任务委托给Mybatis的执行器Execute return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error querying database. Cause: &quot; + e, e); } finally { ErrorContext.instance().reset(); } } MyBatis在初始化的时候，会将MyBatis的配置信息全部加载到内存中，使用org.apache.ibatis.session.Configuration实例来维护。使用者可以使用sqlSession.getConfiguration()方法来获取。MyBatis的配置文件中配置信息的组织格式和内存中对象的组织格式几乎完全对应的。上述例子中的 &amp;lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; &amp;gt; select EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY from LOUIS.EMPLOYEES &amp;lt;if test=&quot;min_salary != null&quot;&amp;gt; where SALARY &amp;lt; #{min_salary,jdbcType=DECIMAL} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt; 会加载到内存中生成一个对应的MappedStatement对象，然后以 key = com.louis.mybatis.dao.EmployeesMapper.selectByMinSalary, value = MappedStatement对象的形式维护到Configuration的一个Map中。 总结： SqlSession根据Statement ID, 在mybatis配置对象Configuration中获取到对应的MappedStatement对象，然后调用mybatis执行器来执行具体的操作。 3.2.3. Mybatis执行器Executor根据SqlSession传递的参数执行query()方法 /** * BaseExecutor 类部分代码 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { // 1.根据具体传入的参数，动态地生成需要执行的SQL语句，用BoundSql对象表示 BoundSql boundSql = ms.getBoundSql(parameter); // 2.为当前的查询创建一个缓存Key CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } @SuppressWarnings(&quot;unchecked&quot;) public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId()); if (closed) throw new ExecutorException(&quot;Executor was closed.&quot;); if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) { clearLocalCache(); } List&amp;lt;E&amp;gt; list; try { queryStack++; list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null; if (list != null) { handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); } else { // 3.缓存中没有值，直接从数据库中读取数据 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); } } finally { queryStack--; } if (queryStack == 0) { for (DeferredLoad deferredLoad : deferredLoads) { deferredLoad.load(); } deferredLoads.clear(); // issue #601 if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) { clearLocalCache(); // issue #482 } } return list; }  private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { List&amp;lt;E&amp;gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try { //4. 执行查询，返回List 结果，然后 将查询的结果放入缓存之中 list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); } finally { localCache.removeObject(key); } localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) { localOutputParameterCache.putObject(key, parameter); } return list; } /** * *SimpleExecutor类的doQuery()方法实现 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { Statement stmt = null; try { Configuration configuration = ms.getConfiguration(); //5. 根据既有的参数，创建StatementHandler对象来执行查询操作 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); //6. 创建java.Sql.Statement对象，传递给StatementHandler对象 stmt = prepareStatement(handler, ms.getStatementLog()); //7. 调用StatementHandler.query()方法，返回List结果集  return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); } finally { closeStatement(stmt); } } 上述的Executor.query()方法几经转折，最后会创建一个StatementHandler对象，然后将必要的参数传递给StatementHandler，使用StatementHandler来完成对数据库的查询，最终返回List结果集。 总结 根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用； 为查询创建缓存，以提高性能 创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果 3.2.4. StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回 看一下：prepareStatement() 方法的实现 /** * *SimpleExecutor类的doQuery()方法实现 * */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException { Statement stmt = null; try { Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 1.准备Statement对象，并设置Statement对象的参数 stmt = prepareStatement(handler, ms.getStatementLog()); // 2. StatementHandler执行query()方法，返回List结果 return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler); } finally { closeStatement(stmt); } } private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException { Statement stmt; Connection connection = getConnection(statementLog); stmt = handler.prepare(connection); //对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数 handler.parameterize(stmt); return stmt; } 总结 对于JDBC的PreparedStatement类型的对象，创建的过程中，我们使用的是SQL语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。 StatementHandler通过parameterize(statement)方法对Statement进行设值； StatementHandler通过List query(Statement statement, ResultHandler resultHandler)方法来完成执行Statement，和将Statement对象返回的resultSet封装成List； 3.2.5. StatementHandler 的parameterize(statement) 方法的实现 /** * StatementHandler 类的parameterize(statement) 方法实现 */ public void parameterize(Statement statement) throws SQLException { //使用ParameterHandler对象来完成对Statement的设值 parameterHandler.setParameters((PreparedStatement) statement); } /** * *ParameterHandler类的setParameters(PreparedStatement ps) 实现 * 对某一个Statement进行设置参数 */ public void setParameters(PreparedStatement ps) throws SQLException { ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId()); List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) { for (int i = 0; i &amp;lt; parameterMappings.size(); i++) { ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) { Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params value = boundSql.getAdditionalParameter(propertyName); } else if (parameterObject == null) { value = null; } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) { value = parameterObject; } else { MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); } // 每一个Mapping都有一个TypeHandler，根据TypeHandler来对preparedStatement进行设置参数 TypeHandler typeHandler = parameterMapping.getTypeHandler(); JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;amp;&amp;amp; jdbcType == null) jdbcType = configuration.getJdbcTypeForNull(); // 设置参数 typeHandler.setParameter(ps, i + 1, value, jdbcType); } } } } 总结 StatementHandler 的parameterize(Statement) 方法调用了 ParameterHandler的setParameters(statement) 方法 ParameterHandler的setParameters(Statement)方法负责 根据我们输入的参数，对statement对象的 ? 占位符处进行赋值。 3.2.6. StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现 /** * PreParedStatement类的query方法实现 */ public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException { // 1.调用preparedStatemnt。execute()方法，然后将resultSet交给ResultSetHandler处理 PreparedStatement ps = (PreparedStatement) statement; ps.execute(); //2. 使用ResultHandler来处理ResultSet return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps); } /** *ResultSetHandler类的handleResultSets()方法实现 * */ public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException { final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps(); int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) { ResultMap resultMap = resultMaps.get(resultSetCount); //将resultSet handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) { while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) { ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) { String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); } rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } } return collapseSingleResultList(multipleResults); } StatementHandler 的List query(Statement statement, ResultHandler resultHandler)方法的实现，是调用了ResultSetHandler的handleResultSets(Statement) 方法。ResultSetHandler的handleResultSets(Statement) 方法会将Statement语句执行后生成的resultSet 结果集转换成List 结果集 // // DefaultResultSetHandler 类的handleResultSets(Statement stmt)实现 //HANDLE RESULT SETS // public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException { final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps(); int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) { ResultMap resultMap = resultMaps.get(resultSetCount); //将resultSet handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) { while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) { ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) { String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); } rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; } } return collapseSingleResultList(multipleResults); }</summary></entry></feed>